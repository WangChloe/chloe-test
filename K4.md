<!-- MarkdownTOC -->

- 1.9
	- 1. H5
	- 2. toString\(\) && valueOf\(\)
	- 3. JSON
	- 4. css3
- 1.10
	- 4. css3
- 1.16
	- H5地理位置 geolocation
	- H5 audio
	- H5 video
- 1.17
	- H5 FileReader
- 1.18
	- H5 webSocket 网络套接字
	- 映像劫持
- 1.19
	- 移动端
- 2.6
	- css3媒体查询 media
	- 解决移动端click事件延迟 fastclick.js
	- 移动端多点触控 hammer.js
	- 移动端下拉刷新 iScroll.js
	- jQueryMobile
	- 移动端触摸滑动 Swiper.js
	- 轻量级移动端框架 zepto.js
- 2.7
	- H5 canvas
	- 应用 canvas运动回调
	- canvas框架 jCanvaScript.js
- 2.13
	- Hybrid App
	- 移动应用程序开发
	- SVG
	- SVG应用
- 2.14
	- Sass
	- ES6
	- Bootstrap
	- React
	- 高级运动

<!-- /MarkdownTOC -->


##1.9

### 1. H5
[翻译-你必须知道的28个HTML5特征、窍门和技术](http://www.zhangxinxu.com/wordpress/2010/08/%E7%BF%BB%E8%AF%91-%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8428%E4%B8%AAhtml5%E7%89%B9%E5%BE%81%E3%80%81%E7%AA%8D%E9%97%A8%E5%92%8C%E6%8A%80%E6%9C%AF/)

[html5shiv项目让IE6-IE9浏览器都支持HTML5中的元素](http://www.zhangxinxu.com/wordpress/2013/02/github-html5shiv-readme-translate/)

#### 1.1 选择器补充
querySelector() 匹配指定 CSS 选择器的一个元素
querySelectorAll() 匹配指定 CSS 选择器的所有元素。
> 注意：querySelectorAll()方法得到的类数组对象是非动态实时的

querySelectorAll对比getElements的优势
-> 可以操作数组
``` html
	<div class="box"></div>
	<div class="box"></div>
	<div class="box"></div>
```

``` javascript
	<script>
		var aBox = document.querySelectorAll('div');
		// var aBox = document.getElementsByTagName('div');	// 该方法得到的是伪数组，不能操作各项的属性

		// for (var i = 0; i < aBox.length; i++) {
		// 	aBox[i].onclick = function() {
		// 		alert(1);
		// 	}
		// }

		// 循环深入

		aBox.forEach(function(item, index) {
			item.onclick = function() {
				alert(index);	// 弹出当前点击div的索引值 依次为0、1、2
			}
		})
	</script>
```

**jQuery的选择器即是querySelectorAll**

``` javascript
<script>
	function $(selector) {
		var items = document.querySelectorAll(selector);

		if (items.length > 1) {
			return items;
		} else if (items.length == 0) {
			return;
		} else {
			return items[0];
		}
	}
</script>
```

#### 1.2 H5自定义属性dataset

[HTML5自定义属性对象Dataset简介](http://www.zhangxinxu.com/wordpress/2011/06/html5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1dataset%E7%AE%80%E4%BB%8B/)

[HTML5 datalist在实际项目中应用的可行性研究](http://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/)

示例
``` html
	<a data-link="#" data-user-name="chloe">baidu.com</a>
```

``` javascript
	<script>
		var oA = document.querySelector('a');
		oA.dataset.link = 'https://www.baidu.com';
		oA.href = oA.dataset.link + '?name=' + oA.dataset.userName;	// https://www.baidu.com/?name=chloe
		// 注意：两个及以上属性名调用时需转化为驼峰命名
	</script>
```
#### 1.3 H5元素类名操作classList

[HTML5 DOM元素类名相关操作API classList简介](http://www.zhangxinxu.com/wordpress/2013/07/domtokenlist-html5-dom-classlist-%E7%B1%BB%E5%90%8D/)

``` html
<!-- 该示例来源于张鑫旭个人博客 -->
<body class="a b c"></body>
```

``` javascript
<script>
	console.log(document.body.classList);
	console.log(document.body.className);
	console.log(document.body.classList.toString() === document.body.className;)	// true
</script>
```

> HTML5 DOM元素类名相关操作API classList简介>>>测试

![HTML5 DOM元素类名相关操作API classList简介>>>测试](http://img.blog.csdn.net/20170110000715296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzk1MDkxNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

隐式原型上的方法：(不一一列举)
- obj.add(cName1, cName2, ...);
- obj.remove(cName1, cName2, ...);
- obj.toggle(cName);
- obj.contains(cName);

#### 1.4 H5本地存储localStorage

**坑：首先注意name这个独特的变量名**

``` javascript
<script>
	alert(name);	// 第一次 ''  刷新浏览器 'chloe'
	alert(a);		// 第一次 undefined  刷新浏览器 'undefined'
	// console.log(name);
	// console.log(a);
	var name = 'chloe';
	var a = 'aaa';
</script>
```

解释：(源自[JavaScript 保留关键字](http://www.runoob.com/js/js-reserved.html))


![js内置属性](http://img.blog.csdn.net/20170110134557301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzk1MDkxNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


[HTML5 localStorage本地存储实际应用举例](http://www.zhangxinxu.com/wordpress/2011/09/html5-localstorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/)

**cookie && localStorage && sessionStorage** (来源CSDN)
- 共同点：
     都是保存在浏览器端，且同源的。
- 不同点：

1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

2. cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。

3. 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

4. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。

5. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

6. Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。


##### 1.4.1 Web Storage实际上由两部分组成：sessionStorage与localStorage。

- sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。

- localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

> 兼容：可以先测试，以确定window.localStorage是否存在。

sessionStorage与localStorage操作相同

- 设置

	`localStorage.key = value;`

	`localStorage.setItem(key,value);`

``` javascript
<script>
	var userName = 'chloe';

	//存储，IE6~7 cookie 其他浏览器HTML5本地存储
	if (window.localStorage) {
		localStorage.setItem("name", userName);
	} else {
		Cookie.write("name", userName);	// MooTools框架下cookie的写法
	}
</script>
```

- 读取

	`localStorage.key;`

	`localStorage.getItem(key);`

``` javascript
<script>
	var userName = window.localStorage ? localStorage.getItem("name") : Cookie.read("name"); // MooTools框架下cookie的写法
</script>
```

- 遍历

``` javascript
<script>
	var storage = window.localStorage;
	for (var i = 0, len = storage.length; i < len; i++) {
		var key = storage.key(i);
		var value = storage.getItem(key);
		console.log(key + "=" + value);
	}
</script>
```

- 删除

	`delete localStorage.key;`

	`localStorage.removeItem(key);`

``` javascript
<script>
	if (window.localStorage) {
		localStorage.removeItem("name");
	} else {
		Cookie.dispose('name'); // MooTools框架下cookie的写法
	}
</script>
```

- 清空

	`localStorage.clear();`

> window.onstorage 监听localstorage变化

### 2. toString() && valueOf()
toString() 把一个逻辑值转换为字符串，并返回结果

valueOf()  返回 Boolean 对象的原始值

> 源自知乎

>这两个方法一般是交由JS去隐式调用，以满足不同的运算情况。

>在数值运算里，会优先调用valueOf()，如a + b；

>在字符串运算里，会优先调用toString()，如alert(c)。

``` javascript
<script>
	// 该示例来源于脚本之家
	var bbb = {
		i: 10,
		toString: function() {
			console.log('toString');
			return this.i;
		},
		valueOf: function() {
			console.log('valueOf');
			return this.i;
		}
	}

	alert(bbb); // 10 toString
	alert(+bbb); // 10 valueOf
	alert('' + bbb); // 10 valueOf
	alert(String(bbb)); // 10 toString
	alert(Number(bbb)); // 10 valueOf
	alert(bbb == '10'); // true valueOf
	alert(bbb === '10'); // false
</script>

```

``` javascript
<script>
	console.log({
		valueOf: function() {
			return 20;
		}
	} * {
		valueOf: function() {
			return 30;
		}
	});		// 600
</script>
```

### 3. JSON

之前的例子

1.JSON.stringify(object);	// 对象 -> 字符串

eg: `{a:1,b:2}` -> `"{"a":1,"b":2}"`

2.JSON.parse(str);		// 字符串 -> json对象

`{"name":"huangxiaojian","age":"23"}'` ->
`{`
	`age: "23"`
	`name: "huangxiaojian"`
	`__proto__: Object`
`}`


JSON.stringify(object) 将对象字符串序列化成标准JSON字符串

JSON.parse(str)        将字符串序列化成对象

``` html
<a href="https://www.baidu.com/" attr1='13'>baidu.com</a>
```

``` javascript
<script>
	var oA = document.querySelector('a');
	console.log(oA.getAttribute('attr1')); // 13

	oA.setAttribute('attr1', '14');
	var number = oA.getAttribute('attr1');
	console.log(oA.getAttribute('attr1')); // 14
	console.log(typeof number);	// string 直接设置自定义属性只能得到string类型

	oA.setAttribute('attr1', JSON.stringify({
		name: 14
	}));

	var number2 = oA.getAttribute('attr1');

	console.log(number2); // {"name": "14"}
	console.log(JSON.parse(number2)); // -> Object {name: "14"}
									  // 		name: "14"
									  // 		-> _proto_: Object
	console.log(JSON.parse(number2).name); // 14
	console.log(typeof JSON.parse(number2).name); // number JSON转化得到了真正类型
</script>
```


### 4. css3
#### 4.1 border-radius
10px 20px 30px 40px -> 左上角起顺时针经过的角的顺序

10px 20px 30px 40px / 30px 10px 40px 20px

/ -> 分离x/y轴方向半径

#### 4.2 box-shadow
[inset]  10px   20px   30px      40px   black;

[内阴影] x位移 y位移 模糊半径  弥散半径 颜色

多边框实例
``` css
<style>
	#box{
		width: 100px;
		height: 100px;
		box-shadow: 0 0 0 10px black,
					0 0 0 20px green,
					0 0 0 30px pink,
					0 0 0 40px purple,
					0 0 0 50px orange,
					0 0 0 60px khaki,
					0 0 0 70px indigo,
					0 0 0 80px plum,
					0 0 0 90px violet;
		margin: 200px auto;
	}
</style>
```

##1.10

### 4. css3
#### 4.3 transform(搭配transition使用效果更佳)
**以下属性可以一同使用**

- rotate([deg]) 旋转

`tansform: rotate(30deg);` 正向旋转30度
`tansform: rotate(0.785rad);` 正向旋转0.785弧度
`tansform: rotateX|Y|Z(45deg);`
> 角度转弧度 π/180×角度
弧度变角度 180/π×弧度

transofrm-origin 旋转中心

eg:
`transofrm-origin: left|top|bottom|right|center(默认);`
`transofrm-origin: left top|left bottom|right top|left center|center bottom;`
`transofrm-origin: -120px -120px;`

- translate(x, y) 偏移
x>0 右偏移
x<0 左偏移
y>0 下偏移
y<0 上偏移

`transform: translate(-30px, -40px);` 左偏移30px, 右偏移40px
`transform: translateX|Y|Z(-30px);`

- scale(s); 放大/缩小

`transform: scale(0.2)` 宽高缩小至0.2倍的大小
`transform: scale(0.2, 1)` 宽度缩小至0.2倍大小，高度不变
`transform: scaleX|scaleY(0.2)`


- skew([deg]) 倾斜

`transform: skew(20deg)` 水平向左倾斜20度
`transform: skewX(20deg)` 水平向左倾斜20度
`transform: skewY(20deg)` 垂直向上倾斜20度
`transform: skew(20deg, 20deg)` 水平向左倾斜20度，垂直向上倾斜20度


- 关于多属性
transform多属性时从后向前解析

eg:
`transform: rotate(45deg) scale(2,1);`	先横向放大再旋转
`transform: scale(2,1) rotate(45deg);`  先旋转再横向放大

#### 4.4 transition
transition([]); 过渡

transition 属性是一个简写属性，用于设置**四个过渡属性**：

- transition-property 设置过渡效果的 CSS 属性的名称
- transition-duration 完成过渡效果需要多少秒
- transition-timing-function 速度效果的速度曲线
	- linear      匀速等于 cubic-bezier(0,0,1,1)
    - ease	      慢速开始，然后变快，然后慢速结束 cubic-bezier(0.25,0.1,0.25,1)
    - ease-in     慢速开始 等于 cubic-bezier(0.42,0,1,1)
    - ease-out	  慢速结束 等于 cubic-bezier(0,0,0.58,1)
    - ease-in-out 慢速开始和结束 等于 cubic-bezier(0.42,0,0.58,1)
    - cubic-bezier(n,n,n,n)
- transition-delay 过渡效果何时开始

eg:
``` css
<style>
	#box{
		width: 200px;
		height: 200px;
		background-color: green;
		transition: 1s width cubic-bezier(1, 1.7, 0, 1.54) 1s;	/* 1s后由400px过渡到200px */
	}
	#box:active{
		width: 400px;
		transition: 0s;	/* 按下0s后变为400px */
	}
</style>
```
#### 4.5 animation
animation([]); 动画

animation 属性是一个简写属性，用于设置**六个动画属性**：

- animation-name 需要绑定到选择器的 keyframe 名称
- animation-duration 完成动画所花费的时间
- animation-timing-function 动画的速度曲线
- animation-delay 在动画开始之前的延迟
- animation-iteration-count 动画应该播放的次数
	- n	       播放次数
	- infinite 无限次播放
- animation-direction 是否应该轮流反向播放动画
	- alternate	轮流反向播放
	- reverse   反向播放
	- alternate-reverse 反向交替播放
- animation-fill-mode 结束状态
	- forwards  停留在结束状态
	- backwards 返回原始状态
- animation-play-state 暂停动画
	- paused   动画已暂停
	- running 动画正在播放

keyframe 关键帧
``` css
<style>
	@keyframes name{
		from{

		}
		to{

		}

		10%{

		}
		20%{

		}
		100%{

		}
	}
</style>
`

#### 4.6 perspective
perspective 视角

指定观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果

[小tip: 纯CSS实现视差滚动效果](http://www.zhangxinxu.com/wordpress/2015/03/css-only-parallax-effect/)
[好吧，CSS3 3D transform变换，不过如此！](http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/)

perspective属性有两种书写形式，一种用在舞台元素上（动画元素们的共同父辈元素）；第二种就是用在当前动画元素上，与transform的其他属性写在一起

1. perspective:800px; -> 给当前元素的子集增加视角
2. transform:perspective(800px)(必须最前面) rotate... -> 给当前元素增加视角

开启3D空间

transform-style:preserve-3d;
加给3D变化元素父集,不可继承

transform-style: preserve-3d

#### 4.6 direction
文字转向 需配合unicode-bidi使用

`direction: rtl; unicode-bidi: bidi-override;`

#### 4.7 -webkit-mask
遮罩
**webkit下神奇的图层蒙版效果**

`-webkit-mask: url(xxx.jpg);` 背景按mask图片大小显示
`-webkit-mask:linear-gradient(rgba(0,0,0,1)), to(rgba(0,0,0,0);` 背景按渐变遮罩显示

#### 4.8 box-reflect
倒影

[-webkit-box-reflect各个属性值效果演示](http://www.zhangxinxu.com/study/201608/-webkit-box-reflect.html)

box-reflect：none | <direction> <offset>? <mask-box-image>?

方向<direction> = above | below | left | right
间隔<offset> = <length> | <percentage>
遮罩<mask-box-image> = none | <url> | <linear-gradient> | <radial-gradient> | <repeating-linear-gradient> | <repeating-radial-gradient>

#### 4.9 text-shadow
文字阴影
`text-shadow: x-shadow y-shadow [blur] [color];`

水平阴影位置 垂直阴影位置 模糊的距离 阴影颜色

#### 4.10 resize
是否允许用户调整元素的尺寸

`resize: none`			用户无法调整元素的尺寸
`resize: both`			用户可调整元素的高度和宽度
`resize: horizontal`	用户可调整元素的宽度
`resize: vertical`		用户可调整元素的高度

#### 4.11 background-image内的一些属性
- linear-gradient 线性渐变

background:linear-gradient(direction, start-color, stop-color);

direction:
to top    ->	0deg   -> 从下到上
to right  ->	90deg  -> 从左到右
to bottom ->	180deg -> 从上到下（默认值）
to left	  ->    270deg -> 从右到左
to top left	 ->	右上角到左上角（斜对角）
to top right ->	左下角到右上角（斜对角）

eg:
`background-image: linear-gradient(red,blue);`
`background-image: linear-gradient(250deg,red,blue);`
`background-image: linear-gradient(red,orange,yellow,green,blue,indigo,violet);`
`background-image: linear-gradient(red 50%,blue 50%);` 跳变
`background-image: linear-gradient(90deg,blue 33.33333%,white 33.33333%,white 66.66666%,red 66.66666%,red 100%);` 0~1/3是蓝色 1/3~2/3是白色 2/3~1是红色

- radial-gradient 径向渐变

background:radial-gradient(position ,shape size, start-color, stop-color);

position 圆心位置

shape:
circle	定义径向渐变为“圆形”
ellipse	定义径向渐变为“椭圆形”

size:
closet-side	指定径向渐变的半径长度为从圆心到离圆心最近的边
closest-corner	指定径向渐变的半径长度为从圆心到离圆心最近的角
farthest-side	指定径向渐变的半径长度为从圆心到离圆心最远的边
farthest-corner	指定径向渐变的半径长度为从圆心到离圆心最远的角

eg:
`background-image: radial-gradient(red,blue);` 内圆红色，外框蓝色
`background-image: radial-gradient(red,orange,yellow,green,blue,indigo,violet);border-radius: 50%;`
`background-image: radial-gradient(circle,red 30%,white 30%);`
`background-image: -webkit-radial-gradient(100px 100px,circle farthest-corner,red,blue);`
`background-image: -webkit-radial-gradient(100px 100px,circle farthest-side,red,blue);`
`background-image: -webkit-radial-gradient(150px 100px,200px 80px,red,blue);`


- repeating-linear-gradient 重复渐变
eg:
`background-image: repeating-linear-gradient(red,blue 20%);`


#### 4.12 background相关属性
- background-origin 相对于内容框来定位背景图像

`background-origin: border-box;`  相对于边框盒来定位背景图像：
`background-origin: content-box;` 相对于内容框来定位背景图像：
`background-origin: padding-box;` 相对于内边距框来定位背景图像：

- background-clip 裁剪背景图片

`background-clip: border-box;`  相对于边框盒来定位背景图像：
`background-clip: content-box;` 相对于内容框来定位背景图像：
`background-clip: padding-box;` 相对于内边距框来定位背景图像：

**webkit下神奇的图层蒙版效果**
- webkit-background-clip(字内显示图片)
eg:
``` css
<style>
	#box {
		width: 200px;
		height: 200px;
		background: url(xxx.jpg);
		background-size: cover;
		-webkit-background-clip: text;
		font-size: 200px;
		font-weight: bolder;
		color: rgba(0, 0, 0, 0.1);
	}
</style>
```
``` html
	<div id="box">品</div>
```

- background-attachment
`background-attachment: scroll` 默认值。背景图像会随着页面其余部分的滚动而移动。
`background-attachment: fixed`	当页面的其余部分滚动时，背景图像不会移动。

[图片覆盖切换效果](http://wangchloe.vip/Demo/CSS3/background-attachment)

- background-size 背景图像尺寸

`background-size: 3em, 25%;`  自定义背景图像尺寸
`background-size: cover;`     使背景图像完全覆盖背景区域(图像可能被裁剪)
`background-size: contain;`   完全包含背景图(no-repeat背景区域可能有空白)

- background-position 背景图像定位

`background-position: center|top|right|bottom|left`
`background-position: 20px 20%`

#### 4.13 fliter(滤镜)的属性
[CSS3 Filter的十种特效](http://www.w3cplus.com/css3/ten-effects-with-css3-filter)

- blur 模糊
eg:
`filter: blur(20px);`

- drop-shadow 阴影
[CSS3 filter:drop-shadow滤镜与box-shadow区别应用](http://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/)
eg:
`filter: drop-shadow(100px 1px 2px black);`

- invert 反色
eg:
`filter: invert(0.7);`

- brightness 亮度
eg:
`filter: brightness(.5);`

- sepia 褐色
eg:
`filter: sepia(1);`

- hue-rotate 色相旋转
eg:
`filter: hue-rotate(30deg);`

- saturate 饱和度
eg:
`filter: saturate(10);`



### 5. 库&&框架
库：lib，方法库，或组件库。核心库是给二次开发同学用的，它严谨、符合标准、独立健壮、无污染。eg: jQuery

框架：framework，主要是给用户使用，当然也给二次开发者用，它易使用、易扩展、可持续发展、可控。 eg: Angular.js

[框架和类库的区别](http://blog.sina.com.cn/s/blog_732ae613010155gj.html)

### 6. H5新增标签
header -> 头部
footer -> 底部
nav -> 导航
section -> 部分
aside -> 侧边栏
article -> 文章
mark -> 高亮(默认黄底高亮)
datalist -> 用input的list属性配合datalist的id属性 生成 可输入下拉框
dialog -> 定义对话框或窗口

meter -> 度量条
eg:
`<meter value="3" min="0" max="10">3/10</meter><br>
<meter value="0.6">60%</meter>`

progress -> 下载进度条
eg:
`<progress max="100"></progress>
<progress value="22" max="100"></progress>`

address -> 地址
summary -> 总结/梗概(下拉按钮展开details内容)
details -> summary里 -> 详情
eg:
`<details>
<summary>HTML 5</summary>
This document teaches you everything you have to learn about HTML 5.
</details>`

figure -> 内容相关，去掉不影响理解的内容
figcaption -> figure里
`<figure>
  <img src="xxx.jpg">
  <figcaption>描述</figcaption>
</figure>`

time -> 时间

### 7. CSS3新增选择器
####属性选择器
[attr=value] -> 匹配属性
[attr^=value] -> 匹配开头
[attr$=value] -> 匹配结尾
[attr|=value] -> 匹配value-开头
[attr~=value] -> 匹配空格隔开的单词

####结构选择器
:nth-child(n) -> 数字 从1开始
:nth-child(2n/2n-1/2n+1) -> 表达式
:nth-child(odd/even) -> 关键字
:nth-last-child(n/表达式) -> 倒着算
:first-child -> 选中第一项
:last-child -> 选中最后一项

####文字伪类选择器 -> p
:first-letter
:first-line
::selection

####其他选择器
:not() -> 反选
:after -> 从后面增加
:before -> 从前面增加
:target -> 被锚点锚住的元素

更详细的内容 css3.md && html5.md

##1.10

###CSS3
####老版浏览器的内核前缀

css

-webkit-transition: 1s;
-moz-transition: 1s;
-o-transition: 1s;
transition:	1s;

js(去掉-, 首字母大写)

WebkitTransition
MozTransition
OTransition

####属性选择器
**兼容：IE7+**

- E[attr]
- E[attr="value"]  **只含一个属性值**
- E[attr~="value"]   attr属性值包含value
- E[attr^="value"]   attr属性值以value开头
- E[attr$="value"]   attr属性值以value结束
- E[attr*="value"]   attr属性值包含value字符
- E[attr|="value"]   attr属性值是value或者"value-"开头  **只含一个属性值**


``` css
<style>
	p[attr1] {
		background: #f00;
	}
	p[attr1=a] {
		background: #0ff;
	}
	p[attr1~=c] {
		background: #00f;
	}
	p[attr1^=e] {
		background: #ff0;
	}
	p[attr1$=g] {
		background: #f0f;
	}
	p[attr1*=i] {
		background: #0f0;
	}
	p[attr1|=k] {
		background: #fff;
	}
</style>
```

``` html
	<strong>E[attr="value"] **只含一个属性值**</strong>
   	<p attr1="a">attr1="a"</p>
   	<p attr1="b a">attr1="b a"</p>
   	<hr/>
   	<strong>E[attr~="value"] attr属性值包含value</strong>
   	<p attr1="c">attr1="c"</p>
   	<p attr1="d c">attr1="d c"</p>
   	<hr/>
   	<strong>E[attr^="value"] attr属性值以value开头</strong>
   	<p attr1="e">attr1="e"</p>
   	<p attr1="f ef">attr1="f ef"</p>
   	<p attr1="ef f">attr1="ef f"</p>
   	<hr/>
   	<strong>E[attr$="value"] attr属性值以value结束</strong>
   	<p attr1="g gh">attr1="g gh"</p>
   	<p attr1="h hg">attr1="h hg"</p>
   	<hr/>
   	<strong>E[attr*="value"] attr属性值包含value字符</strong>
   	<p attr1="i">attr1="i"</p>
   	<p attr1="j jij">attr1="j jij"</p>
   	<hr/>
   	<strong>E[attr|="value"] attr属性值是value或者"value-"开头  **只含一个属性值**</strong>
   	<p attr1="k">attr1="k"</p>
   	<p attr1="l k">attr1="l k"</p>
   	<p attr1="m k-m">attr1="m k-m"</p>
   	<p attr1="k-m">attr1="k-m"</p>

```

![css3属性选择器](http://img.blog.csdn.net/20170110165816536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzk1MDkxNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

####结构选择器
**兼容：IE9+**

**下标索引从1开始**

- `:nth-child(n) ` 找当前节点的父节点下的第n个子节点，**当且仅当该子节点与当前节点的类型相符时有效**

- `:nth-last-child(n)`  找当前节点的父节点下的倒数第n个子节点，**当且仅当该子节点与当前节点的类型相符时有效**

- `:nth-of-type(n)` 找当前节点的父节点下的第n个与当前节点的类型相符的子节点

- `:nth-last-of-type(n)` 找当前节点的父节点下的倒数第n个与当前节点的类型相符的子节点

- `:first-child`  即 :nth-child(1)

- `:last-child`  即 :nth-last-child(1)

- `:first-of-type`  即 :nth-of-type(1)

- `:last-of-type`  即 :nth-last-of-type(1)

- `:only-child`	  当前节点的父节点下只有一个子节点时有效

- `:only-of-type` 当前节点的父节点下与当前节点的类型相符的子节点只有一个时有效，可有多个其他类型子节点

---

- `:target`  设置跳转锚点属性  <a href="#div1"></a> -> <div id="div1"></div>

- `:disabled`  不可点击的表单控件

- `:enabled`   可点击的表单控件

- `:checked`   选中的checkbox/radio

- `A~B`        A元素后的第一个类型为B的兄弟节点    **应用：模拟checkbox**

- `:first-line`	当前节点的第一行

- `:first-letter` 当前节点的第一个字符

- `:not(x)`      不匹配x时有效

伪元素

- `::selection`  在当前节点内选中文字时有效

- `::before`     搭配content使用，在当前节点内容最前面插入content **不增加DOM**

- `::before`     搭配content使用，在当前节点内容最后面插入content **不增加DOM**

####颜色rgba
之前的opacity改变背景色透明度时同时改变文字颜色透明度

rgba可实现只改变背景色透明度

####文字阴影
text-shadow: [x轴 y轴 模糊度 弥散度 颜色]

x轴：正值 -> 向右 负值 -> 向左

y轴：正值 -> 向下 负值 -> 向上

阴影叠加

####文字省略text-overflow
``` css
<style>
	.ell {
		white-space: nowrap;  /* 不允许换行 */
		overflow: hidden;     /* 超出隐藏 */
		text-overflow: ellipsis;  /* 超出显示省略号，默认为clip(无省略号) */
	}
</style>
```


# html5
语法：
1. 内容类型
2. DOCTYPE声明
3. 指定字符编码
4. 可以省略标记的元素
5. 具有boolean值的属性
6. 省略行内属性赋值的引号

## 1. 新增元素
### 结构元素
#### section
对网站内容分块、分段
当容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section

结构(标题+内容)
``` html
<section>
	<h1></h1>
	<p></p>
</section>
```
#### article
代表文档内容 独立性 可嵌套使用
可看作特殊的section元素

常见结构
``` html
<article>
	<header>
		<h1></h1>
	</header>
	<article>
		<header>
			<h2></h2>
		</header>
		<p></p>
		<footer></footer>
	</article>
	<footer></footer>
</article>
```

#### aside
用来表示当前页面或文章的附属信息(相关引用、侧边栏、广告、导航条)

常见结构
``` html
<header>
	<h1></h1>
</header>
<article>
	<h1></h1>
	<p></p>
	<aside>
		<h1></h1>
		<p></p>
	</aside>
</article>
<aside>
	<nav>
		<h2>评论</h2>
		<ul>
			<li><a href="javascipt:;"></a></li>
			<li><a href="javascipt:;"></a></li>
		</ul>
	</nav>
</aside>
```

#### nav
常见应用：导航条、侧边栏导航、页内导航、翻页操作
**不能用menu元素代替nav元素**

常见结构
``` html
<nav>
	<ul>
		<li><a href="javascript:;"></a></li>
		<li><a href="javascript:;"></a></li>
	</ul>
</nav>

<article>
	<header>
		<nav>
			<ul>
				<li><a href="javascript"></a></li>
				<li><a href="javascript"></a></li>
			</ul>
		</nav>
	</header>
	<section>
		<h1></h1>
		<p></p>
	</section>
	<section>
		<h1></h1>
		<p></p>
	</section>
	<footer>
		<a href="javascript:;"></a>
		<a href="javascript:;"></a>
	</footer>
</article>
```

#### figure
#### time
用来区分各时区或编码

常见结构
``` html
	<time datetime="2017-1-1">2017-1-1</time>
	<time datetime="2017-1-1T20:00">2017-1-1</time>
```

#### pubdate
指明发布时间

常见结构
``` html
	<article>
		<header>
			<h1></h1>
			<p>
				<time datetime="2017-1-1" pubdate>2017-1-1</time>
			</p>
		</header>
	</article>
```
#### header
header可出现多次

常见结构
``` html
<header>
	<h1></h1>
	<nav>
		<ul>
			<li><a href=""></a></li>
			<li><a href=""></a></li>
			<li><a href=""></a></li>
		</ul>
	</nav>
</header>
<article>
	<header>
		<h1></h1>
	</header>
</article>
```

#### footer
footer可出现多次
常见应用：脚注(相关链接、版权信息)

常见结构
``` html
<footer>
	<ul>
		<li><a href="">版权信息</a></li>
		<li><a href="">联系我们</a></li>
		<li><a href="">加入我们</a></li>
	</ul>
</footer>
```
#### hgroup
将标题及其子标题进行分组

常见结构
``` html
<article>
	<header>
		<hgroup>
			<h1>主标题</h1>
			<h2>子标题</h2>
		</hgroup>
		<p>
			<time datetime="2017-1-1">2017-1-1</time>
		</p>
	</header>
	<div></div>
	<footer>
	</footer>
</article>
```

#### address
在文档中呈现联系信息(作者名字、网站连接、电子邮箱、地址、手机号)

常见结构
``` html
<address>
	<a href=""></a>
	<a href=""></a>
</address>
<footer>
	<div>
		<address>
			<a href=""></a>
		</address>
		<time datetime="2017-1-1">2017-1-1</time>
	</div>
</footer>
```

#### 整体应用
``` html
<header>
	<h1>xxx</h1>
	<nav>
		<ul>
			<li><a href="#">a1</a></li>
			<li><a href="#">a2</a></li>
		</ul>
	</nav>
</header>
<article>
	<hgroup>
		<h1>主标题</h1>
		<h2>子标题</h2>
	</hgroup>
	<p>正文</p>
	<section>
		<div>
			<article>
				<h1>评论标题</h1>
				<p>评论正文</p>
			</article>
		</div>
	</section>
</article>
<footer>
	<small>版权***</small>
</footer>

```

### 其他元素
#### video
不同浏览器支持的格式不同，可能需要转码，在source标签里引入多种格式

FF不支持mp4，支持ogg

controls属性显示自带控制进度条

常见结构
``` html
<html>
	<video src="xxx.mp4" controls></video>
	<hr>
	<video  controls>
		<source src="xxx.mp4">
		<source src="xxx.ogg">
	</video>
	<hr>
	<video src="xxx.mp4" id="v1" width="400px" height="200px"></video>
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var v1 = document.getElementById('v1');
	function play() {
		if(v1.paused) {
			v1.play();
		} else {
			v1.pause();
		}
	}
</script>
```

#### audio
controls属性显示自带控制进度条

常见结构
``` html
<html>
	<audio src="xxx.mp3" controls></audio>  <!-- 显示音频自带播放器样式 -->
	<hr>
	<audio src="xxx.mp3" id="a1"></audio>  <!-- 只显示下面的按钮 -->
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var a1 = document.getElementById('a1');
	function play() {
		if(a1.paused) {
			a1.play();
		} else {
			a1.pause();
		}
	}
</script>
```

#### canvas

...


### input元素类型
email
url
number
range

date
time

Date Pickers

### *废除的元素
能用CSS替代的元素：basefont、big、center、font、s、tt、u等
frame框架
只有部分浏览器支持的元素

## 2. 新增属性
### 表单相关属性
####form
form的元素可写在form外，只要指向相同id

常见结构
``` html
<form id="form1">
	<input type="text">
</form>
<textarea form="form1"></textarea>
```
#### formaction
不同表单元素不同action路径

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formaction="fc1">
	<input type="submit" name="s2" value="v2" formaction="fc2">
	<input type="submit" name="s3" value="v3" formaction="fc3">
</form>
```

#### formmethod
不同表单元素不同提交方法

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formmethod="get" formaction="fc1">
	<input type="submit" name="s2" value="v2" formmethod="post" formaction="fc2">
</form>
```
#### formmethod
不同表单元素不同编码方式

常见结构
``` html
<form id="form1">
	<input type="text" formenctype="text/plain" value="表单数据中的空格转换为加号">
	<input type="text" formenctype="multipart/form-data" value="文件上传">
	<input type="text" formenctype="application/x-www-form-urlencoded" value="get方式时把表单数据转换为字符">
</form>
<textarea form="form1"></textarea>
```

#### formtarget
不同表单元素不同提交后在何处打开加载页面

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formtarget="_blank" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_self" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_parent" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_top" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="framename" formaction="fc1">
</form>
```

#### autofocus
表单元素自动获得焦点

常见结构
``` html
<form id="form1">
	<input type="text" autofocus>
	<input type="text">
</form>
```

#### require
提交时内容为空不允许提交，并显示提示

常见结构
``` html
<form id="form1">
	<input type="text" required>
	<input type="text">
	<input type="submit">
</form>
```
#### labels
验证提示信息

常见结构
``` html
<form id="form1">
	<label for="t1" id="l1"></label>
	<input type="text" id="t1">
	<input type="button" id="btn1" value="验证" onclick="validate()">
</form>
```

``` javascript
<script>
	function validate() {
		var t1 = document.getElementById('t1');
		var btn1 = document.getElementById('btn1');
		var fm1 = document.getElementById('form1');

		if(t1.value.trim() == "") {
			var l1 = document.getElementById('l1');
			l1.setAttribute('for', 't1');
			f1.insertBefore(l1, btn1);	// 在button前显示验证提示信息
			t1.labels[1].innerHTML = '输入为空';
		}
	}
</script>
```

#### placeholder
输入提示信息

常见结构
``` html
<form id="form1">
	<input type="text" placeholder="请输入...">
</form>
```

#### datalist
可输入的下拉框

常见结构
``` html
<form id="form1">
	<input type="text" name="n1" list="ns">  <!-- 点击下拉箭头时显示datalist -->
	<datalist id="ns" style="display: none">
		<option value="v1">v1</option>
		<option value="v2">v2</option>
	</datalist>
</form>
```
#### autocomplete
输入自动填充

#### pattern
表单元素正则验证，输入错误时不跳转

常见结构
``` html
<form id="form1" action="xxx">
	<input type="text" pattern="{a-z}[3]" >
	<input type="submit">
</form>
```

#### selectionDirection
*Chrome不支持

#### indeterminate
复选框checkbox 的第三种状态 “尚未明确是否选取”状态

#### image按钮的width/height

### 链接相关属性
### 其他属性
### *废除属性

### 全局属性
contentEditable
designMode
hidden
spellcheck       拼写检查
tabindex         设置tab键焦点的顺序


##1.12

### css3应用

####拖拽

``` javascript
<script>
	var oBox = document.querySelector('div');

	oBox.onmousedown = function({
		clientX,
		clientY
	}) {
		var disX = clientX - (oBox.dataset.left || 0);
		var disY = clientY - (oBox.dataset.top || 0);

		console.log(oBox.offsetLeft, oBox.offsetTop);

		document.onmousemove = function({
			clientX,
			clientY
		}) {
			var deltaX = clientX - disX;
			var deltaY = clientY - disY;

			oBox.dataset.left = deltaX;
			oBox.dataset.top = deltaY;

			oBox.style.transform = `translate(${
				deltaX
			}px,${
				deltaY
			}px)`
		}

		document.onmouseup = function() {
			document.onmousemove = null;
			document.onmouseup = null;
		}
	}
</script>
``

##### ES6模板字符串 ``

[深入浅出ES6（四）：模板字符串](http://www.infoq.com/cn/articles/es6-in-depth-template-string)

``` javascript
<script>
	var x = 'a', y = 'b';
	var z = `${x,y}`;	 //'b'
</script>
```

#### 纯css3手风琴
``` css
<style>
	/* hover切换，默认初始收起  */
	.m-demo {
		width: 600px;
		height: 250px;
		overflow: hidden;
	}
	.m-demo li {
		float: left;
		width: 120px;
		heihgt: 100%;
		box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
		-webkit-transition: width 0.5s ease-out;
		-moz-transition: width 0.5s ease-out;
		-ms-transition: width 0.5s ease-out;
		transition: width 0.5s ease-out;
	}
	.m-demo:hover li:not(:hover) {
		width: 50px;
	}
	.m-demo li:hover {
		width: 400px;
	}

	/* 初始展开  */
	.m-demo-1 li {
		width: 50px;
	}
	.m-demo-1 li:first-child {
		width: 400px;
	}
</style>
```

``` html
<ul class="m-demo">
    <li><a href="#"><img src="http://nec.netease.com/img/m/1.jpg" alt=""/></a></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/2.jpg" alt=""/></a></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/3.jpg" alt=""/></a></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/4.jpg" alt=""/></a></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/5.jpg" alt=""/></a></li>
</ul>
<ul class="m-demo m-demo-1">
    <li><a href="#"><img src="http://nec.netease.com/img/m/1.jpg" alt=""/></a></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/2.jpg" alt=""/></a></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/3.jpg" alt=""/></a></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/4.jpg" alt=""/></a></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/5.jpg" alt=""/></a></li>
</ul>
```

#### 纯css3幻灯片
``` css
<style>
	/* hover切换  */
	.m-demo {
		position: relative;
		width: 400px;
		height: 250px;
		overflow: hidden;
	}
	.m-demo li:nth-child(3n-1) {
		position: absolute;
		opacity: 1;
		-webkit-transform: scale(1);
		-moz-transform: scale(1);
		-ms-transform: scale(1);
		transform: scale(1);
		-webkit-transition: transform 0.5s ease-out, opacity 0.5s ease-out;
		-moz-transition: transform 0.5s ease-out, opacity 0.5s ease-out;
		-ms-transition: transform 0.5s ease-out, opacity 0.5s ease-out;
		transition: transform 0.5s ease-out, opacity 0.5s ease-out;
	}
	.m-demo:hover li:nth-child(3n-1) {
		opacity: 0;
		-webkit-transform: scale(1.2);
		-moz-transform: scale(1.2);
		-ms-transform: scale(1.2);
		transform: scale(1.2);
	}
	.m-demo li:nth-child(2), .m-demo li:nth-child(3n-1):hover, .m-demo li:nth-child(3n+1):hover + li {
		z-index: 2;
		opacity: 1;
		-webkit-transform: scale(1);
		-moz-transform: scale(1);
		-ms-transform: scale(1);
		transform: scale(1);
	}
	.m-demo li:nth-child(3n+1), .m-demo li:nth-child(3n) {
		position: relative;
		z-index: 5;
		float: left;
		width: 10px;
		height: 10px;
		margin: 235px 0 0 5px;
		border-radius: 50%;
	}
	.m-demo li:nth-child(3n+1), .m-demo:hover li:nth-child(3n+1) {
		box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.5);
		background: rgba(0, 0, 0, 0.2);
	}
	.m-demo li:nth-child(3n) {
		z-index: 4;
		margin-left: -10px;
	}
	.m-demo li:first-child {
		margin-left: 325px;
	}
	.m-demo li:first-child, .m-demo li:nth-child(3n+1):hover, .m-demo li:nth-child(3n-1):hover + li {
		box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.5);
		background: rgba(255, 255, 0, 0.8);
	}
	.m-demo li:nth-child(3n-1):hover + li {
		z-index: 6;
	}
</style>
```

``` html
<ul class="m-demo">
    <li></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/1.jpg" alt=""/></a></li>
    <li></li>
    <li></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/2.jpg" alt=""/></a></li>
    <li></li>
    <li></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/3.jpg" alt=""/></a></li>
    <li></li>
    <li></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/4.jpg" alt=""/></a></li>
    <li></li>
    <li></li>
    <li><a href="#"><img src="http://nec.netease.com/img/m/5.jpg" alt=""/></a></li>
    <li></li>
</ul>

```

#### 无缝滚动
假设共有9涨不重复图片
每次显示5张

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	.container {
		width: 500px;
		height: 100px;
		border: 1px solid #000;
		overflow: hidden;
	}
	ul {
		height: 100px;
		width: 1400px;
		animation: ani 6s infinite linear;
	}
	ul:hover {
		animation-play-state: paused;
	}
	li {
		list-style: none;
		width: 100px;
		height: 100px;
		float: left;
		background-size: cover;
		text-align: center;
		line-height: 100px;
	}
	@keyframes ani {
		to {
			transform: translate(-900px);
		}
	}
</style>
```

``` html
<div class="container">
	<ul>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<!-- 无缝 -->
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
	</ul>
</div>
```

``` javascript
<script>
	var aLi = document.querySelectorAll('li');

	aLi.forEach(function(oLi, index) {
		oLi.style.backgroundImage = `img/img${(index%9)+1}.jpg)`;

	})
</script>
```

#### 点赞

``` css
<style>
	#box {
		width: 20px;
		height: 20px;
		font-size: 20px;
		line-height: 20px;
		margin: 200px auto;
		position: relative;
		cursor: pointer;
		color: grey;
	}
	#box.active {
		color: red;
	}
	#box.active:after {
		content: "❤";
		width: 30px;
		height: 30px;
		font-size: 30px;
		line-height: 30px;
		position: absolute;
		left: -5px;
		top: -20px;
		color: red;
		animation: ani 2s forwards;
	}
	@keyframes ani {
		to {
			top: -100px;
			opacity: 0;
		}
	}
</style>
```

``` html
<div id="box">❤</div>
```

``` javascript
<script>
	var oBox = document.querySelector('div');

	oBox.onclick = function() {
		oBox.classList.toggle('active');
	}
</script>
```

高能版动画
``` css
<style>
	@keyframes ani {
		25% {
			transform: translate(0, -25px) rotate(20deg) scale(1.125);
			opacity: 0.75;
		}
		50% {
			transform: translate(0, -50px) rotate(-15deg) scale(1.25);
			opacity: 0.5;
		}
		75% {
			transform: translate(0, -75px) rotate(25deg) scale(1.375);
			opacity: 0.25;
		}
		100% {
			transform: translate(0, -100px) rotate(-10deg) scale(1.5);
			opacity: 0;
		}
	}
</style>
```

#### 动态时钟
``` css
<style>
	.container{
		width: 300px;
		height: 300px;
		border:  2px solid black;
		border-radius: 50%;
		margin: 20px auto;
		position: relative;
	}

	.hour{
		width: 10px;
		height: 50px;
		background-color: green;
		position: absolute;
		left: 145px;
		top: 100px;
		transform-origin: center bottom;
	}

	.minute{
		width: 8px;
		height: 80px;
		background-color: pink;
		position: absolute;
		left: 146px;
		top: 70px;
		transform-origin: center bottom;
	}

	.second{
		width: 4px;
		height: 100px;
		background-color: red;
		position: absolute;
		left: 148px;
		top: 50px;
		transform-origin: center bottom;
	}

	.cap{
		width: 20px;
		height: 20px;
		background: radial-gradient(white,silver);
		left: 140px;
		top: 140px;
		position: absolute;
		border-radius: 50%;
	}

	.mark{
		width: 4px;
		height: 10px;
		background-color: black;
		position: absolute;
		top: 0;
		left: 148px;
		transform-origin: 2px 150px;
	}

	.inner-block{
		width: 20px;
		height: 20px;
		text-align: center;
		position: absolute;
		left: -8px;
		top: 12px;
		line-height: 20px;
	}
</style>
```

``` html
<div class="container">
	<div class="hour"></div>
	<div class="minute"></div>
	<div class="second"></div>
	<div class="cap"></div>
</div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');
	var oHour = document.querySelector('.hour');
	var oMinute = document.querySelector('.minute');
	var oSecond = document.querySelector('.second');

	var count = 12;

	for (var i = 0; i < count; i++) {
		var oDiv = document.createElement('div');
		oDiv.classList.add('mark');
		oDiv.style.transform = `rotate(${i*360/count}deg)`

		var innerBlock = document.createElement('div');
		innerBlock.classList.add('inner-block');

		innerBlock.innerHTML = i;

		innerBlock.style.transform = `rotate(${-i*360/count}deg)`

		if (i == 0) {
			innerBlock.innerHTML = 12;
		}

		oDiv.appendChild(innerBlock);
		oContainer.appendChild(oDiv);
	}

	setInterval(function() {
		var oDate = new Date();

		var hour = oDate.getHours();
		var minute = oDate.getMinutes();
		var second = oDate.getSeconds();
		var millisecond = oDate.getMilliseconds();

		oHour.style.transform = `rotate(${
			(hour+minute/60)*360/12
		}deg)`

		oMinute.style.transform = `rotate(${
			(minute+second/60)/60*360
		}deg)`

		oSecond.style.transform = `rotate(${
			(second+millisecond/1000)/60*360
		}deg)`
	}, 1000)
</script>
```


#### 修改之前的分块运动

##### 之前的分块运动

1. 自定义行数R、列数C
2. 创建span
  计算oSpan的width、height、left、top、background-position

注意：先appendChild才能获取oSpan的offsetWidth和offsetHeight

``` javascript
<script>
	for(var r = 0; r < R; r++) {
		for(var c = 0; c < C; c++) {
			var oSpan = document.createElement('span');
			oSpan.style.width = oBox.offsetWidth / C + 'px';
			oSpan.style.height = oBox.offsetHeight / R + 'px';
			oBox.appendChild(oSpan);
			oSpan.style.left = oSpan.offsetWidth * c + 'px';
			oSpan.style.top = oSpan.offsetHeight * r + 'px';
			oSpan.style.backgroundPosition = - oSpan.offsetWidth * c + 'px ' + (-oSpan.offsetHeight * r) + 'px';
			oSpan.r = r;
			oSpan.c = c;
		}
	}
</script>
```

3. 分布运动，依次显示span

##### 修改后的分块运动

backface-visibility

[使用CSS3 BACKFACE-VISIBILITY属性制作翻转动画效果](http://www.html5cn.org/article-7978-1.html)

**假设分块运动的图片资源为3张，分别为0.jpg，1.jpg，2.jpg*

``` css
<style>
	.container{
		width: 700px;
		height: 400px;
		margin: 40px auto;
		perspective: 800px;
		transform-style: preserve-3d;
	}

	.wrapper{
		width: 100px;
		height: 100px;
		float: left;
		position: relative;
		transform-style: preserve-3d;
	}

	.front,.back{
		width: 100px;
		height: 100px;
		position: absolute;
		left: 0;
		top: 0;
	}

	.front{
		z-index: 999;
		backface-visibility: hidden;  /* 3d空间内生效 */
	}

	.back{
		z-index: 9;
		transform: scale(-1,1);  /* 水平翻转 */
	}
</style>
```

``` html
	<div class="container"></div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');

	var rows = 4;  // 自定义分块行数
	var cols = 7;  // 自定义分块列数

	var currentIndex = 0;	// 当前图片序号

	// 行列循环 -> 分块放置前后图片
	for (var row = 0; row < rows; row++) {
		for (var col = 0; col < cols; col++) {
			var oDiv = document.createElement('div');
			oDiv.classList.add('wrapper');

			// 前置图片
			var oFront = document.createElement('div');
			oFront.classList.add('front');

			oFront.style.backgroundImage = `url(img/${currentIndex}.jpg)`;

			// 按行列数移动背景图片摆放位置

			oFront.style.backgroundPosition = `${-col*100}px ${-row*100}px`

			// 后置图片
			var oBack = document.createElement('div');
			oBack.classList.add('back');

			oBack.style.backgroundImage = `url(img/${currentIndex+1}.jpg)`;

			oBack.style.backgroundPosition = `${-col*100}px ${-row*100}px`

			oDiv.dataset.col = col;
			oDiv.dataset.row = row;

			oDiv.appendChild(oFront);
			oDiv.appendChild(oBack);

			oContainer.appendChild(oDiv);
		}
	}

	var aWrapper = document.querySelectorAll('.wrapper');

	// 监听最后一个分块是否运动完毕
	// 运动完毕则将原后置图更至前置，后置图序列加1
	aWrapper[aWrapper.length - 1].addEventListener('transitionend', function() {

		currentIndex++;

		aWrapper.forEach(function(oWrapper) {

			// 防止后置更至前置时有动画
			oWrapper.style.transition = '0s';
			oWrapper.style.transform = '';

			// 原后置图更至前置
			oWrapper.children[0].style.backgroundImage = `url(img/${currentIndex%3}.jpg)`
			// 现后置图更换
			oWrapper.children[1].style.backgroundImage = `url(img/${(currentIndex+1)%3}.jpg)`
		})
	}, false)

	window.onclick = function() {
		aWrapper.forEach(function(oWrapper) {
			var row = oWrapper.dataset.row;
			var col = oWrapper.dataset.col;

			// dataset为字符串，先解析为Number数据类型再进行运算
			oWrapper.style.transition = `1s ${0.3*(Number(row)+Number(col))}s`;  // 控制各分块旋转延迟时间
			oWrapper.style.transform = `rotateY(180deg)`;
		})
	}
</script>
```

#### 爆炸轮播

**假设爆炸运动的图片资源为3张，分别为0.jpg，1.jpg，2.jpg*

``` css
<style>
	.container{
		width: 700px;
		height: 400px;
		margin: 40px auto;
		perspective: 800px;
		transform-style: preserve-3d;
	}

	.wrapper{
		width: 100px;
		height: 100px;
		/* background: green; */
		float: left;
	}
</style>
```

``` html
	<div class="container"></div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');

	var rows = 4; // 自定义分块行数
	var cols = 7; // 自定义分块列数

	var currentIndex = 0; // 当前图片序号

	var bReady = true; // 是否运动完成

	// 爆炸时显示的背景图
	oContainer.style.backgroundImage = `url(img/${currenIndex+1}.jpg)`;

	// 爆炸分块图
	for (var row = 0; row < rows; row++) {
		for (var col = 0; col < cols; col++) {
			var oDiv = document.createElement('div');
			oDiv.classList.add('wrapper');

			oDiv.style.backgroundImage = `url(img/${currenIndex}.jpg)`;
			oDiv.style.backgroundPosition = `${-col*100}px ${-100*row}px`

			oContainer.appendChild(oDiv);
		}
	}

	var aWrapper = document.querySelectorAll('.wrapper');

	window.onclick = function() {
		if (!bReady) return;

		bReady = false;

		aWrapper.forEach(function(oWrapper) {
			oWrapper.style.transition = `.6s ${rnd(0,300)}ms`;  // 运动时间600ms, 爆炸随机延迟0~300ms
			oWrapper.style.transform = `translateZ(600px) rotateX(${rnd(100,300)}deg) rotateY(${rnd(100,300)}deg)`;  // 爆炸效果
			oWrapper.style.opacity = '0';
		})

		// 900ms后运动完成，将原背景图更至爆炸图，背景图更换
		setTimeout(function() {
			currenIndex++;

			aWrapper.forEach(function(oWrapper) {
				oWrapper.style.transition = '0s';
				oWrapper.style.transform = '';
				oWrapper.style.opacity = '1';
				oWrapper.style.backgroundImage = `url(img/${currenIndex%3}.jpg)`;
			})

			oContainer.style.backgroundImage = `url(img/${(currenIndex+1)%3}.jpg)`;

			bReady = true;	// 更换完成
		}, 900)
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}
</script>
```

#### 立方体
``` css
<style>
	body{
		perspective: 800px;
		transform-style: preserve-3d;
		user-select: none;  /* 文本不能被选择 */
	}

	.container{
		width: 200px;
		height: 200px;
		margin: 200px auto;
		position: relative;
		/*transition: 2s;*/
		transform-style: preserve-3d;
	}

	.container > div{
		width: 200px;
		height: 200px;
		text-align: center;
		line-height: 200px;
		font-size: 40px;
		color: white;
		font-weight: bolder;
		position: absolute;
	}

	.container > div:nth-child(1){
		transform: translateZ(100px);  /* 距中心点往前伸一半的宽度 */
	}

	.container > div:nth-child(2){
		transform: rotateY(180deg) translateZ(100px);
	}

	.container > div:nth-child(3){
		transform: rotateY(90deg) translateZ(100px);
	}

	.container > div:nth-child(4){
		transform: rotateY(-90deg) translateZ(100px);
	}

	.container > div:nth-child(5){
		transform: rotateX(90deg) translateZ(100px);
	}

	.container > div:nth-child(6){
		transform: rotateX(-90deg) translateZ(100px);
	}

	.container:active{
		transform: rotateY(180deg) rotateX(180deg);
	}
</style>
```

``` html
	<div class="container">
		<div>1</div>
		<div>2</div>
		<div>3</div>
		<div>4</div>
		<div>5</div>
		<div>6</div>
	</div>
```

``` javascript
<script>
	var aDiv = document.querySelectorAll('.container > div');
	var oContainer = document.querySelector('.container');

	var transformX = 0;
	var transformY = 0;

	aDiv.forEach(function(oDiv) {
		oDiv.style.background = `rgba(${rnd(0,255)},${rnd(0,255)},${rnd(0,255)},0.3)`
	})

	document.onmousedown = function({
		clientX,
		clientY
	}) {
		var disX = clientX - transformX;
		var disY = clientY - transformY;

		document.onmousemove = function({
			clientX,
			clientY
		}) {
			var deltaX = clientX - disX;
			var deltaY = clientY - disY;

			transformX = deltaX;
			transformY = deltaY;

			oContainer.style.transform = `rotateY(${transformX}deg) rotateX(${-transformY}deg)`;	// 旋转
		}

		document.onmouseup = function() {
			document.onmousemove = null;
			document.onmouseup = null;
		}
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}
</script>
```

#### 翻页效果

**假设分块运动的图片资源为3张，分别为0.jpg，1.jpg，2.jpg*

``` css
<style>
	.container{
		width: 700px;
		height: 400px;
		margin: 40px auto;
		position: relative;
		perspective: 800px;
		transform-style: preserve-3d;
	}

	.left,.right{
		width: 350px;
		height: 400px;
		position: absolute;
		top: 0;
	}

	.left{
		left: 0;
		z-index: 99;
	}

	.right{
		right: 0;
		z-index: 99;
	}

	.card{
		width: 350px;
		height: 400px;
		position: absolute;
		right: 0;
		top: 0;
		z-index: 999;
		transform-origin: left center;  /* 旋转中心 */
		transform-style: preserve-3d;
	}

	.front,.back{
		width: 100%;
		height: 100%;
		position: absolute;
		top: 0;
		left: 0;
	}

	.front{
		z-index: 999;
		backface-visibility: hidden;
	}

	.back{
		z-index: 9;
		transform: scale(-1,1);
	}
</style>
```

``` html
	<div class="container">
		<!-- 前置左边 -->
		<div class="left"></div>
		<!-- 翻页卡 -->
		<div class="card">
			<!-- 前置右边 -->
			<div class="front"></div>
			<!-- 后置左边 -->
			<div class="back"></div>
		</div>
		<!-- 后置右边 -->
		<div class="right"></div>
	</div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');
	var oCard = document.querySelector('.card');
	var oFront = document.querySelector('.front');
	var oBack = document.querySelector('.back');
	var oRight = document.querySelector('.right');
	var oLeft = document.querySelector('.left');

	var currentIndex = 0;

	// 前置左边
	oLeft.style.backgroundImage = `url(img/${currentIndex}.jpg)`;

	// 后置右边
	oRight.style.backgroundImage = `url(img/${currentIndex+1}.jpg)`;
	oRight.style.backgroundPosition = `-350px 0px`;

	// 前置右边
	oFront.style.backgroundImage = `url(img/${currentIndex}.jpg)`;
	oFront.style.backgroundPosition = `-350px 0px`;

	// 后置左边
	oBack.style.backgroundImage = `url(img/${currentIndex+1}.jpg)`;

	// 翻页运动完毕则将原后置图更至前置，后置图序列加1
	oCard.addEventListener('transitionend', function() {

		currentIndex++;

		// 防止后置更至前置时有动画
		oCard.style.transition = "0s";
		oCard.style.transform = "";

		// 原后置图更至前置
		oLeft.style.backgroundImage = `url(img/${currentIndex%3}.jpg)`;

		// 现后置图更换
		oRight.style.backgroundImage = `url(img/${(currentIndex+1)%3}.jpg)`;

		// 原后置图更至前置
		oFront.style.backgroundImage = `url(img/${currentIndex%3}.jpg)`;

		// 现后置图更换
		oBack.style.backgroundImage = `url(img/${(currentIndex+1)%3}.jpg)`;


	}, false)

	window.onclick = function() {
		oCard.style.transition = `1s`;
		oCard.style.transform = `rotateY(-180deg)`;
	}
</script>
```

#### 3D图片环

**假设分块运动的图片资源为10张，分别为1.jpg，2.jpg，3.jpg，4.jpg，5.jpg，6.jpg，7.jpg，8.jpg，9.jpg，10.jpg*

``` css
<style>
	body{
		background-color: black;
		transform-style: preserve-3d;
		perspective: 2000px;
	}

	.container{
		width: 100px;
		height: 150px;
		margin: 200px auto;
		position: relative;
		transform-style: preserve-3d;
		transform: rotateX(-10deg);
	}

	.card{
		width: 100px;
		height: 150px;
		background-size: cover;
		position: absolute;
		left: 0;
		top: 0;
		border-radius: 10px;
		box-shadow: 0 0 10px grey;
		/*-webkit-box-reflect:below 20px linear-gradient(rgba(0,0,0,0),red);*/
	}

	.shadow{
		width: 100px;
		height: 150px;
		position: absolute;
		left: 0;
		bottom:-170px;
		border-radius: 10px;
		transform: scale(1,-1);
		-webkit-mask:linear-gradient(rgba(0,0,0,0) 60%,rgba(0,0,0,0.7));
	}
</style>
```

``` html
	<div class="container"></div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');

	var amount = 10;

	// 拖拽变化值
	var rotateXDegree = 0;
	var rotateYDegree = 10;

	// 实时计算速度值
	var speedX = 0;
	var speedY = 0;

	// 用于计算速度值的上次值
	var lastX = 0;
	var lastY = 0;

	var timer = null;

	// 设置图片环
	for (var i = 0; i < amount; i++) {
		var oDiv = document.createElement('div');
		oDiv.classList.add('card');
		oDiv.style.backgroundImage = `url(statics/img/${i+1}.jpg)`;
		oDiv.style.transition = `0.8s ${(amount-i)*0.3}s`;

		// 设置倒影
		var oShadow = document.createElement('div');
		oShadow.classList.add('shadow');
		oShadow.style.backgroundImage = `url(statics/img/${i+1}.jpg)`;

		(function(ele, index) {
			setTimeout(function() {
				ele.style.transform = `rotateY(${index*360/amount}deg) translateZ(300px)`

			})
		})(oDiv, i)

		oDiv.appendChild(oShadow);
		oContainer.appendChild(oDiv);
	}

	var aCard = document.querySelectorAll('.card');

	aCard.forEach(function(oCard) {
		oCard.onmousedown = function(ev) {
			ev.preventDefault();
		}
	})

	// 监听最后一个图片是否运动完毕
	aCard[0].addEventListener('transitionend', function() {

		aCard.forEach(function(oCard, index) {

			// 防止delay值影响
			oCard.style.transition = '0.7s';

			/*
			 * 1. 角度 - 180
			 * 2. 角度取绝对值
			 * 3. 角度/180 得出透明度
			 */
			oCard.style.opacity = Math.abs(index * 36 - 180) / 180 + 0.4;
		})
	}, false)

	document.onmousedown = function({
		clientX,
		clientY
	}) {

		// 防止拖拽时有阻滞感
		clearTransition()

		// 防止多个定时器改变位置
		clearInterval(timer);

		var disX = clientX - rotateXDegree * 4;
		var disY = clientY - rotateYDegree * 4;

		document.onmousemove = function({
			clientX,
			clientY
		}) {
			var deltaX = clientX - disX;
			var deltaY = clientY - disY;

			rotateXDegree = deltaX * 0.25;
			rotateYDegree = deltaY * 0.25;

			setPosition()

			// 计算速度
			speedX = rotateXDegree - lastX;
			speedY = rotateYDegree - lastY;

			lastX = rotateXDegree;
			lastY = rotateYDegree;
		}

		document.onmouseup = function() {
			document.onmousemove = null;
			document.onmouseup = null;

			timer = setInterval(function() {
				rotateXDegree += speedX;
				rotateYDegree += speedY;

				// 衰减
				speedX *= 0.95;
				speedY *= 0.95;

				setPosition();
			}, 16);
		}
	}

	function setPosition() {
		aCard.forEach(function(oCard, index) {
			oCard.style.transform = `rotateY(${index*360/amount + rotateXDegree }deg) translateZ(300px)`

			/*
			 * 1. 角度(大于360时模360,小于0时取绝对值) - 180
			 * 2. 角度取绝对值
			 * 3. 角度/180 得出透明度
			 */

			oCard.style.opacity = Math.abs(Math.abs((index * 36 + rotateXDegree)) % 360 - 180) / 180 + 0.4;
		})

		// Y轴旋转
		oContainer.style.transform = `rotateX(${-rotateYDegree}deg)`;
	}

	function clearTransition() {
		aCard.forEach(function(oCard) {
			oCard.style.transition = '0s';
		})
	}
</script>
```

## 1.16

### H5地理位置 geolocation

LBS -> Location Based Service 基于位置服务

#### 测试用例

``` javascript
<script>
	window.navigator.geolocation.getCurrentPosition(function(res) {
		console.log(res);
	}, function(err) {
		console.log(err);
	})
</script>
```

##### PositionError
错误码 错误信息

code: 1
message: "User denied Geolocation" -> 用户拒绝授权

code: 1
message: "Only secure origins are allowed (see: https://goo.gl/Y0ZkNV). -> 仅允许HTTPS访问

code:2
message:"Network location provider at 'https://www.googleapis.com/' : No response received." -> 没翻墙

#### 百度地图API
timestamp 时间戳

coords -> 地理坐标
	accuracy:26 -> 精确度
	altitude:null -> 海拔
	altitudeAccuracy:null -> 海拔高度精确度
	heading:null -> 方向
	latitude:31.167638 -> 纬度
	longitude:121.423593 -> 经度
	speed:null -> 速度

```
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
	<style type="text/css">
		body, html,#allmap {
			user-select: none;
			width: 100%;
			height: 100%;
			overflow: hidden;
			margin: 0;
			font-family: "微软雅黑";
		}
	</style>
	<script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=wmwHFMPxi66GlPBVUrdgEhDzbLUqlSrM"></script>
	<title>上海师范大学 - 百度地图</title>
</head>
<body>
	<div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
	var map = new BMap.Map("allmap");

	map.centerAndZoom(new BMap.Point(121.423593, 31.167638), 20); // 初始化地图,设置中心点坐标和地图级别

	map.addControl(new BMap.MapTypeControl()); //添加地图类型控件
	map.setCurrentCity("上海"); // 设置地图显示的城市 此项是必须设置的
	map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放

	navigator.geolocation.getCurrentPosition(function(res) {
		var {
			coords: {
				longitude,
				latitude
			}
		} = res;

		var point = new BMap.Point(longitude, latitude);

		var marker = new BMap.Marker(point);
		map.addOverlay(marker);

		marker.setAnimation(BMAP_ANIMATION_BOUNCE)

		map.panTo(point)
	}, function(err) {
		console.log(err);
	})
</script>
```

### H5 audio

音频格式：mp3 wma flat ape wav ogg
#### 属性
src -> 音频路径
controls -> 显示自带控制进度条
loop -> 音频循环
autoplay -> 自动播放 只有pc端可以实现
muted -> 静音

currentTime -> 当前播放时间
duration -> 音频总时间
volume -> 音量 [0,1]

ontimeupdate -> 进度更新

play -> 是否在播放 返回true/false
pause -> 是否暂停 返回true/false

#### 方法
play() -> 播放歌曲
pause() -> 暂停歌曲
load() -> 重新加载歌曲
onended() -> 音频播放完毕

常见结构
``` html
<html>
	<audio src="xxx.mp3" controls></audio>  <!-- 显示音频自带播放器样式 -->
	<hr>
	<!-- 自定义播放器 -->
	<audio src="xxx.mp3" id="a1"></audio>  <!-- 只显示下面的按钮 -->
	<!-- 进度条 -->
	<div class="progress">
		<div class="inner"></div>
	</div>
	<input type="range" min="0" max="100" value="100">音量
	<button onclick="aPlay()">播放/暂停</button>
	<button onclick="aMute()">静音</button>
</html>
```

``` javascript
<script>
	var a1 = document.getElementById('a1');
	var progress = document.querySelector('.progress');
	var oInner = document.querySelector('.inner');
	var oRange = document.querySelector('[type=range]');

	// 自定义进度条
	// setInterval(function() {
	// 	oInner.style.width = (a1.currentTime / a1.duration) * 100 + '%';
	// }, 16);

	a1.ontimeupdate = function(){
		oInner.style.width = (a1.currentTime / a1.duration) * 100 + '%';
	}

	progress.onclick = function({
		clientX
	}) {
		var leftDelta = clientX - this.offsetLeft;

		var percentage = leftDelta / this.offsetWidth;

		a1.currentTime = a1.duration * percentage;
	}

	oRange.oninput = function(){
		a1.volume = this.value/100;
	}

	function aPlay() {
		if (a1.paused) {
			a1.play();
		} else {
			a1.pause();
		}
	}

	function aMute() {
		a1.muted = !oA.muted;
	}

</script>
```

#### 应用：钢琴弹奏

**sound.js**

钢琴示例

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>钢琴示例</title>
	<style>
		body {
			user-select: none;
		}
		ul, li {
			list-style: none;
			margin: 0;
			padding: 0;
		}
		ul {
			width: 400px;
			margin: 40px auto;
		}
		li {
			width: 38px;
			border: 1px solid black;
			height: 198px;
			float: left;
			text-align: center;
			line-height: 350px;
			margin-left: 10px;
			transform-origin: top center;
		}
		li:active {
			transform: perspective(800px) rotateX(-10deg);
		}
		li.active {
			transform: perspective(800px) rotateX(-10deg);
		}
	</style>
</head>
<body>
	<ul>
		<li>1</li>
		<li>2</li>
		<li>3</li>
		<li>4</li>
		<li>5</li>
		<li>6</li>
		<li>7</li>
		<li>8</li>
	</ul>
	<script src="statics/sound.js"></script>
	<script>
		var aLi = document.querySelectorAll('li');

		aLi.forEach(function(oLi, index) {
			oLi.onmousedown = function() {
				playSound(index + 49);
			}
		})

		window.onkeydown = function({
			keyCode
		}) {
			playSound(keyCode);

			aLi[keyCode - 49].classList.add('active');
		}

		window.onkeyup = function({
			keyCode
		}) {
			if (keyCode >= 49 && keyCode <= 56) {
				aLi[keyCode - 49].classList.remove('active');
			}
		}

		function playSound(index) {
			new Audio(oggSound[`sound${index}`]).play();
		}
	</script>
</body>
</html>
```

#### 应用：音乐播放器

##### 歌词显示

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		#box {
			width: 200px;
			margin: 40px auto;
			text-align: center;
			padding: 10px;
			border: 2px solid black;
			-webkit-background-clip: text;
			background-image: linear-gradient(90deg, red 30%, blue 30%);
			color: transparent;
		}
	</style>
</head>
<body>
	<div id="box">
		西湖的水我的泪
	</div>
	<script>
		var progress = 0;
		var oBox = document.querySelector('div');

		setInterval(function() {
			oBox.style.backgroundImage = `linear-gradient(90deg,red ${progress}%,blue ${progress}%)`

			progress += 0.4;
		}, 16)
	</script>
</body>
</html>
```

### H5 video
不同浏览器支持的格式不同，可能需要转码，在source标签里引入多种格式

FF不支持mp4，支持ogg

视频格式：
#### 属性
src -> 视频路径
controls -> 显示自带控制进度条
loop -> 视频循环
autoplay -> 自动播放
muted -> 静音

currentTime -> 当前播放时间
duration -> 视频总时间
volume -> 音量 [0,1]

ontimeupdate -> 进度更新

play -> 是否在播放 返回true/false
pause -> 是否暂停 返回true/false

#### 方法
play() -> 播放视频
pause() -> 暂停视频
load() -> 重新加载视频
onended() -> 视频播放完毕

常见结构
``` html
<html>
	<video src="xxx.mp4" controls></video>
	<hr>
	<video  controls>
		<source src="xxx.mp4">
		<source src="xxx.ogg">
	</video>
	<hr>
	<video src="xxx.mp4" id="v1" width="400px" height="200px"></video>
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var v1 = document.getElementById('v1');
	function play() {
		if(v1.paused) {
			v1.play();
		} else {
			v1.pause();
		}
	}
</script>
```

## 1.17

### H5 FileReader

#### 文件拖拽
ondragover -> 只要悬浮，一直触发
ondragenter -> 进入时触发，有子节点时有问题
ondragleave -> 离开时触发，有子节点时有问题
ondrop -> 释放鼠标时触发，对应DOM节点的dragover事件必须取消默认事件

#### File接口
`var reader = new FileReader();`  新建文件读取对象

方法
.readAsText(file) -> 读取文本文件
.readAsDataURL(file) -> 读取多媒体

.onload -> 资源读取完毕  reader.result
.onprogress -> 读取进度更新时触发
`<progress max="100"></progress>`
```
<script>
	reader.onprogress = function(ev){
		oProgress.value = ev.loaded/ev.total*100;
	}
</script>
```

.onloadstart -> 加载开始时触发
.onloadend -> 加载结束时触发
.onerror -> 出现错误时触发
.onabort -> 加载过程中中止时触发

.abort -> 手动中止加载


**示例**

文本
``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		reader.readAsText(file);	// 读取文本文件

		reader.onload = function(ev) {
			console.log(reader.result);
		}

		ev.preventDefault();
	}
</script>
```

多媒体
``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		reader.readAsDataURL(file);		// 读取多媒体

		reader.onload = function(ev) {
			new Audio(reader.result).play();
		}

		ev.preventDefault();
	}
</script>
```

处理文本/多媒体
``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		if (/text/.test(file.type)) {  // 处理文本

			reader.readAsText(file);

			reader.onload = function() {
				document.write(reader.result);
			}

			console.log('text');

		} else {  // 处理多媒体
			reader.readAsDataURL(file);

			reader.onload = function() {
				if (/image/.test(file.type)) {
					console.log('image');

					var oImage = new Image();
					oImage.src = reader.result;

					document.body.appendChild(oImage)

				} else if (/video/.test(file.type)) {

					console.log('video');

					oVideo.src = reader.result;
					oVideo.play();

				} else {

					console.log('audio');
					new Audio(reader.result).play();

				}
			}
		}

		ev.preventDefault();
	}
</script>
```

#### H5 web工作线程webworker
进程
线程

`var worker = new Worker('js文件');`  新建worker

> 	1. 需在服务器环境下
	2. 不会改变数据类型
	3. 不会改变父线程数据
	4. DOM/BOM 不可使用(console.log可用)
    5. 只能有一层子线程，子线程不可再开子线程

方法
worker.postMessage('Data')  向worker内传递数据 (1)
worker.onmessage 监听事件 (4)
worker.terminate 停止worker

worker内部
监听事件：
this.onmessage -> ev -> ev.data //'Data' (2)
this.postMessage 向父线程传递数据  (3)

示例

主程序
``` javascript
<script>
	var worker = new Worker('./calc.js');

	worker.postMessage(2);
</script>
```

calc.js
``` javascript
<script>
	this.onmessage = function(ev) {
		console.log(ev.data)
	}

	function fibonacci(n){
		if( n == 1 || n == 2 ) return 1;

		return fibonacci(n-1) + fibonacci(n-2);
	}
</script>
```

## 1.18

### H5 webSocket 网络套接字

客户端
1.发消息 -> emit
2.接消息 -> on

服务端
1.接消息 -> on
2.发消息 -> emit

在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header。

WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。

> Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议

### 映像劫持

## 1.19

### 移动端

#### viewport设置
`<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">`

window.innerWidth(度量viewport)

document.body.clientWidth(布局viewport)

width 设置布局viewport的特定值
  > width=device-width  布局viewport=设备宽度

initial-scale 设置页面的初始缩放
  > window.innerWidth/document.body.clientWidth=initial-scale=1.0  度量viewport=布局viewport

maximum-scale 最大缩放
minimum-scale 最小缩放
user-scalable 用户能否缩放

#### 移动端布局

##### 1. 定宽布局

- 定宽水平居中

``` css
<style>
	.container{
		width: 600px;
		height: 4000px;
		background-color: green;
		margin: 0 auto;
	}
</style>
```

``` css
<style>
	.container {
		width: 600px;
		height: 4000px;
		background-color: green;
		position: absolute;
		left: 50%;
		top: 0;
		margin-left: -300px;
	}
</style>
```

``` css
<style>
	.container {
		width: 600px;
		height: 4000px;
		background-color: green;
		position: absolute;
		left: 50%;
		top: 0;
		transform: translateX(-50%);
	}
</style>
```



##### 2. 流体/浮动布局

- 一侧定宽，一侧自适应

**calc() -> 计算布局**

``` css
<style>
	#box1 {
		width: 200px;
		height: 200px;
		display: inline-block;
		background-color: green;
	}
	#box2 {
		width: calc(100% - 200px);
		display: inline-block;
		height: 200px;
		background-color: blue;
	}
</style>
```

``` css
<style>
	#box1 {
		width: 200px;
		height: 200px;
		display: inline-block;
		background-color: green;
		position: absolute;
		left: 0;
		top: 0;
	}
	#box2 {
		width: calc(100% - 200px);
		display: inline-block;
		height: 200px;
		background-color: blue;
		margin-left: 200px;
	}
</style>
```

- 自适应5列等宽导航栏

``` css
<style>
	li{
		width: calc(20% - 10px);
		float: left;
		background-color: green;
		text-align: center;
		border: 5px solid black;
	}
</style>
```

``` css
<style>
	li{
		width: 20%;
		float: left;
		background-color: green;
		text-align: center;
		border: 5px solid black;
		box-sizing: border-box;
	}
</style>
```

##### 3. 等比布局

[css中的px、em、rem 详解](http://www.mamicode.com/info-detail-655497.html)

- px 像素  虚拟长度单位  px=1/dpi (英寸)
- em 相对长度单位 相对父节点的font-size

> 默认  1em = 16px(浏览器默认字体高) 12px=0.75e，10px=0.625em

  **若body选择器中声明font-size=62.5%，em值变为 16px*62.5%=10px -> 12px=1.2em，10px=1em**

> 1. em的值并不是固定的；
  2. **em会继承父级元素的字体大小再计算。

- pt 磅  物理长度单位  pt=1/72 (英寸)
- rem 根em(root em) 相对html的font-size  **IE9+**  **推荐**

**重点：根据根字号和设计图设备尺寸写js**
document.documentElement.style.fontSize = (clientWidth/320(设备宽度))*10(根字号) + 'px';

1vh -> 视窗高度的1%
1vw -> 视窗宽度的1%
1vmax -> 视窗高度/视窗宽度 取大值的1%
1vmin -> 视窗高度/视窗宽度 取小值的1%


``` css
<style>
	html{
		font-size: 100px;
	}
</style>
```

**resize.js**

``` javascript
<script>
	// ;(function() {

	// 	var doc = document.documentElement;

	// 	function reset() {
	// 		var {clientWidth} = doc;  // var clientWidth = doc.clientWidth

	// 		doc.style.fontSize = (clientWidth / 320) * 100 + 'px';
	// 	}

	// 	window.onresize = reset;
	// 	reset();
	// })();

	;(function() {
		var doc = document.documentElement;

		function resize() {
			doc.style.fontSize = doc.clientWidth / 320 * 100 + 'px';
		}

		window.addEventListener('resize', resize, false);

		resize();
	})();
</script>
```

**考虑Retina**

```
<script>
	var dpr, rem, scale;
	var docEl = document.documentElement;
	var fontEl = document.createElement('style');
	var metaEl = document.querySelector('meta[name="viewport"]');

	scale = 1 / dpr;
	dpr = window.devicePixelRatio || 1;
	rem = docEl.clientWidth * dpr / 10;

	// 设置viewport，进行缩放，达到高清效果
	metaEl.setAttribute('content', 'width=' + dpr * docEl.clientWidth + ',
	                     initial-scale=' + scale + ',maximum-scale=' + scale + ',
	                     minimum-scale=' + scale + ',user-scalable=no');

	// 设置data-dpr属性，留作的css hack之用
	docEl.setAttribute('data-dpr', dpr);

	// 动态写入样式
	docEl.firstElementChild.appendChild(fontEl);
	fontEl.innerHTML = 'html{font-size:' + rem + 'px!important;}';

	// 给js调用的，某一dpr下rem和px之间的转换函数
	window.rem2px = function(v) {
		v = parseFloat(v);
		return v * rem;
	};
	window.px2rem: function(v) {
		v = parseFloat(v);
		return v / rem;
	};
	window.dpr = dpr;
	window.rem = rem;
</script>
```

##### 4. 弹性盒模型

[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)

display:flex

> 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。

**属性**
父级

- flex-direction flex方向

  row/row-reverse -> 行(水平方向)/转置

  column/column-reverse -> 列(竖直方向)/转置

- justify-content  对齐方式(水平方向)

	flex-start -> 开始端
	flex-end -> 结束端
	center -> 中间
	space-between -> 两端对齐 将两侧子元素顶到头，剩余空间均分
	space-around -> 空间均分给每个子元素,子元素均分给两侧

- align-items  对齐方式(垂直方向)
	flex-start -> 开始端
	flex-end -> 结束端
	center -> 中间
	stretch -> 拉伸以充满
	baseline -> 基线

- align-content

- flex-wrap 换行
	nowrap -> 超出不换行
	wrap -> 超出换行


子级

- flex: 1/2/3  均分剩余空间的多少份

-align-self
	flex-start -> 开始端
	flex-end -> 结束端
	center -> 中间
	stretch -> 拉伸以充满

**兼容：IE11+**
[ CSS之flex兼容](http://blog.csdn.net/u010130282/article/details/52627661)

``` css
<style>
	.box{
	    display: -webkit-flex;  /* 新版本语法: Chrome 21+ */
	    display: flex;          /* 新版本语法: Opera 12.1, Firefox 22+ */
	    display: -webkit-box;   /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */
	    display: -moz-box;      /* 老版本语法: Firefox (buggy) */
	    display: -ms-flexbox;   /* 混合版本语法: IE 10 */

	 }

	.flex1 {
	    -webkit-flex: 1;        /* Chrome */
	    -ms-flex: 1             /* IE 10 */
	    flex: 1;                /* NEW, Spec - Opera 12.1, Firefox 20+ */
	    -webkit-box-flex: 1;     /* OLD - iOS 6-, Safari 3.1-6 */
	    -moz-box-flex: 1;       /* OLD - Firefox 19- */
	}
</style>
```

**应用**

1. 一侧定宽，一侧自适应

``` css
<style>
	.container{
		display: flex;
	}

	.left{
		width: 200px;
		height: 200px;
		background-color: green;
	}

	.right{
		flex: 1;
		height: 200px;
		background-color: blue;
	}
</style>
```

2. 三列 中间定宽 两侧3:1

``` css
<style>
	.container{
		display: flex;
	}

	.center{
		width: 200px;
		height: 200px;
		background-color: green;
	}

	.right{
		flex: 1;
		height: 200px;
		background-color: blue;
	}

	.left{
		flex: 3;
		height: 200px;
		background-color: blue;
	}
</style>
```

3. 自适应5列等宽导航栏

``` css
<style>
	ul{
		width: 100%;
		display: flex;
	}

	ul > li{
		flex: 1;
		background-color: green;
		text-align: center;
		border: 5px solid black;
	}
</style>
```

#### 移动端事件
**在手机WEB端，click会有 200~300 ms，所以用tap代替click作为点击事件。**

- touchstart 当手指触摸到屏幕触发

- touchmove  当手指在屏幕上移动时触发

- touchend   当手指离开屏幕时触发

- touchcancel  系统取消touch事件时触发

每个触摸事件被触发后，会生成一个event对象，event对象里额外包括触摸列表

targetTouches 当前dom元素上手指的列表


触摸列表的属性

clientX/clientY  触摸点相对浏览器窗口的位置

pageX/pageY  触摸点相对于页面的位置

screenX/screenY  触摸点相对于屏幕的位置

identifier  touch对象的ID

target  当前的DOM元素


##### 应用：移动端拖拽
``` javascript
<script>
	var oBox = document.querySelector('#box');

	oBox.addEventListener('touchstart', function(ev) {
		var clientX = ev.targetTouches[0].clientX;
		var clientY = ev.targetTouches[0].clientY;

		var disX = clientX - oBox.offsetLeft;
		var disY = clientY - oBox.offsetTop;

		document.addEventListener('touchmove', fnMove, false)

		document.addEventListener('touchend', fnEnd, false)

		function fnMove(ev) {
			var deltaX = ev.targetTouches[0].clientX - disX;
			var deltaY = ev.targetTouches[0].clientY - disY;

			oBox.style.left = deltaX + 'px';
			oBox.style.top = deltaY + 'px';

			ev.preventDefault();
		}

		function fnEnd() {
			document.removeEventListener('touchmove', fnMove, false)
			document.removeEventListener('touchend', fnEnd, false)

		}
	}, false)
</script>
```

##### 应用：移动端双击
``` javascript
<script>
	var oBox = document.querySelector('#box');
	var firstClicked = false;

	oBox.addEventListener('touchstart', function() {
		if (!firstClicked) {
			firstClicked = true;

			setTimeout(function() {
				firstClicked = false;
			}, 300)

		} else {
			alert(1);
		}
	}, false)
</script>
```

##### 应用：旋转缩放
``` javascript
<script>
	var oBox = document.querySelector('#box');

	var boxOriginX = oBox.offsetLeft + oBox.offsetWidth / 2;
	var boxOriginY = oBox.offsetTop + oBox.offsetHeight / 2;

	var scale = 1;    // 初始缩放比例
	var rotate = 0;   // 初始旋转度数

	document.addEventListener('touchstart', function(ev) {

		var startDis = getDistance(ev);
		var startDegree = getDegree(ev) - rotate;

		var oldScale = scale;

		document.addEventListener('touchmove', fnMove, false)

		function fnMove(ev) {

			// 缩放
			var endDis = getDistance(ev);

			scale = endDis / startDis + oldScale - 1;

			// 旋转
			var endDegree = getDegree(ev);
			var deltaDegree = startDegree - endDegree;

			rotate = -deltaDegree;

			oBox.style.transform = `scale(${scale}) rotate(${rotate}deg)`;
		}
	}, false);


	function getDistance(ev) {

		var clientX = ev.targetTouches[0].clientX;
		var clientY = ev.targetTouches[0].clientY;

		var deltaX = clientX - boxOriginX;
		var deltaY = clientY - boxOriginY;

		return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	}

	function getDegree(ev) {
		var clientX = ev.targetTouches[0].clientX;
		var clientY = ev.targetTouches[0].clientY;

		var deltaY = clientY - boxOriginY;
		var deltaX = clientX - boxOriginX;

		return a2d(Math.atan2(deltaY, deltaX));
	}

	function a2d(a) {
		return a / Math.PI * 180;
	}
</script>
```

##### 应用：双指旋转
``` javascript
<script>
	var oBox = document.querySelector('#box');
	var rotate = 0;

	oBox.addEventListener('touchstart', function(ev) {
		if (ev.targetTouches.length == 2) {
			document.addEventListener('touchmove', fnMove, false);
			document.addEventListener('touchend', fnEnd, false);

			var oldDegree = rotate;

			var startDegree = getDegree(ev);

			function fnMove(ev) {
				var endDegree = getDegree(ev);
				var delta = startDegree - endDegree;

				oBox.style.transform = `rotate(${oldDegree+delta}deg)`;

				rotate = oldDegree + delta;
			}

			function fnEnd() {
				document.removeEventListener('touchmove', fnMove, false);
				document.removeEventListener('touchend', fnEnd, false);
			}

			ev.preventDefault();
		}
	}, false)

	function getDegree(ev) {
		var targetTouches = ev.targetTouches;
		var firstTouch = targetTouches[0];
		var secondTouch = targetTouches[1];

		var deltaX = firstTouch.clientX - secondTouch.clientX;

		var deltaY = firstTouch.clientY - secondTouch.clientY;

		return a2d(Math.atan2(deltaX, deltaY));
	}

	function a2d(a) {
		return a / Math.PI * 180;
	}
</script>
```

##### 应用：双指缩放
``` javascript
<script>
	var oBox = document.querySelector('#box');
	var scale = 1;

	oBox.addEventListener('touchstart', function(ev) {
		if (ev.targetTouches.length == 2) {
			document.addEventListener('touchmove', fnMove, false);
			document.addEventListener('touchend', fnEnd, false);

			var oldScale = scale;

			var startDis = getDistance(ev);

			function fnMove(ev) {
				var endDis = getDistance(ev);
				scale = endDis / startDis + oldScale - 1;

				oBox.style.transform = `scale(${scale})`;
			}

			function fnEnd() {
				document.removeEventListener('touchmove', fnMove, false);
				document.removeEventListener('touchend', fnEnd, false);
			}

			ev.preventDefault();
		}
	}, false)

	function getDistance(ev) {
		var targetTouches = ev.targetTouches;

		var firstTouch = targetTouches[0];
		var secondTouch = targetTouches[1];

		var deltaX = secondTouch.clientX - firstTouch.clientX;

		var deltaY = secondTouch.clientY - firstTouch.clientY;

		return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	}

	function a2d(a) {
		return a / Math.PI * 180;
	}
</script>
```

##### 应用：双指一起拖拽
``` javascript
<script>
	var oBox = document.querySelector('#box');

	oBox.addEventListener('touchstart', function(ev) {

		if (ev.targetTouches.length == 2) {
			document.addEventListener('touchmove', fnMove, false);
			document.addEventListener('touchend', fnEnd, false);
		}

		var disX = ev.targetTouches[0].clientX - (oBox.dataset.left || 0);
		var disY = ev.targetTouches[0].clientY - (oBox.dataset.top || 0);

		function fnMove(ev) {
			var deltaX = ev.targetTouches[0].clientX - disX;
			var deltaY = ev.targetTouches[0].clientY - disY;

			oBox.dataset.left = deltaX;
			oBox.dataset.top = deltaY;

			oBox.style.transform = `translate(${deltaX}px,${deltaY}px)`
		}

		ev.preventDefault();

		function fnEnd() {
			document.removeEventListener('touchmove', fnMove, false);
			document.removeEventListener('touchend', fnEnd, false);

		}
	}, false)
</script>
```

##### 应用：双指分开拖拽
``` javascript
<script>
	var oLeft = document.querySelector('.left');
	var oRight = document.querySelector('.right');

	function setDrag(obj) {
		obj.addEventListener('touchstart', function(ev) {
			var disX = ev.targetTouches[0].clientX - obj.offsetLeft;
			var disY = ev.targetTouches[0].clientY - obj.offsetTop;

			var myId = ev.targetTouches[0].identifier;

			document.addEventListener('touchmove', fnMove, false);
			document.addEventListener('touchend', fnEnd, false);

			function fnMove(ev) {
				if (ev.targetTouches[0].identifier == myId) {

					var deltaX = ev.targetTouches[0].clientX - disX;
					var deltaY = ev.targetTouches[0].clientY - disY;

					obj.style.left = deltaX + 'px';
					obj.style.top = deltaY + 'px';
				}
			}

			function fnEnd() {
				document.removeEventListener('touchmove', fnMove, false);
				document.removeEventListener('touchend', fnEnd, false);
			}

			ev.preventDefault();
		}, false)
	}

	setDrag(oLeft);
	setDrag(oRight);
</script>
```

##### 应用：移动端轮播图

``` css
<style>
	html {
		font-size: 100px;
	}
	body {
		font-size: 0.16rem;
		margin: 0;
	}
	.container {
		width: 3.2rem;
		overflow: hidden;
	}
	ul, li {
		list-style: none;
		margin: 0;
		padding: 0;
	}
	ul {
		width: 22.4rem;
		display: flex;
		transform: translateX(-3.2rem);
	}
	ul > li {
		width: 3.2rem;
		height: 2rem;
		background-color: green;
		font-size: 0.3rem;
		text-align: center;
		line-height: 2rem;
		font-weight: bold;
		color: white;
	}
</style>
```

``` html
	<div class="container">
		<ul>
			<li>5</li>
			<li>1</li>
			<li>2</li>
			<li>3</li>
			<li>4</li>
			<li>5</li>
			<li>1</li>
			<!-- <li>
				<img src="img/slide_4.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_1.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_2.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_3.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_4.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_1.jpg" alt="">
			</li> -->
		</ul>
	</div>
```


``` javascript
<script>
	var aLi = document.querySelectorAll('li');
	var oUl = document.querySelector('ul');
	var vw = aLi[0].offsetWidth;

	var currentIndex = 0;
	var bReady = true;

	oUl.addEventListener('touchstart', function(ev) {

		// 控制频率
		if (!bReady) return;
		bReady = false;

		oUl.style.transition = '0s';

		var startX = ev.targetTouches[0].clientX;
		var disX = startX - (oUl.dataset.left || -vw);

		oUl.addEventListener('touchmove', fnMove, false);
		oUl.addEventListener('touchend', fnEnd, false);

		function fnMove(ev) {
			var deltaX = ev.targetTouches[0].clientX - disX;

			oUl.dataset.left = deltaX;

			oUl.style.transform = `translateX(${deltaX}px)`;

			ev.preventDefault();
		}

		function fnEnd(ev) {
			var endX = ev.changedTouches[0].clientX;
			var deltaX = endX - startX;

			// 拖拽距离是否可以切换
			if (Math.abs(deltaX) > vw / 4) {

				oUl.style.transition = '0.3s';

				//判断正负确定切换方向
				if (deltaX > 0) {
					currentIndex--

					if (currentIndex < 0) {
						currentIndex = 0;
					}
				} else {
					currentIndex++

					if (currentIndex > aLi.length - 1) {
						currentIndex = aLi.length - 1;
					}
				}

				setPosition();
			} else {

				// 不切换
				oUl.style.transition = '0.3s';
				setPosition();
			}

			oUl.removeEventListener('touchmove', fnMove, false);
			oUl.removeEventListener('touchend', fnEnd, false);
		}
	}, false)

	// 播放完毕之后判断currentIndex，是否拉回
	oUl.addEventListener('transitionend', function() {
		if (currentIndex == 0) {
			currentIndex = aLi.length - 2
		} else if (currentIndex == aLi.length - 1) {
			currentIndex = 1
		}

		oUl.style.transition = '0s';
		setPosition();

		bReady = true;
	}, false)

	aLi.forEach(function(oLi) {
		oLi.style.backgroundColor = `rgb(${
			rnd(0,255)
		},${
			rnd(0,255)
		},${
			rnd(0,255)
		})`
	})

	function setPosition() {
		var translate = -currentIndex * vw;
		oUl.style.transform = `translateX(${translate}px)`
		oUl.dataset.left = translate;
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}
</script>
```

## 2.6

### css3媒体查询 media
#### 媒体类型
- `all` 用于所有设备
- `screen` 用于电脑屏幕，平板电脑，智能手机等
- `print` 用于打印机和打印预览

#### 媒体功能
- `width` 定义输出设备中的页面可见区域宽度
- `heigth` 定义输出设备中的页面可见区域高度
- `min-width` 定义输出设备中的页面最小可见区域宽度
- `max-width` 定义输出设备中的页面最大可见区域宽度
- `min-height` 定义输出设备中的页面最小可见区域高度
- `max-height` 定义输出设备中的页面最大可见区域高度
- `device-width` 定义输出设备的屏幕可见宽度
- `device-height` 定义输出设备的屏幕可见高度
- `orientation` 定义输出设备中的页面可见区域高度是否大于或等于宽度
  - `portrait` 竖屏 页面可见区域高度大于或等于宽度
  - `landscape` 横屏 页面可见区域高度小于宽度

#### media大全
``` css
<style>
	/* iphone3 */
	@media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:1) {
	}
	@media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:1) and (orientation:portrait) {
	}
	@media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:1) and (orientation:landscape) {
	}

	/*iphone  4 (retina)*/
	@media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) {
	}
	@media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) and (orientation:portrait) {
	}
	@media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) and (orientation:landscape) {
	}

	/*iphone 5*/
	@media only screen and (min-device-width:320px) and (max-device-width:568px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) {
	}
	@media only screen and (min-device-width:320px) and (max-device-width:568px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) and (orientation:portrait) {
	}
	@media only screen and (min-device-width:320px) and (max-device-width:568px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) and (orientation:landscape) {
	}

	/*ipads (all) */
	@media only screen and (min-device-width:768px) and (max-device-width:1024px) {
	}
	@media only screen and (min-device-width:768px) and (max-device-width:1024px) and (orientation:portrait) {
	}
	@media only screen and (min-device-width:768px) and (max-device-width:1024px) and (orientation:landscape) {
	}

	/* ipad-retina */
	@media screen and (min-device-width:768px) and (max-device-width:1024px)  and (-webkit-device-pixel-ratio:2) {
	}
	@media screen and (min-device-width:768px) and (max-device-width:1024px)  and (-webkit-device-pixel-ratio:2) and (orientation:portrait) {
	}
	@media screen and (min-device-width:768px) and (max-device-width:1024px)  and (-webkit-device-pixel-ratio:2) and (orientation:landscape) {
	}

	/* iPhone 6 */
	/* Landscape */
	@media only screen 
	and (min-device-width:375px) /* or 213.4375em or 3in or 9cm */
	and (max-device-width:667px) /* or 41.6875em */
	and (width:667px)  /* or 41.6875em */
	and (height:375px)  /* or 23.4375em */
	and (orientation:landscape) 
	and (color:8)
	and (device-aspect-ratio:375/667)
	and (aspect-ratio:667/375)
	and (device-pixel-ratio:2)
	and (-webkit-min-device-pixel-ratio:2) {
	}

	/* Portrait */
	@media only screen 
	and (min-device-width:375px)  /* or 213.4375em */
	and (max-device-width:667px)  /* or 41.6875em */
	and (width:375px)  /* or 23.4375em */
	and (height:559px)  /* or 34.9375em */
	and (orientation:portrait) 
	and (color:8)
	and (device-aspect-ratio:375/667)
	and (aspect-ratio:375/559)
	and (device-pixel-ratio:2)
	and (-webkit-min-device-pixel-ratio:2) {
	}

	/* ----------- iPhone 6+ ----------- */

	/* Portrait and Landscape */
	@media only screen 
	  and (min-device-width: 414px) 
	  and (max-device-width: 736px) 
	  and (-webkit-min-device-pixel-ratio: 3) { 

	}

	/* Portrait */
	@media only screen 
	  and (min-device-width: 414px) 
	  and (max-device-width: 736px) 
	  and (-webkit-min-device-pixel-ratio: 3)
	  and (orientation: portrait) { 
	}

	/* Landscape */
	@media only screen 
	  and (min-device-width: 414px) 
	  and (max-device-width: 736px) 
	  and (-webkit-min-device-pixel-ratio: 3)
	  and (orientation: landscape) { 

	}

</style>
```

[常见移动设备的 CSS3 Media Query 整理（iPhone/iPad/Galaxy/HTC One etc.）](https://segmentfault.com/a/1190000002711737)
[Media Queries for Standard Devices](https://css-tricks.com/snippets/css/media-queries-for-standard-devices/)

### 解决移动端click事件延迟 fastclick.js
示例
``` javascript
	<script src="libs/zepto/zepto.js"></script>
	<script src="libs/zepto/touch.js"></script>
	<script src="libs/fastclick.js"></script>
	<script>
		FastClick.attach(document.body);

		$('.block').click(function(){
			console.timeEnd();
		})

		$('.block').on('touchstart',function(){
			console.time()
		})
	</script>
```

### 移动端多点触控 hammer.js
识别器
- tap 点
- doubletap 双点击
- press 按住
- pan 平移
- swipe 快速滑动
- pinch 多触点捏放
- rotate 多触点旋转

示例
``` javascript
<script src="libs/hammer.min.js"></script>
<script>
	var box = document.querySelector('#box')
	var hammertime = new Hammer(box);

	box.addEventListener('touchstart', function(ev) {
		ev.preventDefault()
	}, false)

	hammertime.get('pinch').set({
		enable: true
	});
	hammertime.get('rotate').set({
		enable: true
	});
	hammertime.get('pan').set({
		direction: Hammer.DIRECTION_ALL  // 所有方向都可平移
	});

	hammertime.get('swipe').set({
		direction: Hammer.DIRECTION_VERTICAL  // 仅垂直方向可滑动
	});

	hammertime.on('press', function(ev) {
		console.log(ev);
	});

</script>
```

### 移动端下拉刷新 iScroll.js
[iScroll下拉刷新演示](http://cubiq.org/dropbox/iscroll4/examples/pull-to-refresh/)

示例
``` javascript
<script src="libs/iscroll/iscroll.js"></script>
<script type="text/javascript">
	var myScroll = new IScroll('#wrapper', {
		mouseWheel: true,  // 鼠标滚轮支持
		scrollbars: true,  // 滚动条支持
		// disableTouch: false
	});
</script>
```

### jQueryMobile
结构demo

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="libs/jquery-mobile-demo/res/jquery.mobile-1.2.0.min.css" />
	<script src="libs/jquery-mobile-demo/res/jquery-1.8.2.min.js"></script>
	<script src="libs/jquery-mobile-demo/res/jquery.mobile-1.2.0.min.js"></script>
</head>
<body>
	<div data-role="page">
		<div data-role="header">  <!-- 顶部功能栏 -->
			<a href="#" data-icon="grid" onClick="location.reload()">刷新</a>
			<h1>首页</h1>
			<a href="#" data-icon="refresh" data-iconpos="right">菜单</a>
		</div>
		<div data-role="content">  <!-- 中间内容 -->
			<ul data-role="listview">
				<li><a href="#page2" data-transition="fade">新闻（fade）</a></li>
				<li><a href="#page2" data-transition="flip">新闻(flip)</a></li>
				<li><a href="#page2" data-transition="pop">新闻(pop)</a></li>
				<li><a href="#page2" data-transition="slide">新闻(slide)</a></li>
				<li><a href="#page2" data-transition="slidedown">新闻(slidedown)</a></li>
				<li><a href="#page2" data-transition="slideup">新闻(slideup)</a></li>
				<li><a href="#page2" data-transition="slidefade">新闻(slidefade)</a></li>
				<li><a href="#page2" data-transition="flow">新闻(flow)</a></li>
				<li><a href="#page2" data-transition="turn">新闻(turn)</a></li>
				<li class="ui-btn-active"><a href="#page2" data-transition="none">新闻(none)</a></li>
			</ul>
		</div>
		<div data-role="footer" data-position="fixed">  <!-- 底部导航栏 -->
			<div data-role="navbar">
				<ul>
					<li><a href="#formMsg" data-icon="info" data-transition="turn">表单信息</a></li>
					<li><a href="#btnGroup" data-icon="custom" data-transition="flow">按钮组</a></li>
					<li><a href="#d1" data-icon="star">dialog</a></li>
					<li><a href="#list" data-icon="forward" data-transition="slide">列表</a></li>
					<li><a href="#layout" data-icon="grid" data-transition="pop">列布局</a></li>
				</ul>
			</div>
		</div>
	</div>
	<!-- 新页面 -->
	<div data-role="page" id="page2">
		<div data-role="header">
			<a href="#" data-icon="back" data-rel="back">返回</a>
			<h1>新闻页面</h1>
		</div>
		<div data-role="content">
			<p style="text-align:center;">
				xxxx
			</p>
		</div>
		<div data-role="footer" data-position="fixed">
			<div data-role="navbar">
				<ul>
					<li><a href="#formMsg" data-icon="info" data-transition="turn">表单信息</a></li>
					<li><a href="#btnGroup" data-icon="custom" data-transition="flow">按钮组</a></li>
					<li><a href="#d1" data-icon="star">dialog</a></li>
					<li><a href="#list" data-icon="forward" data-transition="slide">列表</a></li>
					<li><a href="#layout" data-icon="grid" data-transition="pop">列布局</a></li>
				</ul>
			</div>
		</div>
	</div>
</body>
</html>
```

### 移动端触摸滑动 Swiper.js

示例
```
 <link rel="stylesheet" href="libs/swiper/css/swiper.min.css">
```

``` html
<div class="swiper-container">
	<div class="swiper-wrapper">
		<div class="swiper-slide">Slide 1</div>
		<div class="swiper-slide">Slide 2</div>
		<div class="swiper-slide">Slide 3</div>
	</div>
	<!--  -->
	<!-- 如果需要分页器 -->
	<div class="swiper-pagination"></div>
	<!--  -->
	<!-- 如果需要导航按钮 -->
	<div class="swiper-button-prev"></div>
	<div class="swiper-button-next"></div>
	<!--  -->
	<!-- 如果需要滚动条 -->
	<div class="swiper-scrollbar"></div>
</div>
```

``` javascript
<script src="libs/swiper/js/swiper.min.js"></script>
<!-- 或者 -->
<!-- <script src="libs/jquery.js"></script>
<script src="libs/swiper.jquery.min.js"></script> -->
<script>
	var swiper = new Swiper('.swiper-container', {
		// autoplay: 5000,  //可选选项，自动滑动
		// autoHeight: true, //高度随内容变化
		loop : true,  // 循环

		// 如果需要分页器
		pagination: '.swiper-pagination',

		// 如果需要前进后退按钮
		nextButton: '.swiper-button-next',
		prevButton: '.swiper-button-prev',

		// 如果需要滚动条
		scrollbar: '.swiper-scrollbar',

		effect: 'cube',  // 默认为"slide"（位移切换），可设置为"fade"（淡入）"cube"（方块）"coverflow"（3d流）"flip"（3d翻转）
		grabCursor: true,

		cube: {  // 可设置cube效果参数
			shadow: true,
			slideShadows: true,
			shadowOffset: 20,
			shadowScale: 0.94
		}
	});
</script>
```

### 轻量级移动端框架 zepto.js
zepto可选模块
- zepto	✔	核心模块；包含许多方法
- event	✔	通过on()& off()处理事件
- ajax	✔	XMLHttpRequest 和 JSONP 实用功能
- form	✔	序列化 & 提交web表单
- detect		提供 $.os和 $.browser消息
- fx		The animate()方法
- fx_methods		以动画形式的 show, hide, toggle, 和 fade*()方法.
- selector		实验性的支持 jQuery CSS 表达式 实用功能，比如 $('div:first')和 el.is(':visible')
- touch		在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的touch(iOS, Android)和pointer事件(Windows Phone)

[jQuery与Zepto的异同](http://www.cnblogs.com/colima/p/5289386.html)


## 2.7

### H5 canvas
基于 JavaScript 的绘图 API

`<canvas></canvas>`

获取绘图上下文
``` javascript
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');
</script>
```

ctx.
  - moveTo(x, y)  移动
  - lineTo(x, y)  划线
  - fillStyle = "color"  更改填充颜色
  - fill()  填充
  - strokeStyle = "color"  更改描边样式
  - stroke()  描边

矩形
ctx.
  - fillRect(x, y, w, h)  填充矩形(没有路径)
  - strokeRect(x, y, w, h)  描边矩形(没有路径)
  - rect(x, y, w, h)  举行路径
  - clearRect(x, y, w, h)  清空区域

弧
ctx.
  - arc(cx, cy, r, startDegree, endDegree, anticlockwise)  圆心x，圆心y，半径，起始角度(弧度制)，结束角度(弧度制)，是否逆时针
  - fill()  填充

文本
ctx.
  - font = "字号 字体"
  - textAlign = "left/center/right"  竖轴对齐方式
  - textBaseline ="top/middle/bottom" 横轴对齐方式
  - fillText('文字', x, y)  填充文字
  - strokeText('文字', x, y)  描边文字
  - measureText('文字')  返回文字长度(width)

ctx.
  - beginPath()  开始路径
  - closePath()  闭合路径

线条样式
ctx.
  - lineCap = "round/butt(默认)/square"  更改线帽
  - lineJoin = "round/miter(默认)/bevel(切角)"  更改连接点样式
  - lineWidth = 20  线宽

阴影
ctx.
  - shadowColor	设置或返回阴影颜色
  - shadowBlur	设置或返回阴影模糊级别
  - shadowOffsetX	设置或返回阴影距形状的水平距离
  - shadowOffsetY	设置或返回阴影距形状的垂直距离

渐变
ctx.
  - createLinearGradient(x0, y0, x1, y1)  创建线性渐变 起始位置 结束位置（用在画布内容上）
  - createPattern(img, "repeat|repeat-x|repeat-y|no-repeat")	在指定的方向上重复指定的元素
  - createRadialGradient(x0, y0, r0, x1, y1, r1)	创建径向渐变 起始位置 结束位置（用在画布内容上）
  - addColorStop(位置, 颜色)	规定渐变对象中的颜色和停止位置(0~1)

画图
ctx.
  - drawImage(img, x, y)  在画布上绘制图像、画布或视频
  - drawImage(img, x, y, width, height)
  - drawImage(img, sx, sy, swidth, sheight, x, y, width, height)  剪切图像，并在画布上定位被剪切的部分 s-裁剪

	```
	<script>
		var oC = document.querySelector('canvas');
		var ctx = oC.getContext('2d');

		var oImage = new Image();
		oImage.src = 'xxx.png';

		oImage.onload = function() {
			ctx.drawImage(oImage, 0, 0);
		}
	</script>
	```

像素操作
ctx.
  - getImageData(x, y, w, h)  画布指定矩形复制像素数据  **需服务器环境**
    imgData包括{data, width, height}  其中data是像素数组
    - red=imgData.data[0];
	- green=imgData.data[1];
	- blue=imgData.data[2];
	- alpha=imgData.data[3];
  - putImageData(imgData, x, y) 将图像数据放回画布

变换
ctx.
  - scale(sW, sH)	缩放当前绘图至更大或更小
  - rotate(角度*Math.PI/180)	旋转当前绘图
  - translate(x, y)	重新映射画布上的 (0,0) 位置
  > 注意translate和moveTo的区别

  - transform(a,b,c,d,e,f)	替换绘图的当前转换矩阵(相对变化)  水平缩放 水平倾斜 垂直倾斜 垂直缩放 水平移动 垂直移动
  - setTransform(a,b,c,d,e,f)	将当前转换重置为单位矩阵(不相对变化)  水平缩放 水平倾斜 垂直倾斜 垂直缩放 水平移动 垂直移动

ctx.
  - isPointInPath(x, y)  点是否在路径内

ctx.
  - save()	保存当前环境的状态
  - restore()	返回之前保存过的路径状态和属性

#### 应用 canvas笑脸
```
<canvas width="800" height="1200"></canvas>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');

	// face
	ctx.fillStyle = 'yellow';
	ctx.arc(400, 250, 180, 0, 2 * Math.PI, false);
	ctx.fill();
	ctx.stroke();

	// mouth
	ctx.beginPath();
	ctx.lineCap = 'round';

	ctx.lineWidth = 20;
	ctx.fillStyle = 'red';
	ctx.arc(400, 280, 80, 0, Math.PI, false);
	// ctx.fill();  // 红色实心半圆张嘴笑脸
	ctx.stroke();  // 黑色半圆弧微笑脸

	// eyes
	ctx.beginPath();
	ctx.fillStyle = 'black';
	ctx.moveTo(350, 200);
	ctx.arc(350, 200, 20, 0, 2 * Math.PI, false);

	ctx.moveTo(450, 200);
	ctx.arc(450, 200, 20, 0, 2 * Math.PI, false);

	ctx.closePath();

	ctx.fill();
</script>
```

#### 应用 canvas画图
```
<canvas width="800" height="600"></canvas>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');

	oC.onmousedown = function(ev) {

		var {
			clientX,
			clientY
		} = ev;

		ctx.moveTo(clientX, clientY)

		oC.onmousemove = function(ev) {

			ctx.clearRect(0, 0, oC.width, oC.height);

			var {
				clientX,
				clientY
			} = ev;

			ctx.lineWidth = 5;
			ctx.lineTo(clientX, clientY);
			ctx.stroke();
		}

		oC.onmouseup = function() {
			oC.onmousemove = null;
			oC.onmouseup = null;
		}
	}
</script>
```

#### 应用 canvas变换
```
<canvas width="800" height="600"></canvas>
	<script>
		var oC = document.querySelector('canvas');
		var ctx = oC.getContext('2d');

		var degree = 1;

		var x1 = 300;
		var y1 = 300;
		var w1 = 100;
		var h1 = 100;

		var x2 = 100;
		var y2 = 100;
		var w2 = 50;
		var h2 = 50;

		var rotate1 = 0;
		var rotate2 = 0;

		setInterval(function() {
			ctx.clearRect(-oC.width, -oC.height, oC.width * 2, 2 * oC.height);

			ctx.save();
			ctx.translate(x1, y1);
			ctx.rotate(rotate1);
			ctx.fillRect(-w1 / 2, -h1 / 2, w1, h1);
			ctx.restore();

			ctx.save();
			ctx.translate(x2, y2);
			ctx.rotate(rotate2);
			ctx.fillRect(-w2 / 2, -h2 / 2, w2, h2);
			ctx.restore()

			rotate1++;
			rotate2 += 0.2;
		}, 100)

		function d2a(deg) {
			return deg / 180 * Math.PI
		}
	</script>
```

#### 应用 canvas内长方形拖拽
```
<canvas width="800" height="600"></canvas>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');

	var rect = {
		x: 0,
		y: 0,
		w: 100,
		h: 100
	}

	ctx.fillRect(
		rect.x,
		rect.y,
		rect.w,
		rect.h
	);

	oC.onmousedown = function({
		clientX,
		clientY
	}) {
		var {
			x,
			y,
			w,
			h
		} = rect;

		var disX = clientX - x;
		var disY = clientY - y;

		if (
			clientX > x &&
			clientX < x + w &&
			clientY > y &&
			clientY < y + h
		) {
			oC.onmousemove = function({
				clientX,
				clientY
			}) {

				ctx.clearRect(0, 0, oC.width, oC.height)  // **先清空画布再画

				var deltaX = clientX - disX;
				var deltaY = clientY - disY;

				rect.x = deltaX;
				rect.y = deltaY;

				ctx.fillRect(
					rect.x,
					rect.y,
					rect.w,
					rect.h
				);
			}

			oC.onmouseup = function() {
				oC.onmousemove = null;
				oC.onmouseup = null;
			}
		}
	}
</script>
```

#### 应用 canvas内圆形拖拽
```
<canvas width="800" height="600"></canvas>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');

	var circle = {
		x: 50,
		y: 50,
		r: 50
	}

	ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI, false);

	ctx.fill();

	oC.onmousedown = function({
		clientX,
		clientY
	}) {
		var {
			x,
			y,
			r
		} = circle;

		var disX = clientX - x;
		var disY = clientY - y;

		if (
			ctx.isPointInPath(clientX, clientY)  // 利用isPointInPath函数
		) {
			oC.onmousemove = function({
				clientX,
				clientY
			}) {
				ctx.clearRect(0, 0, oC.width, oC.height);
				ctx.beginPath();

				var deltaX = clientX - disX;
				var deltaY = clientY - disY;

				circle.x = deltaX;
				circle.y = deltaY;

				ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI, false);
				ctx.fill();
			}

			oC.onmouseup = function() {
				oC.onmousemove = null;
				oC.onmouseup = null;
			}
		}
	}
</script>

```

#### 应用 下载canvas绘图
```
<canvas width="600" height="400"></canvas>
<br>
<button>Download</button>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');
	var oBtn = document.querySelector('button');

	var data = [
		rnd(100, 1000),
		rnd(100, 1000),
		rnd(100, 1000),
		rnd(100, 1000),
		rnd(100, 1000)
	]

	var start = 0;

	var sum = sumUp(data);

	data.forEach(function(number, index) {
		var color = `rgb(${rnd(0,255)},${rnd(0,255)},${rnd(0,255)})`;

		var delta = number / sum * 2 * Math.PI;

		ctx.fillStyle = color;

		ctx.beginPath();

		ctx.moveTo(300, 200)
		ctx.arc(300, 200, 100, start, start + delta, false);
		ctx.lineTo(300, 200)

		ctx.fill();

		start = start + delta;
	})

	function sumUp(array) {
		var sum = 0;

		array.forEach(function(n) {
			sum += n
		})

		return sum;
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}

	// **下载canvas图片
	oBtn.onclick = function() {
		var oA = document.createElement('a');
		oA.href = oC.toDataURL();
		oA.download = '默认命名';
		// oA.download = fileName.value ? fileName.value : '默认命名' + '.png';

		oA.click();
	}
</script>
```

### 应用 canvas运动回调
```
<script>
	function loadStatics(statics, callback) {
		var count = 0;

		statics.forEach(function(path, index) {
			var oImage = new Image();
			oImage.src = `img/${path}.png`

			resources[path] = oImage;

			oImage.onload = function() {

				count++

				if (count == statics.length) {
					callback && callback();
				}
			}
		})
	}

	function d2a(d) {
		return d / 180 * Math.PI
	}

	function a2d(a) {
		return a / Math.PI * 180
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n)
	}

	function rndSign() {
		return Math.random() < 0.5 ? -1 : 1
	}
</script>
```

### canvas框架 jCanvaScript.js
[jCanvaScript.js](http://jcscript.com/)

示例
```
<canvas id="c1" width="500" height="500"></canvas>
<script src="libs/jCanvaScript.1.5.18.min.js"></script>
<script>
    var idCanvas = "c1";
    onload_1();

    var interval_1 = 0;

    function startShow() {
        var r = Math.floor(Math.random() * (254)),
            g = Math.floor(Math.random() * (254)),
            b = Math.floor(Math.random() * (254)),
            x = Math.floor(Math.random() * (439)),
            y = Math.floor(Math.random() * (554)),
            color = "rgba(" + r + ", " + g + ", " + b + ", 0.5)",
            filled = true,
            radius = 1;
        jc.circle(x, y, radius, color, filled)
            .animate({
                radius: 100,
                opacity: 0
            }, 1500, function() {
                this.del();
            });
    }

    function onload_1() {
        jc.start(idCanvas, true);
        interval_1 = setInterval(startShow, 200);
    }

    function start_1(idCanvas) {
        if (interval_1) return;
        onload_1();
    }

    function stop_1(idCanvas) {
        clearInterval(interval_1);
        interval_1 = 0;
        jc.clear(idCanvas);
    }
</script>
```

## 2.13

### Hybrid App
- Native App
  优势：低效、维护成本高
  劣势：性能高、功能多
  - IOS(swift/objective-c)
  - Android(java)
- Web App(H5)
  优势：开发成本低、迭代迅速
  劣势：功能缺失
- Hybrid App
  优势：性能高、功能多、迭代迅速
  - 原生底层 + web页面

![Web App && Hybrid App && Native App](http://cc.cocimg.com/api/uploads/20141202/1417490115816004.png)

![一张图告诉你Native APP、WEB APP与Hybrid APP的区别](http://www.51mono.com/Uploads/Image/2013-07-24/49c3df2b-86ba-4a02-8950-b631975ce181.png)

![Web App、Hybrid App、Native App 技术特性](http://cc.cocimg.com/api/uploads/20141202/1417492897519728.jpg)

#### 关于移动端
Battery Status -> 电池状态
Camera -> 相机
Contacts -> 联系人
Device Info -> 设备信息
Device Motion (accelerometer) -> 设备运动
Device Orientation (compass) -> 电子罗盘
Dialogs (notification) -> 消息通知
File -> 文件
File Transfer -> 文件传输
Geolocation -> 地理信息
Globalization -> 全球化  i18n/internationalization
InAppBrowser -> 内置浏览器
Media -> 多媒体
Media Capture -> 多媒体录制
Network Information -> 网络信息
Splash Screen -> 闪屏/闪页
Status Bar -> 状态栏
Whitelist -> 白名单
Vibration -> 震动

### 移动应用程序开发

#### cordova
[Apache科尔多瓦 - getstarted](http://cordova.apache.org/#getstarted)

[cordova+famous实战篇（1）——创建第一个应用程序](http://www.ifcoder.us/1049)

#### React-Native

[React Native 中文网](http://reactnative.cn/)

#### 比较
- ionic ：html + angularjs + css

使用 html + angularjs 与网页开发类似，代码只需要写一次，就可以达到跨平台效果

- react-native ：js + css

普通UI全程js开发，部分情况下需要使用与native混合的方式，简单空间和逻辑层可共用，基本上iOS和android是两套代码，可用flexbox布局。

[Cordova VS React Native 谁是未来？](http://www.aichengxu.com/other/2486618.htm)

[ionic react-native和native开发移动app那个好](http://www.phonegap100.com/article-486-1.html)


### SVG
SVG(Scalable Vector Graphic 可伸缩矢量图形)
VML(The Vector Markup Language  矢量可标记语言)

SVG 使用 XML 格式定义图形

#### 位图 && 矢量图
- 位图 -> 由像素点构成的图形
  - 优点: 色彩信息相当复杂
  - 缺点: 失真、体积大

- 矢量图 -> 由数学语言描述出的图形
  - 优点: 体积小不失真
  - 缺点: 色彩信息单一，图形简单

#### SVG使用
1.
```
<img src="xxx.svg">
```
```
<?xml version="1.0" encoding="UTF-8"?>
<svg width="801px" height="792px" viewBox="0 0 801 792" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	...
</svg>
```

2.
```
<svg>
	<rect x="20" y="20" rx="20" ry="20" width="250" height="250" style="fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9"/>
</svg>
```

3.
```
<svg width="200" height="200"></svg>
<script>
	var oSvg = document.querySelector('svg');
	var oLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');

	oLine.setAttribute('x1', '10');
	oLine.setAttribute('y1', '10');
	oLine.setAttribute('x2', '100');
	oLine.setAttribute('y2', '100');
	oLine.setAttribute('stroke', 'green');

	oSvg.appendChild(oLine);
</script>
```


#### SVG梗概
- `<rect>`     矩形
  eg: `<rect x="20" y="20" rx="20" ry="20" width="250" height="250" style="fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9"/>`
  - x, y  位置
  - width, height  宽高
  - rx, ry  圆角矩形
  - style  css属性

- `<circle>`   圆形
  eg: `<circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red"/>`
  - cx, cy  圆心坐标 默认(0, 0)
  - r  半径

- `<ellipse>`  椭圆
  eg: `<ellipse cx="300" cy="150" rx="200" ry="80"style="fill:rgb(200,100,50);stroke:rgb(0,0,100);stroke-width:2"/>`
  - cx, cy  圆心坐标
  - rx, ry  水平/垂直半径

- `<line>`     线
  eg: `<line x1="0" y1="0" x2="300" y2="300"style="stroke:rgb(99,99,99);stroke-width:2"/>`
  - x1, y1  开始坐标
  - x2, y2  结束坐标

- `<polyline>` 折线
  eg: `<polyline points="0,0 0,20 20,20 20,40 40,40 40,60"style="fill:white;stroke:red;stroke-width:2"/>`
  - points 每个折点的x,y坐标

- `<polygon>`  多边形
  eg: `<polygon points="220,100 300,210 170,250"style="fill:#cccccc;stroke:#000000;stroke-width:1"/>`
  - points  每个角的x,y坐标(自动闭合)

- `<path>`     路径
  eg: `<path d="M250 150 L150 350 L350 350 Z" style="#ccc;"/>`  **大写表示绝对定位，小写表示相对定位。**
  - M  moveto
  - L  lineto
  - H  horizontal lineto
  - V  vertical lineto
  - C  curveto
  - S  smooth curveto
  - Q  quadratic Belzier curve
  - T  smooth quadratic Belzier curveto
  - A  elliptical Arc
  - Z  closepath


- `<filter>`    高斯滤镜  **<filter> 标签必须嵌套在 <defs> 标签内。**  definitions 定义
  eg: `<defs><filter id="Gaussian_Blur"><feGaussianBlur in="SourceGraphic" stdDeviation="3" /></filter></defs>`
  `<ellipse cx="200" cy="150" rx="70" ry="40" style="fill:#ff0000;stroke:#000000;stroke-width:2;filter:url(#Gaussian_Blur)"/>`
  - <filter>id  定义名称

  - filter:url(#xxx)  链接滤镜

- `<linearGradient>`  线性渐变  **<linearGradient> 标签必须嵌套在 <defs> 的内部。**
  eg: `<defs><linearGradient id="orange_red" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1"/><stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1"/></linearGradient></defs>`
  `<ellipse cx="200" cy="190" rx="85" ry="55" style="fill:url(#orange_red)"/>`
  - <linearGradient>id  定义名称
  - <linearGradient>x1,y1  渐变开始位置
  - <linearGradient>x2,y2  渐变结束位置
  - <stop>  渐变颜色

  - fill:url(#xxx)  链接渐变

- `<radialGradient>`  径向渐变  **<radialGradient> 标签必须嵌套在 <defs> 中。**
  eg: `<defs><radialGradient id="grey_blue" cx="50%" cy="50%" r="50%"fx="50%" fy="50%"><stop offset="0%" style="stop-color:rgb(200,200,200);stop-opacity:0"/><stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1"/></radialGradient></defs>`
  `<ellipse cx="230" cy="200" rx="110" ry="100" style="fill:url(#grey_blue)"/>`
  - <radialGradient>id  定义名称
  - <radialGradient>cx,cy,r  外圈
  - <radialGradient>fx,fy  内圈
  - <stop>  渐变颜色

  - fill:url(#xxx)  链接渐变

### SVG应用

[纯CSS实现帅气的SVG路径描边动画效果](http://www.zhangxinxu.com/wordpress/2014/04/animateion-line-drawing-svg-path-%E5%8A%A8%E7%94%BB-%E8%B7%AF%E5%BE%84/)

- `stroke-dasharray`  各虚线长度
- `stroke-dashoffset`  虚线的起始偏移

获取路径长度
```
<script>
	var path = document.querySelector('path');
	var length = path.getTotalLength();
</script>
``

#### 2017
``` css
<style>
	.one {
		stroke-dasharray: 600;
		stroke-dashoffset: 600;
		animation: ani 2s forwards;
	}
	.two {
		stroke-dasharray: 600;
		stroke-dashoffset: 600;
		animation: ani 1.8s forwards 0.2s;
	}
	.three {
		stroke-dasharray: 600;
		stroke-dashoffset: 600;
		animation: ani 1.6s forwards 0.4s;
	}
	@keyframes ani {
		to {
			stroke-dashoffset: 0;
		}
	}
</style>
```

三个颜色变换

``` html
<svg width="800" height="600">
	<!-- one -->
	<path d="M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563" class="one" stroke="#4A4A4A" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z" class="one"  stroke="#4A4A4A" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449" class="one"  stroke="#4A4A4A" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696" class="one"  stroke="#4A4A4A" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<!-- two -->
	<path d="M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563" class="two" stroke="#029df9" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z" class="two" stroke="#029df9" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449" class="two" stroke="#029df9" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696" class="two" stroke="#029df9" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<!-- three -->
	<path d="M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563" class="three" stroke="#90da32" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z" class="three" stroke="#90da32" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449" class="three" stroke="#90da32" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696" class="three" stroke="#90da32" stroke-width="8" fill="none" stroke-lineCap="round"></path>
</svg>
```

### 矢量图形库 Raphael.js
[Raphaël Reference](http://dmitrybaranovskiy.github.io/raphael/reference.html)

示例
```
<script src="libs/raphael.min.js"></script>
<script>
	// Creates canvas 320 × 200 at 10, 50
	var paper = Raphael(10, 50, 320, 200);

	// Creates circle at x = 50, y = 40, with radius 10
	var circle = paper.circle(50, 40, 10);
	// Sets the fill attribute of the circle to red (#f00)
	circle.attr("fill", "#f00");

	// Sets the stroke attribute of the circle to white
	circle.attr("stroke", "#fff");

	circle.click(function() {
		this.animate({
			fill: '#fe0',
			y: 100
		}, 500, 'bounce');
	})

	// circle.drag(function(dx,dy){
	// 	this.attr({
	// 		x: x + dx,
	// 		y: y + dy
	// 	})
	// },function(){
	// 	x = this.attr('x')
	// 	y = this.attr('y')
	// })
</script>
``

## 2.14

### Sass
- 变量
  `$color-white: #fff;`

- 嵌套

- 拼接 #{变量}
  ```
  $name : Name;

  .good#{$name}{
  	color: $color-white;
  }
  ```
  =>
  ```
  .goodName{
  	color: #fff;
  }
  ```

- 混合
  ```
  @mixin name($vari/$vari:#fff){
  	color: $vari;
  }

  .hello{
  	@include name($red);
  }
  ```

- 继承
  ```
  .hi{
  	@extend .hello;
  }
  ```


[sass-vs-less](https://css-tricks.com/sass-vs-less/)

[Sass和Less的区别](http://blog.csdn.net/wen81643956/article/details/40106525)

[sass 与 less 的区别与学习](http://www.cnblogs.com/StephenJiang/p/4607100.html)


### ES6

[ECMAScript 6 入门](http://es6.ruanyifeng.com/)

[Babel 入门教程](http://www.ruanyifeng.com/blog/2016/01/babel.html)

1. 变量声明
  - let  声明的变量作用在块级作用域
    - var 声明的变量作用在函数级作用域
  - const  定义常量 constant

2. 解构赋值
  eg: `let [a, b, c] = [1, 2, 3];` =>`let a = 1;let b = 2;let c = 3;`
  `let [bar, foo] = [1];`  foo为undefined

``` javascript
<script>
	var json = {a:1};
	var {a} = json;  // var a = json.a

	var arr = [1,2];
	var [a,b] = arr; // a=1 b=2
</script>
```

  ```
  <script>
    // 显示按下键码
	window.onkeydown = function({keyCode}){
		console.log(keyCode);
	}
  </script>
  ```

3. 箭头函数

	| ES5	    			| ES6	    |
	|  :----: 				|   :----: 	|
	|function(a){return a+1}|a => a+1    |
	|function(){return 1} 	|() => 1	|
	|function(a,b){return a+b} |(a,b) => a+b		|
	|function(a){let b = 1;return a+b}|a => {let b = 1;return a+b}|
    |var f = function(v) {return v;};|var f = v => v;|
    |function full(person) {return person.first + ' ' + person.last;}|const full = ({ first, last }) => first + ' ' + last;|

4. 字符串模板
  - ``  反引号标识
  - ${}  引用变量
  eg: `let message = \`${name}:${message}.\`;`
   => `let message = name + ':' + message + '.';`

5. Map
  Map类似于对象，也是键值对的集合，但是“键”的范围**不限于字符串**，各种类型的值（包括对象）都可以当作键。

  - keys() 返回键名的遍历器
  - values() 返回键值的遍历器
  - entries() 返回所有成员的遍历器
  - forEach() 遍历Map的所有成员

![Map的遍历](http://ojvx9eehr.bkt.clouddn.com/img/Map%E7%9A%84%E9%81%8D%E5%8E%86.PNG)

```
<script>
	map.forEach(function(value, key, map) {
	  console.log("Key: %s, Value: %s", key, value);
	});
</script>
```

```
<script>
	var map = new Map([
	  ['name', '张三'],
	  ['title', 'Author']
	]);

	map.size // 2
	map.has('name') // true
	map.get('name') // "张三"
	map.has('title') // true
	map.get('title') // "Author"
</script>
```

=> 原理

```
<script>
	var items = [
	  ['name', '张三'],
	  ['title', 'Author']
	];
	var map = new Map();
	items.forEach(([key, value]) => map.set(key, value));
</script>
```


6. 类

```
<script>
class Point {
  constructor(x, y) {  // 构造器
    this.x = x;
    this.y = y;
  }

  toString() {  // 类源性方法
    return '(' + this.x + ', ' + this.y + ')';
  }

  // toValue(){
  //  ...
  // }
}

Point === Point.prototype.constructor // true
</script>
```

=>

```
<script>
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};

// Point.prototype = {
//   toString(){},
//   toValue(){}
// };

var p = new Point(1, 2);
</script>
```

  - 类的继承

	```
	<script>
	class ColorPoint extends Point {
	  // constructor(...args) {
	  //   super(...args);
	  // }

	  constructor(x, y, color) {
	    super(x, y); // 调用父类的constructor(x, y)
	    this.color = color;
	  }

	  toString() {
	    return this.color + ' ' + super.toString(); // 调用父类的toString()
	  }
	}

	// 子类的__proto__属性指向父类，子类的prototype属性的__proto__属性指向父类的prototype属性。

	ColorPoint.__proto__ === Point // true
	ColorPoint.prototype.__proto__ === Point.prototype // true
	</script>
	```

7. 模块
  - import  引入模块
	`import http from 'http'`  类似于  `var http = require('http');`
  - export  导出模块
    `var firstName = 'Michael';var lastName = 'Jackson'; export {firstName, lastName};`  类似于  `module.exports = xxx;`

应用
```
<script>
	// circle.js

	export function area(radius) {
	  return Math.PI * radius * radius;
	}

	export function circumference(radius) {
	  return 2 * Math.PI * radius;
	}
</script>
```

```
<script>
	// main.js

	// import { area, circumference } from './circle';

	// console.log('圆面积：' + area(4));
	// console.log('圆周长：' + circumference(14));

	// 或者
	import * as circle from './circle';

	console.log('圆面积：' + circle.area(4));
	console.log('圆周长：' + circle.circumference(14));
</script>
```

### Bootstrap
[全局 CSS 样式 · Bootstrap v3 中文文档](http://v3.bootcss.com/css/#forms-control-sizes)

head
```
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bootstrap</title>
  <!-- Bootstrap -->
  <link href="libs/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>
```

```
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="libs/bootstrap/js/bootstrap.min.js"></script>
```

#### 1. 栅格系统

媒体查询
```
<style>
	/* 小屏幕（平板，大于等于 768px） */
	@media (min-width: @screen-sm-min) { ... }

	/* 中等屏幕（桌面显示器，大于等于 992px） */
	@media (min-width: @screen-md-min) { ... }

	/* 大屏幕（大桌面显示器，大于等于 1200px） */
	@media (min-width: @screen-lg-min) { ... }
</style>
```

| 			   		|超小屏幕 手机 (<768px)|小屏幕 平板 (≥768px) |中等屏幕 桌面显示器 (≥992px)|大屏幕 大桌面显示器 (≥1200px)|
|  :----: 	  		|   :----: 			   |	  :----: 		 |   :----: 				  |  :----: 					|
|栅格系统行为 		|	总是水平排列	   |开始是堆叠在一起的，当大于这些阈值时将变为水平排列C   							|
|.container最大宽度 |	None （自动）	   |750px				 |970px						  |1170px						|
|类前缀				|.col-xs-*			   |.col-sm-*			 |	.col-md-*     			  |	.col-lg-*    				|

- `.col-*-*`  占据几列(12列的基数)
- `.col-*-offset-*`  向右偏移几列(增加左侧margin)
- `.col-*-pull/push-*`  往左拉/往右推几列(改变列顺序)


> **每一块的栅格化都要在row标签内，row标签都要在container/container-fluid标签内**

示例
```
<div class="container-fluid">
  <div class="row">
    <div class="col-xs-12 col-md-8">.col-xs-12 .col-md-8</div>
    <div class="col-xs-6 col-md-4">.col-xs-6 .col-md-4</div>
  </div>
  <div class="row">
    <div class="col-md-3 col-md-offset-3">.col-md-3 .col-md-offset-3</div>
    <div class="col-md-3 col-md-offset-3">.col-md-3 .col-md-offset-3</div>
  </div>
  <div class="row">
    <div class="col-sm-9">
      Level 1: .col-sm-9
      <!-- 嵌套 -->
      <div class="row">
        <div class="col-xs-8 col-sm-6">
          Level 2: .col-xs-8 .col-sm-6
        </div>
        <div class="col-xs-4 col-sm-6">
          Level 2: .col-xs-4 .col-sm-6
        </div>
      </div>
    </div>
  </div>
</div>
```

#### 2. 排版
- `<h1> ~ <h6>/.h1 ~ .h6`  标题
- `<small>/.small`     副标题
- `.lead`      段落突出显示
- `<mark></mark>`  高亮文本
- `<del></del>`    被删除文本

- `text-left/center/right/justify`  文本居中方式
- `text-nowrap`  文本不换行
- `text-lowercase/uppercase/capitalize`  文本小写/大写/首字母大写

- `<address></address>`  地址
- `<blockquote></blockquote>`  引用
- `<blockquote class="blockquote-reverse"></blockquote>`  引用内容右对齐

- `.list-unstyled`  无样式列表
- `.list-inline`    内联样式列表
- `.dl-horizontal`  让<dl>内<dt>和<dd>并排呈现

#### 3. 表格
- `.table`  加了padding和水平分隔线的表格
- `.table-striped `  tbody每一行增加斑马条纹的表格
- `.table-bordered`  表格和单元格加边框的表格
- `.table-hover`     鼠标悬停至行时行底色变深的表格
- `.table-responsive`  其包裹的表格响应式(小于768px出现水平滚动条)
  ```
  <div class="table-responsive">
    <table class="table">
      ...
    </table>
  </div>
  ```

#### 4. 表单
- `.form-group`    每个表单元素用`<div class="form-group"></div>`包裹可呈现样式
- `.form-control`  设置了.form-control的`<input>` `<textarea>` 和 `<select>`等表单控件有默认样式

- `.form-inline`  <form>设置该项可呈现内容左对齐并排小姑
- `.form-horizontal`  <form>设置该项可使<label>和表单控件并排

- `.has-warning/error/success`  表单校验状态样式

- `.from-group-lg/sm`  表单大小
- `.input-lg/sm`  表单控件大小

示例
```
<form class="form-inline">
  <div class="form-group">
    <label class="sr-only" for="exampleInputEmail3">Email address</label>
    <input type="email" class="form-control" id="exampleInputEmail3" placeholder="Email">
  </div>
  <div class="form-group">
    <label class="sr-only" for="exampleInputPassword3">Password</label>
    <input type="password" class="form-control" id="exampleInputPassword3" placeholder="Password">
  </div>
  <button type="submit" class="btn btn-default">Sign in</button>
</form>
```

#### 5. 按钮
- `.btn .btn-default`  默认样式
- `.btn .btn-lg/sm/xs` 按钮大小
- `.btn .btn-block`    变为width:100%, 块级元素

#### 6. 图片
- `.img-responsive`    图片支持响应式(max-width:100%;height:auto;display:blcok)
- `.img-rounded/circle/thumbnail`  图片显示样式


#### 7. 其他
- `.close`   关闭按钮
- `.caret`   下拉功能三角符号

- `.center-block`  元素水平居中
- `.show/.hidden`  显示/隐藏

| 			   		|超小屏幕 手机 (<768px)|小屏幕 平板 (≥768px) |中等屏幕 桌面显示器 (≥992px)|大屏幕 大桌面显示器 (≥1200px)|
|  :----: 	  		|   :----: 			   |	  :----: 		 |   :----: 				  |  :----: 					|
|.visible-xs-*	|可见	|隐藏	|隐藏	|隐藏|
|.visible-sm-*	|隐藏	|可见	|隐藏	|隐藏|
|.visible-md-*	|隐藏	|隐藏	|可见	|隐藏|
|.visible-lg-*	|隐藏	|隐藏	|隐藏	|可见|
|  											 |
|.hidden-xs		|隐藏	|可见	|可见	|可见|
|.hidden-sm		|可见	|隐藏	|可见	|可见|
|.hidden-md		|可见	|可见	|隐藏	|可见|
|.hidden-lg		|可见	|可见	|可见	|隐藏|

- `.visible-*-block/inline/inline-block`  display属性

### React
[React 入门实例教程 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/03/react.html)

[React入门教程_React开发中文手册[PDF]下载-极客学院Wiki](http://wiki.jikexueyuan.com/project/react-tutorial/)

[Hello World - React](https://facebook.github.io/react/docs/hello-world.html)


#### 特点
1. JSX语法
2. 虚拟DOM(减少DOM操作，提高浏览器渲染性能)
3. 都是组件，所以代码更加模块化，重用更简便
4. 不变性
5. flux进行组件数据传输(单向数据流)
...

#### 组件间通信
1. 父级 -> 子级   this.props
2. 子级 -> 父级   this.props.callbackParent(newState), setState()
3. 没有嵌套关系的组件
  - 指定订阅源 otherObject.addEventListener()  订阅,this.dispatchEvent()  发送
  - 全局广播 globalBroadcast.subscribe()  订阅,globalBroadcaster.publish()  发送
  - 指定事件  otherObject.clicked.add()  订阅,this.clicked.dispatch()  发送

#### 虚拟DOM的Diff算法

[深入浅出React（四）：虚拟DOM Diff算法解析](http://www.infoq.com/cn/articles/react-dom-diff?from=timeline&isappinstalled=0)

给定任意两棵树，找到最少的转换步骤。
将普通Diff算法的复杂度从O(n^3)降低到O(n)

1. 两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构
2. 对于同一层次的一组子节点，可以通过唯一的id进行区分


#### 固定引入

```
<script src="libs/react/react.js"></script>
<script src="libs/react/react-dom.js"></script>
<script src="libs/react/browser.min.js"></script>
<script type="text/babel">
	// React code here
</script>

```

**以下内容主要整理自阮一峰老师的React教程，上附原文链接，特此说明。**

#### 1. ReactDOM.render
render用于将模板转为 HTML 语言，并插入指定的 DOM 节点。

```
<div id="app"></div>
<script src="libs/react/react.js"></script>
<script src="libs/react/react-dom.js"></script>
<script src="libs/react/browser.min.js"></script>
<script type="text/babel">
	var wrapper = document.querySelector('#app');

	ReactDOM.render(
		<div>Hello,React</div>,
		// JSX
		wrapper
	)
</script>
```

#### 2. 组件component
React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。

```
<script type="text/babel">
	// 注意script的type
	var wrapper = document.querySelector('#app');

	var Header = React.createClass({  // Header为组件类，**每个单词的首字母需大写
		render:function(){
			return (
				<header className="good">
					<div className="logo"></div>
					<nav>
						<ul>
							<li>首页</li>
							<li>产品</li>
							<li>Coll</li>
							<li>美女</li>
						</ul>
					</nav>
				</header>
			)
		}
	})

	ReactDOM.render(
		<div>
			<Header></Header>  // 生成实例
			<Header></Header>
			<Header></Header>
			<Header></Header>
			<Header></Header>
		</div>,
		wrapper
	)
</script>
```

#### 3. props

- this.props

```
<script type="text/babel">
	var HelloMessage = React.createClass({
	  render: function() {
	    return <h1>Hello {this.props.name}</h1>;  // this.props获取属性
	  }
	});

	ReactDOM.render(
	  <HelloMessage name="John" />,  // 向组件加入name属性，值为John
	  document.getElementById('example')
	);
</script>
```

> **添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。**

- this.props.children
**this.props.children** 组件的所有子节点

[5个数组Array方法: indexOf、filter、forEach、map、reduce使用实例_javascript技巧_脚本之家](http://www.jb51.net/article/60502.htm)
```
<script>
	var a = [1,2,3].forEach((a) => { a+1 }); // a:undefined

	var b = [1,2,3].map((a) => {a+1}) // b:[2,3,4]
</script>
```

```
<script type="text/babel">
	var NotesList = React.createClass({
	  render: function() {
	    return (
	      <ol>
	      {
	        React.Children.map(this.props.children, function (child) {
	          return <li>{child}</li>;
	        })
	      }
	      </ol>
	    );
	  }
	});

	ReactDOM.render(
	  <NotesList>
	    <span>hello</span>
	    <span>world</span>
	  </NotesList>,
	  document.body
	);
</script>
```

#### 4. PropTypes
- PropTypes 用来验证组件实例的属性是否符合要求。

示例
```
<script type="text/babel">
	var MyTitle = React.createClass({
	  // PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。
	  propTypes: {
	    title: React.PropTypes.string.isRequired,
	  },

	  render: function() {
	     return <h1> {this.props.title} </h1>;
	   }
	});

	var data = 123;

    // title数据类型不正确，结果报错
	ReactDOM.render(
	  <MyTitle title={data} />,
	  document.body
	);
</script>
```

- getDefaultProps()  设置组件属性默认值

```
<script type="text/babel">
	var MyTitle = React.createClass({
	  getDefaultProps : function () {
	    return {
	      title : 'Hello World'
	    };
	  },

	  render: function() {
	     return <h1> {this.props.title} </h1>;
	   }
	});

	ReactDOM.render(
	  <MyTitle />,
	  document.body
	);
</script>
```

#### 5. refs
组件并**不是真实的 DOM 节点**，而是存在于内存之中的一种数据结构，叫做**虚拟 DOM** （virtual DOM）。只有当它**插入文档以后**，才会变成真实的 DOM 。

- ref  从组件获取真实DOM的节点

> ref在虚拟DOM元素上绑定为属性并赋值
this.refs.[refName]返回真实DOM节点进行操作
**返回的真实DOM节点需在插入文档后，所以定义为事件调用操作函数**


示例
```
<script type="text/babel">
	var MyComponent = React.createClass({
	  handleClick: function() {
	    this.refs.myTextInput.focus();  // this.refs.[refName]返回真实DOM节点
	  },
	  // 在input 上绑定ref属性
	  render: function() {
	    return (
	      <div>
	        <input type="text" ref="myTextInput" />
	        <input type="button" value="Focus the text input" onClick={this.handleClick} />
	      </div>
	    );
	  }
	});

	ReactDOM.render(
	  <MyComponent />,
	  document.getElementById('example')
	);
</script>
```

#### 6. state
- this.state     读取当前状态
- getInitialState()  定义初始状态
- this.setState()  修改状态

**this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。**

示例
```
<script type="text/babel">
	var LikeButton = React.createClass({
	  getInitialState: function() {
	    return {liked: false};
	  },
	  handleClick: function(event) {
	    this.setState({liked: !this.state.liked});
	  },
	  render: function() {
	    var text = this.state.liked ? 'like' : 'haven\'t liked';
	    return (
	      <p onClick={this.handleClick}>
	        You {text} this. Click to toggle.
	      </p>
	    );
	  }
	});

	ReactDOM.render(
	  <LikeButton />,
	  document.getElementById('example')
	);
</script>
```

```
<script type="text/babel">
	var wrapper = document.querySelector('#app');

	var Clock = React.createClass({
		getInitialState:function(){
			return this.getTime();
		},
		componentWillMount:function(){
			setInterval(() => {
				this.setState(this.getTime());
			},1000)
		},
		render:function(){
			var {
				hour,
				minute,
				second
			} = this.state;

			return (
				<div>
					<span style={{color: this.props.color || 'blue'}}>{ `${hour}:${minute}:${second}` }</span>
				</div>
			)
		},
		getTime:function(){
			var date = new Date();

			return {
				hour:date.getHours(),
				minute:date.getMinutes(),
				second:date.getSeconds()
			}
		}
	})

	ReactDOM.render(
		<div>
			<Clock color="red"/>
			<Clock/>
			<Clock color="pink"/>
			<Clock/>
		</div>,
		wrapper
	)
</script>
```

![setState](http://ojvx9eehr.bkt.clouddn.com/img/state.gif)

#### 7. 组件的生命周期
三种状态
- Mounting    已插入真实 DOM
- Updating    正在被重新渲染
- Unmounting  已移出真实 DOM

五种状态处理函数(**will位进入状态前，did为进入状态后**)
- componentWillMount()

- componentDidMount()

- componentWillUpdate(object nextProps, object nextState)

- componentDidUpdate(object prevProps, object prevState)

- componentWillUnmount()

两种特殊状态处理函数
- componentWillReceiveProps(object nextProps) 已加载组件收到新的参数时调用

- shouldComponentUpdate(object nextProps, object nextState)  组件判断是否重新渲染时调用

```
<script type="text/babel">
	var Hello = React.createClass({
	  getInitialState: function () {
	    return {
	      opacity: 1.0
	    };
	  },

	  componentDidMount: function () {
	    this.timer = setInterval(function () {
	      var opacity = this.state.opacity;
	      opacity -= .05;
	      if (opacity < 0.1) {
	        opacity = 1.0;
	      }
	      this.setState({
	        opacity: opacity
	      });
	    }.bind(this), 100);
	  },

	  // **注意style写法  第一重大括号表示 JavaScript 语法，第二重大括号表示样式对象。
	  render: function () {
	    return (
	      <div style={{opacity: this.state.opacity}}>
	        Hello {this.props.name}
	      </div>
	    );
	  }
	});

	ReactDOM.render(
	  <Hello name="world"/>,
	  document.body
	);
</script>
```

![componentDidMount](http://ojvx9eehr.bkt.clouddn.com/img/%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.gif)

#### 8. Ajax
```
<script type="text/babel">
	var UserGist = React.createClass({
	  getInitialState: function() {
	    return {
	      username: '',
	      lastGistUrl: ''
	    };
	  },

	  componentDidMount: function() {
	    $.get(this.props.source, function(result) {
	      var lastGist = result[0];
	      if (this.isMounted()) {
	        this.setState({
	          username: lastGist.owner.login,
	          lastGistUrl: lastGist.html_url
	        });
	      }
	    }.bind(this));
	  },

	  render: function() {
	    return (
	      <div>
	        {this.state.username}'s last gist is
	        <a href={this.state.lastGistUrl}>here</a>.
	      </div>
	    );
	  }
	});

	ReactDOM.render(
	  <UserGist source="https://api.github.com/users/octocat/gists" />,
	  document.body
	);
</script>
```

### 高级运动

#### 弹性运动 elastic.js
```
<div class="container">
	<div class="navigator">
		<div class="slider"></div>
		<ul>
			<li>xx</li>
			<li>xx</li>
			<li>xx</li>
			<li>xx</li>
			<li>xx</li>
		</ul>
	</div>
</div>
<script src="js/elastic.js"></script>
<script>
	var aLi = document.querySelectorAll('li');
	var oSlider = document.querySelector('.slider');

	aLi.forEach(function(oLi){
		oLi.onmouseenter = function(){
			elastic(oSlider,this.offsetLeft);
		}

		oLi.onmouseleave = function(){
			elastic(oSlider,100);
		}
	})
</script>
```

#### 碰撞运动 bounce.js

```
<div class="block"></div>
<script src="js/bounce.js"></script>
<script>
	var oBlock = document.querySelector('.block');

	var speedX = 0;
	var speedY = 0;

	var lastX = 0;
	var lastY = 0;

	oBlock.onmousedown = function({
			clientX,clientY
		}){

		var disX = clientX - oBlock.offsetLeft;
		var disY = clientY - oBlock.offsetTop;

		document.onmousemove = function({
			clientX,clientY
		}){
			var deltaX = clientX - disX;
			var deltaY = clientY - disY;

			speedX = deltaX - lastX;
			speedY = deltaY - lastY;

			lastX = deltaX;
			lastY = deltaY;

			oBlock.style.left = deltaX + 'px';
			oBlock.style.top = deltaY + 'px';
		}

		document.onmouseup = function(){
			bounce(oBlock,speedX,speedY);

			document.onmousemove = null;
			document.onmouseup = null;
		}
	}
</script>
```

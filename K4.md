##1.9

### 1. H5
[翻译-你必须知道的28个HTML5特征、窍门和技术](http://www.zhangxinxu.com/wordpress/2010/08/%E7%BF%BB%E8%AF%91-%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8428%E4%B8%AAhtml5%E7%89%B9%E5%BE%81%E3%80%81%E7%AA%8D%E9%97%A8%E5%92%8C%E6%8A%80%E6%9C%AF/)

[html5shiv项目让IE6-IE9浏览器都支持HTML5中的元素](http://www.zhangxinxu.com/wordpress/2013/02/github-html5shiv-readme-translate/)

#### 1.1 H5选择器
querySelector() 匹配指定 CSS 选择器的一个元素
querySelectorAll() 匹配指定 CSS 选择器的所有元素。
> 注意：querySelectorAll()方法得到的类数组对象是非动态实时的

querySelectorAll对比getElements的优势
-> 可以操作数组
``` html
	<div class="box"></div>
	<div class="box"></div>
	<div class="box"></div>
```

``` javascript
	<script>
		var aBox = document.querySelectorAll('div');
		// var aBox = document.getElementsByTagName('div');	// 该方法得到的是伪数组，不能操作各项的属性

		// for (var i = 0; i < aBox.length; i++) {
		// 	aBox[i].onclick = function() {
		// 		alert(1);
		// 	}
		// }

		// 循环深入

		aBox.forEach(function(item, index) {
			item.onclick = function() {
				alert(index);	// 弹出当前点击div的索引值 依次为0、1、2
			}
		})
	</script>
```

**jQuery的选择器即是querySelectorAll**
``` javascript
<script>
	function $(selector) {
		var items = document.querySelectorAll(selector);

		if (items.length > 1) {
			return items;
		} else if (items.length == 0) {
			return;
		} else {
			return items[0];
		}
	}
</script>
```

#### 1.2 H5自定义属性dataset

[HTML5自定义属性对象Dataset简介](http://www.zhangxinxu.com/wordpress/2011/06/html5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1dataset%E7%AE%80%E4%BB%8B/)

[HTML5 datalist在实际项目中应用的可行性研究](http://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/)

示例
``` html
	<a data-link="#" data-user-name="chloe">baidu.com</a>
```

``` javascript
	<script>
		var oA = document.querySelector('a');
		oA.dataset.link = 'https://www.baidu.com';
		oA.href = oA.dataset.link + '?name=' + oA.dataset.userName;	// https://www.baidu.com/?name=chloe
		// 注意：两个及以上属性名调用时需转化为驼峰命名
	</script>
```
#### 1.3 H5元素类名操作classList

[HTML5 DOM元素类名相关操作API classList简介](http://www.zhangxinxu.com/wordpress/2013/07/domtokenlist-html5-dom-classlist-%E7%B1%BB%E5%90%8D/)

``` html
<!-- 该示例来源于张鑫旭个人博客 -->
<body class="a b c"></body>
```

``` javascript
<script>
	console.log(document.body.classList);
	console.log(document.body.className);
	console.log(document.body.classList.toString() === document.body.className;)	// true
</script>
```

> HTML5 DOM元素类名相关操作API classList简介>>>测试

![HTML5 DOM元素类名相关操作API classList简介>>>测试](http://img.blog.csdn.net/20170110000715296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzk1MDkxNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

隐式原型上的方法：(不一一列举)
- obj.add(cName1, cName2, ...);
- obj.remove(cName1, cName2, ...);
- obj.toggle(cName);
- obj.contains(cName);

#### 1.4 H5本地存储localStorage

**坑：首先注意name这个独特的变量名**

``` javascript
<script>
	alert(name);	// 第一次 ''  刷新浏览器 'chloe'
	alert(a);		// 第一次 undefined  刷新浏览器 'undefined'
	// console.log(name);
	// console.log(a);
	var name = 'chloe';
	var a = 'aaa';
</script>
```

解释：(源自[JavaScript 保留关键字](http://www.runoob.com/js/js-reserved.html))


![js内置属性](http://img.blog.csdn.net/20170110134557301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzk1MDkxNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


[HTML5 localStorage本地存储实际应用举例](http://www.zhangxinxu.com/wordpress/2011/09/html5-localstorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/)

**cookie && localStorage && sessionStorage** (来源CSDN)
- 共同点：
     都是保存在浏览器端，且同源的。
- 不同点：

1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

2. cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。

3. 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

4. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。

5. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

6. Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。


##### 1.4.1 Web Storage实际上由两部分组成：sessionStorage与localStorage。

- sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。

- localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

> 兼容：可以先测试，以确定window.localStorage是否存在。

sessionStorage与localStorage操作相同

- 设置

	`localStorage.key = value;`

	`localStorage.setItem(key,value);`

``` javascript
<script>
	var userName = 'chloe';

	//存储，IE6~7 cookie 其他浏览器HTML5本地存储
	if (window.localStorage) {
		localStorage.setItem("name", userName);
	} else {
		Cookie.write("name", userName);	// MooTools框架下cookie的写法
	}
</script>
```

- 读取

	`localStorage.key;`

	`localStorage.getItem(key);`

``` javascript
<script>
	var userName = window.localStorage ? localStorage.getItem("name") : Cookie.read("name"); // MooTools框架下cookie的写法
</script>
```

- 遍历

``` javascript
<script>
	var storage = window.localStorage;
	for (var i = 0, len = storage.length; i < len; i++) {
		var key = storage.key(i);
		var value = storage.getItem(key);
		console.log(key + "=" + value);
	}
</script>
```

- 删除

	`delete localStorage.key;`

	`localStorage.removeItem(key);`

``` javascript
<script>
	if (window.localStorage) {
		localStorage.removeItem("name");
	} else {
		Cookie.dispose('name'); // MooTools框架下cookie的写法
	}
</script>
```

- 清空

	`localStorage.clear();`

> window.onstorage 监听localstorage变化

### 2. toString() && valueOf()
toString() 把一个逻辑值转换为字符串，并返回结果

valueOf()  返回 Boolean 对象的原始值

> 源自知乎

>这两个方法一般是交由JS去隐式调用，以满足不同的运算情况。

>在数值运算里，会优先调用valueOf()，如a + b；

>在字符串运算里，会优先调用toString()，如alert(c)。

``` javascript
<script>
	// 该示例来源于脚本之家
	var bbb = {
		i: 10,
		toString: function() {
			console.log('toString');
			return this.i;
		},
		valueOf: function() {
			console.log('valueOf');
			return this.i;
		}
	}

	alert(bbb); // 10 toString
	alert(+bbb); // 10 valueOf
	alert('' + bbb); // 10 valueOf
	alert(String(bbb)); // 10 toString
	alert(Number(bbb)); // 10 valueOf
	alert(bbb == '10'); // true valueOf
	alert(bbb === '10'); // false
</script>

```

``` javascript
<script>
	console.log({
		valueOf: function() {
			return 20;
		}
	} * {
		valueOf: function() {
			return 30;
		}
	});		// 600
</script>
```

### 3. JSON

之前的例子

1.JSON.stringify(object);	// 对象 -> 字符串

eg: `{a:1,b:2}` -> `"{"a":1,"b":2}"`

2.JSON.parse(str);		// 字符串 -> json对象

`{"name":"huangxiaojian","age":"23"}'` ->
`{`
	`age: "23"`
	`name: "huangxiaojian"`
	`__proto__: Object`
`}`


JSON.stringify(object) 将对象字符串序列化成标准JSON字符串

JSON.parse(str)        将字符串序列化成对象

``` html
<a href="https://www.baidu.com/" attr1='13'>baidu.com</a>
```

``` javascript
<script>
	var oA = document.querySelector('a');
	console.log(oA.getAttribute('attr1')); // 13

	oA.setAttribute('attr1', '14');
	var number = oA.getAttribute('attr1');
	console.log(oA.getAttribute('attr1')); // 14
	console.log(typeof number);	// string 直接设置自定义属性只能得到string类型

	oA.setAttribute('attr1', JSON.stringify({
		name: 14
	}));

	var number2 = oA.getAttribute('attr1');

	console.log(number2); // {"name": "14"}
	console.log(JSON.parse(number2)); // -> Object {name: "14"}
									  // 		name: "14"
									  // 		-> _proto_: Object
	console.log(JSON.parse(number2).name); // 14
	console.log(typeof JSON.parse(number2).name); // number JSON转化得到了真正类型
</script>
```


### 4. css3
#### 4.1 border-radius
10px 20px 30px 40px -> 左上角起顺时针经过的角的顺序

10px 20px 30px 40px / 30px 10px 40px 20px

/ -> 分离x/y轴方向半径

#### 4.2 box-shadow
[inset]  10px   20px   30px      40px   black;

[内阴影] x位移 y位移 模糊半径  弥散半径 颜色

多边框实例
``` css
<style>
	#box{
		width: 100px;
		height: 100px;
		box-shadow: 0 0 0 10px black,
					0 0 0 20px green,
					0 0 0 30px pink,
					0 0 0 40px purple,
					0 0 0 50px orange,
					0 0 0 60px khaki,
					0 0 0 70px indigo,
					0 0 0 80px plum,
					0 0 0 90px violet;
		margin: 200px auto;
	}
</style>
```

##1.10

### 4. css3
#### 4.3 transform(搭配transition使用效果更佳)
**以下属性可以一同使用**

- rotate([deg]) 旋转

`tansform: rotate(30deg);` 正向旋转30度
`tansform: rotate(0.785rad);` 正向旋转0.785弧度
`tansform: rotateX|Y|Z(45deg);`
> 角度转弧度 π/180×角度
弧度变角度 180/π×弧度

transofrm-origin 旋转中心

eg:
`transofrm-origin: left|top|bottom|right|center(默认);`
`transofrm-origin: left top|left bottom|right top|left center|center bottom;`
`transofrm-origin: -120px -120px;`

- translate(x, y) 偏移
x>0 右偏移
x<0 左偏移
y>0 下偏移
y<0 上偏移

`transform: translate(-30px, -40px);` 左偏移30px, 右偏移40px
`transform: translateX|Y|Z(-30px);`

- scale(s); 放大/缩小

`transform: scale(0.2)` 宽高缩小至0.2倍的大小
`transform: scale(0.2, 1)` 宽度缩小至0.2倍大小，高度不变
`transform: scaleX|scaleY(0.2)`


- skew([deg]) 倾斜

`transform: skew(20deg)` 水平向左倾斜20度
`transform: skewX(20deg)` 水平向左倾斜20度
`transform: skewY(20deg)` 垂直向上倾斜20度
`transform: skew(20deg, 20deg)` 水平向左倾斜20度，垂直向上倾斜20度


- 关于多属性
transform多属性时从后向前解析

eg:
`transform: rotate(45deg) scale(2,1);`	先横向放大再旋转
`transform: scale(2,1) rotate(45deg);`  先旋转再横向放大

#### 4.4 transition
transition([]); 过渡

transition 属性是一个简写属性，用于设置**四个过渡属性**：

- transition-property 设置过渡效果的 CSS 属性的名称
- transition-duration 完成过渡效果需要多少秒
- transition-timing-function 速度效果的速度曲线
	- linear      匀速等于 cubic-bezier(0,0,1,1)
    - ease	      慢速开始，然后变快，然后慢速结束 cubic-bezier(0.25,0.1,0.25,1)
    - ease-in     慢速开始 等于 cubic-bezier(0.42,0,1,1)
    - ease-out	  慢速结束 等于 cubic-bezier(0,0,0.58,1)
    - ease-in-out 慢速开始和结束 等于 cubic-bezier(0.42,0,0.58,1)
    - cubic-bezier(n,n,n,n)
- transition-delay 过渡效果何时开始

eg:
``` css
<style>
	#box{
		width: 200px;
		height: 200px;
		background-color: green;
		transition: 1s width cubic-bezier(1, 1.7, 0, 1.54) 1s;	/* 1s后由400px过渡到200px */
	}
	#box:active{
		width: 400px;
		transition: 0s;	/* 按下0s后变为400px */
	}
</style>
```
#### 4.5 animation
animation([]); 动画

animation 属性是一个简写属性，用于设置**六个动画属性**：

- animation-name 需要绑定到选择器的 keyframe 名称
- animation-duration 完成动画所花费的时间
- animation-timing-function 动画的速度曲线
- animation-delay 在动画开始之前的延迟
- animation-iteration-count 动画应该播放的次数
	- n	       播放次数
	- infinite 无限次播放
- animation-direction 是否应该轮流反向播放动画
	- alternate	轮流反向播放
	- reverse   反向播放
	- alternate-reverse 反向交替播放
- animation-fill-mode 结束状态
	- forwards  停留在结束状态
	- backwards 返回原始状态
- animation-play-state 暂停动画
	- paused   动画已暂停
	- running 动画正在播放

keyframe 关键帧
``` css
<style>
	@keyframes name{
		from{

		}
		to{

		}

		10%{

		}
		20%{

		}
		100%{

		}
	}
</style>
`

#### 4.6 perspective
perspective 视角

指定观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果

[小tip: 纯CSS实现视差滚动效果](http://www.zhangxinxu.com/wordpress/2015/03/css-only-parallax-effect/)
[好吧，CSS3 3D transform变换，不过如此！](http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/)

perspective属性有两种书写形式，一种用在舞台元素上（动画元素们的共同父辈元素）；第二种就是用在当前动画元素上，与transform的其他属性写在一起

1. perspective:800px; -> 给当前元素的子集增加视角
2. transform:perspective(800px)(必须最前面) rotate... -> 给当前元素增加视角

开启3D空间

transform-style:preserve-3d;
加给3D变化元素父集,不可继承

transform-style: preserve-3d

#### 4.6 direction
文字转向 需配合unicode-bidi使用

`direction: rtl; unicode-bidi: bidi-override;`

#### 4.7 -webkit-mask
遮罩
**webkit下神奇的图层蒙版效果**

`-webkit-mask: url(xxx.jpg);` 背景按mask图片大小显示
`-webkit-mask:linear-gradient(rgba(0,0,0,1)), to(rgba(0,0,0,0);` 背景按渐变遮罩显示

#### 4.8 box-reflect
倒影

[-webkit-box-reflect各个属性值效果演示](http://www.zhangxinxu.com/study/201608/-webkit-box-reflect.html)

box-reflect：none | <direction> <offset>? <mask-box-image>?

方向<direction> = above | below | left | right
间隔<offset> = <length> | <percentage>
遮罩<mask-box-image> = none | <url> | <linear-gradient> | <radial-gradient> | <repeating-linear-gradient> | <repeating-radial-gradient>

#### 4.9 text-shadow
文字阴影
`text-shadow: x-shadow y-shadow [blur] [color];`

水平阴影位置 垂直阴影位置 模糊的距离 阴影颜色

#### 4.10 resize
是否允许用户调整元素的尺寸

`resize: none`			用户无法调整元素的尺寸
`resize: both`			用户可调整元素的高度和宽度
`resize: horizontal`	用户可调整元素的宽度
`resize: vertical`		用户可调整元素的高度

#### 4.11 background-image内的一些属性
- linear-gradient 线性渐变

background:linear-gradient(direction, start-color, stop-color);

direction:
to top    ->	0deg   -> 从下到上
to right  ->	90deg  -> 从左到右
to bottom ->	180deg -> 从上到下（默认值）
to left	  ->    270deg -> 从右到左
to top left	 ->	右上角到左上角（斜对角）
to top right ->	左下角到右上角（斜对角）

eg:
`background-image: linear-gradient(red,blue);`
`background-image: linear-gradient(250deg,red,blue);`
`background-image: linear-gradient(red,orange,yellow,green,blue,indigo,violet);`
`background-image: linear-gradient(red 50%,blue 50%);` 跳变
`background-image: linear-gradient(90deg,blue 33.33333%,white 33.33333%,white 66.66666%,red 66.66666%,red 100%);` 0~1/3是蓝色 1/3~2/3是白色 2/3~1是红色

- radial-gradient 径向渐变

background:radial-gradient(position ,shape size, start-color, stop-color);

position 圆心位置

shape:
circle	定义径向渐变为“圆形”
ellipse	定义径向渐变为“椭圆形”

size:
closet-side	指定径向渐变的半径长度为从圆心到离圆心最近的边
closest-corner	指定径向渐变的半径长度为从圆心到离圆心最近的角
farthest-side	指定径向渐变的半径长度为从圆心到离圆心最远的边
farthest-corner	指定径向渐变的半径长度为从圆心到离圆心最远的角

eg:
`background-image: radial-gradient(red,blue);` 内圆红色，外框蓝色
`background-image: radial-gradient(red,orange,yellow,green,blue,indigo,violet);border-radius: 50%;`
`background-image: radial-gradient(circle,red 30%,white 30%);`
`background-image: -webkit-radial-gradient(100px 100px,circle farthest-corner,red,blue);`
`background-image: -webkit-radial-gradient(100px 100px,circle farthest-side,red,blue);`
`background-image: -webkit-radial-gradient(150px 100px,200px 80px,red,blue);`


- repeating-linear-gradient 重复渐变
eg:
`background-image: repeating-linear-gradient(red,blue 20%);`


#### 4.12 background相关属性
- background-origin 相对于内容框来定位背景图像

`background-origin: border-box;`  相对于边框盒来定位背景图像：
`background-origin: content-box;` 相对于内容框来定位背景图像：
`background-origin: padding-box;` 相对于内边距框来定位背景图像：

- background-clip 裁剪背景图片

`background-clip: border-box;`  相对于边框盒来定位背景图像：
`background-clip: content-box;` 相对于内容框来定位背景图像：
`background-clip: padding-box;` 相对于内边距框来定位背景图像：

**webkit下神奇的图层蒙版效果**
- webkit-background-clip(字内显示图片)
eg:
``` css
<style>
	#box {
		width: 200px;
		height: 200px;
		background: url(xxx.jpg);
		background-size: cover;
		-webkit-background-clip: text;
		font-size: 200px;
		font-weight: bolder;
		color: rgba(0, 0, 0, 0.1);
	}
</style>
```
``` html
	<div id="box">品</div>
```

- background-attachment
`background-attachment: scroll` 默认值。背景图像会随着页面其余部分的滚动而移动。
`background-attachment: fixed`	当页面的其余部分滚动时，背景图像不会移动。

[](background-attachment2.html)

- background-size 背景图像尺寸

`background-size: 3em, 25%;`  自定义背景图像尺寸
`background-size: cover;`     使背景图像完全覆盖背景区域(图像可能被裁剪)
`background-size: contain;`   完全包含背景图(no-repeat背景区域可能有空白)

- background-position 背景图像定位

`background-position: center|top|right|bottom|left`
`background-position: 20px 20%`

#### 4.13 fliter(滤镜)的属性
[CSS3 Filter的十种特效](http://www.w3cplus.com/css3/ten-effects-with-css3-filter)

- blur 模糊
eg:
`filter: blur(20px);`

- drop-shadow 阴影
[CSS3 filter:drop-shadow滤镜与box-shadow区别应用](http://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/)
eg:
`filter: drop-shadow(100px 1px 2px black);`

- invert 反色
eg:
`filter: invert(0.7);`

- brightness 亮度
eg:
`filter: brightness(.5);`

- sepia 褐色
eg:
`filter: sepia(1);`

- hue-rotate 色相旋转
eg:
`filter: hue-rotate(30deg);`

- saturate 饱和度
eg:
`filter: saturate(10);`



### 5. 库&&框架
库：lib，方法库，或组件库。核心库是给二次开发同学用的，它严谨、符合标准、独立健壮、无污染。eg: jQuery

框架：framework，主要是给用户使用，当然也给二次开发者用，它易使用、易扩展、可持续发展、可控。 eg: Angular.js

[框架和类库的区别](http://blog.sina.com.cn/s/blog_732ae613010155gj.html)

### 6. H5新增标签
header -> 头部
footer -> 底部
nav -> 导航
section -> 部分
aside -> 侧边栏
article -> 文章
mark -> 高亮(默认黄底高亮)
datalist -> 用input的list属性配合datalist的id属性 生成 可输入下拉框
dialog -> 定义对话框或窗口

meter -> 度量条
eg:
`<meter value="3" min="0" max="10">3/10</meter><br>
<meter value="0.6">60%</meter>`

progress -> 下载进度条
eg:
`<progress max="100"></progress>
<progress value="22" max="100"></progress>`

address -> 地址
summary -> 总结/梗概(下拉按钮展开details内容)
details -> summary里 -> 详情
eg:
`<details>
<summary>HTML 5</summary>
This document teaches you everything you have to learn about HTML 5.
</details>`

figure -> 内容相关，去掉不影响理解的内容
figcaption -> figure里
`<figure>
  <img src="xxx.jpg">
  <figcaption>描述</figcaption>
</figure>`

time -> 时间

### 7. CSS3新增选择器
####属性选择器
[attr=value] -> 匹配属性
[attr^=value] -> 匹配开头
[attr$=value] -> 匹配结尾
[attr|=value] -> 匹配value-开头
[attr~=value] -> 匹配空格隔开的单词

####结构选择器
:nth-child(n) -> 数字 从1开始
:nth-child(2n/2n-1/2n+1) -> 表达式
:nth-child(odd/even) -> 关键字
:nth-last-child(n/表达式) -> 倒着算
:first-child -> 选中第一项
:last-child -> 选中最后一项

####文字伪类选择器 -> p
:first-letter
:first-line
::selection

####其他选择器
:not() -> 反选
:after -> 从后面增加
:before -> 从前面增加
:target -> 被锚点锚住的元素

更详细的内容 css3.md && html5.md

##1.10

###CSS3
####老版浏览器的内核前缀

css

-webkit-transition: 1s;
-moz-transition: 1s;
-o-transition: 1s;
transition:	1s;

js(去掉-, 首字母大写)

WebkitTransition
MozTransition
OTransition

####属性选择器
**兼容：IE7+**

- E[attr]
- E[attr="value"]  **只含一个属性值**
- E[attr~="value"]   attr属性值包含value
- E[attr^="value"]   attr属性值以value开头
- E[attr$="value"]   attr属性值以value结束
- E[attr*="value"]   attr属性值包含value字符
- E[attr|="value"]   attr属性值是value或者"value-"开头  **只含一个属性值**


``` css
<style>
	p[attr1] {
		background: #f00;
	}
	p[attr1=a] {
		background: #0ff;
	}
	p[attr1~=c] {
		background: #00f;
	}
	p[attr1^=e] {
		background: #ff0;
	}
	p[attr1$=g] {
		background: #f0f;
	}
	p[attr1*=i] {
		background: #0f0;
	}
	p[attr1|=k] {
		background: #fff;
	}
</style>
```

``` html
	<strong>E[attr="value"] **只含一个属性值**</strong>
   	<p attr1="a">attr1="a"</p>
   	<p attr1="b a">attr1="b a"</p>
   	<hr/>
   	<strong>E[attr~="value"] attr属性值包含value</strong>
   	<p attr1="c">attr1="c"</p>
   	<p attr1="d c">attr1="d c"</p>
   	<hr/>
   	<strong>E[attr^="value"] attr属性值以value开头</strong>
   	<p attr1="e">attr1="e"</p>
   	<p attr1="f ef">attr1="f ef"</p>
   	<p attr1="ef f">attr1="ef f"</p>
   	<hr/>
   	<strong>E[attr$="value"] attr属性值以value结束</strong>
   	<p attr1="g gh">attr1="g gh"</p>
   	<p attr1="h hg">attr1="h hg"</p>
   	<hr/>
   	<strong>E[attr*="value"] attr属性值包含value字符</strong>
   	<p attr1="i">attr1="i"</p>
   	<p attr1="j jij">attr1="j jij"</p>
   	<hr/>
   	<strong>E[attr|="value"] attr属性值是value或者"value-"开头  **只含一个属性值**</strong>
   	<p attr1="k">attr1="k"</p>
   	<p attr1="l k">attr1="l k"</p>
   	<p attr1="m k-m">attr1="m k-m"</p>
   	<p attr1="k-m">attr1="k-m"</p>

```

![css3属性选择器](http://img.blog.csdn.net/20170110165816536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzk1MDkxNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

####结构选择器
**兼容：IE9+**

**下标索引从1开始**

- `:nth-child(n) ` 找当前节点的父节点下的第n个子节点，当且仅当该子节点与当前节点的类型相符时有效

- `:nth-last-child(n)`  找当前节点的父节点下的倒数第n个子节点，当且仅当该子节点与当前节点的类型相符时有效

- `:nth-of-type(n)` 找当前节点的父节点下的第n个与当前节点的类型相符的子节点

- `:nth-last-of-type(n)` 找当前节点的父节点下的倒数第n个与当前节点的类型相符的子节点

- `:first-child`  即 :nth-child(1)

- `:last-child`  即 :nth-last-child(1)

- `:first-of-type`  即 :nth-of-type(1)

- `:last-of-type`  即 :nth-last-of-type(1)

- `:only-child`	  当前节点的父节点下只有一个子节点时有效

- `:only-of-type` 当前节点的父节点下与当前节点的类型相符的子节点只有一个时有效，可有多个其他类型子节点

---

- `:target`  设置跳转锚点属性  <a href="#div1"></a> -> <div id="div1"></div>

- `:disabled`  不可点击的表单控件

- `:enabled`   可点击的表单控件

- `:checked`   选中的checkbox/radio

- `A~B`        A元素后的第一个类型为B的兄弟节点    **应用：模拟checkbox**

- `:first-line`	当前节点的第一行

- `:first-letter` 当前节点的第一个字符

- `:not(x)`      不匹配x时有效

伪元素

- `::selection`  在当前节点内选中文字时有效

- `::before`     搭配content使用，在当前节点内容最前面插入content **不增加DOM**

- `::before`     搭配content使用，在当前节点内容最后面插入content **不增加DOM**

####颜色rgba
之前的opacity改变背景色透明度时同时改变文字颜色透明度

rgba可实现只改变背景色透明度

####文字阴影
text-shadow: [x轴 y轴 模糊度 弥散度 颜色]

x轴：正值 -> 向右 负值 -> 向左

y轴：正值 -> 向下 负值 -> 向上

阴影叠加

####文字省略text-overflow
``` css
<style>
	.ell {
		white-space: nowrap;  /* 不允许换行 */
		overflow: hidden;     /* 超出隐藏 */
		text-overflow: ellipsis;  /* 超出显示省略号，默认为clip(无省略号) */
	}
</style>
```


# html5
语法：
1. 内容类型
2. DOCTYPE声明
3. 指定字符编码
4. 可以省略标记的元素
5. 具有boolean值的属性
6. 省略行内属性赋值的引号

## 1. 新增元素
### 结构元素
#### section
对网站内容分块、分段
当容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section

结构(标题+内容)
``` html
<section>
	<h1></h1>
	<p></p>
</section>
```
#### article
代表文档内容 独立性 可嵌套使用
可看作特殊的section元素

常见结构
``` html
<article>
	<header>
		<h1></h1>
	</header>
	<article>
		<header>
			<h2></h2>
		</header>
		<p></p>
		<footer></footer>
	</article>
	<footer></footer>
</article>
```

#### aside
用来表示当前页面或文章的附属信息(相关引用、侧边栏、广告、导航条)

常见结构
``` html
<header>
	<h1></h1>
</header>
<article>
	<h1></h1>
	<p></p>
	<aside>
		<h1></h1>
		<p></p>
	</aside>
</article>
<aside>
	<nav>
		<h2>评论</h2>
		<ul>
			<li><a href="javascipt:;"></a></li>
			<li><a href="javascipt:;"></a></li>
		</ul>
	</nav>
</aside>
```

#### nav
常见应用：导航条、侧边栏导航、页内导航、翻页操作
**不能用menu元素代替nav元素**

常见结构
``` html
<nav>
	<ul>
		<li><a href="javascript:;"></a></li>
		<li><a href="javascript:;"></a></li>
	</ul>
</nav>

<article>
	<header>
		<nav>
			<ul>
				<li><a href="javascript"></a></li>
				<li><a href="javascript"></a></li>
			</ul>
		</nav>
	</header>
	<section>
		<h1></h1>
		<p></p>
	</section>
	<section>
		<h1></h1>
		<p></p>
	</section>
	<footer>
		<a href="javascript:;"></a>
		<a href="javascript:;"></a>
	</footer>
</article>
```

#### figure
#### time
用来区分各时区或编码

常见结构
``` html
	<time datetime="2017-1-1">2017-1-1</time>
	<time datetime="2017-1-1T20:00">2017-1-1</time>
```

#### pubdate
指明发布时间

常见结构
``` html
	<article>
		<header>
			<h1></h1>
			<p>
				<time datetime="2017-1-1" pubdate>2017-1-1</time>
			</p>
		</header>
	</article>
```
#### header
header可出现多次

常见结构
``` html
<header>
	<h1></h1>
	<nav>
		<ul>
			<li><a href=""></a></li>
			<li><a href=""></a></li>
			<li><a href=""></a></li>
		</ul>
	</nav>
</header>
<article>
	<header>
		<h1></h1>
	</header>
</article>
```

#### footer
footer可出现多次
常见应用：脚注(相关链接、版权信息)

常见结构
``` html
<footer>
	<ul>
		<li><a href="">版权信息</a></li>
		<li><a href="">联系我们</a></li>
		<li><a href="">加入我们</a></li>
	</ul>
</footer>
```
#### hgroup
将标题及其子标题进行分组

常见结构
``` html
<article>
	<header>
		<hgroup>
			<h1>主标题</h1>
			<h2>子标题</h2>
		</hgroup>
		<p>
			<time datetime="2017-1-1">2017-1-1</time>
		</p>
	</header>
	<div></div>
	<footer>
	</footer>
</article>
```

#### address
在文档中呈现联系信息(作者名字、网站连接、电子邮箱、地址、手机号)

常见结构
``` html
<address>
	<a href=""></a>
	<a href=""></a>
</address>
<footer>
	<div>
		<address>
			<a href=""></a>
		</address>
		<time datetime="2017-1-1">2017-1-1</time>
	</div>
</footer>
```

#### 整体应用
``` html
<header>
	<h1>xxx</h1>
	<nav>
		<ul>
			<li><a href="#">a1</a></li>
			<li><a href="#">a2</a></li>
		</ul>
	</nav>
</header>
<article>
	<hgroup>
		<h1>主标题</h1>
		<h2>子标题</h2>
	</hgroup>
	<p>正文</p>
	<section>
		<div>
			<article>
				<h1>评论标题</h1>
				<p>评论正文</p>
			</article>
		</div>
	</section>
</article>
<footer>
	<small>版权***</small>
</footer>

```

### 其他元素
#### video
不同浏览器支持的格式不同，可能需要转码，在source标签里引入多种格式

FF不支持mp4，支持ogg

controls属性显示自带控制进度条

常见结构
``` html
<html>
	<video src="xxx.mp4" controls></video>
	<hr>
	<video  controls>
		<source src="xxx.mp4">
		<source src="xxx.ogg">
	</video>
	<hr>
	<video src="xxx.mp4" id="v1" width="400px" height="200px"></video>
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var v1 = document.getElementById('v1');
	function play() {
		if(v1.paused) {
			v1.play();
		} else {
			v1.pause();
		}
	}
</script>
```

#### audio
controls属性显示自带控制进度条

常见结构
``` html
<html>
	<audio src="xxx.mp3" controls></audio>  <!-- 显示音频自带播放器样式 -->
	<hr>
	<audio src="xxx.mp3" id="a1"></audio>  <!-- 只显示下面的按钮 -->
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var a1 = document.getElementById('a1');
	function play() {
		if(a1.paused) {
			a1.play();
		} else {
			a1.pause();
		}
	}
</script>
```

#### canvas

...


### input元素类型
email
url
number
range

date
time

Date Pickers

### *废除的元素
能用CSS替代的元素：basefont、big、center、font、s、tt、u等
frame框架
只有部分浏览器支持的元素

## 2. 新增属性
### 表单相关属性
####form
form的元素可写在form外，只要指向相同id

常见结构
``` html
<form id="form1">
	<input type="text">
</form>
<textarea form="form1"></textarea>
```
#### formaction
不同表单元素不同action路径

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formaction="fc1">
	<input type="submit" name="s2" value="v2" formaction="fc2">
	<input type="submit" name="s3" value="v3" formaction="fc3">
</form>
```

#### formmethod
不同表单元素不同提交方法

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formmethod="get" formaction="fc1">
	<input type="submit" name="s2" value="v2" formmethod="post" formaction="fc2">
</form>
```
#### formmethod
不同表单元素不同编码方式

常见结构
``` html
<form id="form1">
	<input type="text" formenctype="text/plain" value="表单数据中的空格转换为加号">
	<input type="text" formenctype="multipart/form-data" value="文件上传">
	<input type="text" formenctype="application/x-www-form-urlencoded" value="get方式时把表单数据转换为字符">
</form>
<textarea form="form1"></textarea>
```

#### formtarget
不同表单元素不同提交后在何处打开加载页面

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formtarget="_blank" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_self" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_parent" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_top" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="framename" formaction="fc1">
</form>
```

#### autofocus
表单元素自动获得焦点

常见结构
``` html
<form id="form1">
	<input type="text" autofocus>
	<input type="text">
</form>
```

#### require
提交时内容为空不允许提交，并显示提示

常见结构
``` html
<form id="form1">
	<input type="text" required>
	<input type="text">
	<input type="submit">
</form>
```
#### labels
验证提示信息

常见结构
``` html
<form id="form1">
	<label for="t1" id="l1"></label>
	<input type="text" id="t1">
	<input type="button" id="btn1" value="验证" onclick="validate()">
</form>
```

``` javascript
<script>
	function validate() {
		var t1 = document.getElementById('t1');
		var btn1 = document.getElementById('btn1');
		var fm1 = document.getElementById('form1');

		if(t1.value.trim() == "") {
			var l1 = document.getElementById('l1');
			l1.setAttribute('for', 't1');
			f1.insertBefore(l1, btn1);	// 在button前显示验证提示信息
			t1.labels[1].innerHTML = '输入为空';
		}
	}
</script>
```

#### placeholder
输入提示信息

常见结构
``` html
<form id="form1">
	<input type="text" placeholder="请输入...">
</form>
```

#### datalist
可输入的下拉框

常见结构
``` html
<form id="form1">
	<input type="text" name="n1" list="ns">  <!-- 点击下拉箭头时显示datalist -->
	<datalist id="ns" style="display: none">
		<option value="v1">v1</option>
		<option value="v2">v2</option>
	</datalist>
</form>
```
#### autocomplete
输入自动填充

#### pattern
表单元素正则验证，输入错误时不跳转

常见结构
``` html
<form id="form1" action="xxx">
	<input type="text" pattern="{a-z}[3]" >
	<input type="submit">
</form>
```

#### selectionDirection
*Chrome不支持

#### indeterminate
复选框checkbox 的第三种状态 “尚未明确是否选取”状态

#### image按钮的width/height

### 链接相关属性
### 其他属性
### *废除属性

### 全局属性
contentEditable
designMode
hidden
spellcheck       拼写检查
tabindex         设置tab键焦点的顺序


##1.12

### css3应用

####拖拽

``` javascript
<script>
	var oBox = document.querySelector('div');

	oBox.onmousedown = function({
		clientX,
		clientY
	}) {
		var disX = clientX - (oBox.dataset.left || 0);
		var disY = clientY - (oBox.dataset.top || 0);

		console.log(oBox.offsetLeft, oBox.offsetTop);

		document.onmousemove = function({
			clientX,
			clientY
		}) {
			var deltaX = clientX - disX;
			var deltaY = clientY - disY;

			oBox.dataset.left = deltaX;
			oBox.dataset.top = deltaY;

			oBox.style.transform = `translate(${
				deltaX
			}px,${
				deltaY
			}px)`
		}

		document.onmouseup = function() {
			document.onmousemove = null;
			document.onmouseup = null;
		}
	}
</script>
``

##### ES6模板字符串 ``

[深入浅出ES6（四）：模板字符串](http://www.infoq.com/cn/articles/es6-in-depth-template-string)

``` javascript
<script>
	var x = 'a', y = 'b';
	var z = `${x,y}`;	 //'b'
</script>
```

#### 无缝滚动
假设共有9涨不重复图片
每次显示5张

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	.container {
		width: 500px;
		height: 100px;
		border: 1px solid #000;
		overflow: hidden;
	}
	ul {
		height: 100px;
		width: 1400px;
		animation: ani 6s infinite linear;
	}
	ul:hover {
		animation-play-state: paused;
	}
	li {
		list-style: none;
		width: 100px;
		height: 100px;
		float: left;
		background-size: cover;
		text-align: center;
		line-height: 100px;
	}
	@keyframes ani {
		to {
			transform: translate(-900px);
		}
	}
</style>
```

``` html
<div class="container">
	<ul>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<!-- 无缝 -->
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
	</ul>
</div>
```

``` javascript
<script>
	var aLi = document.querySelectorAll('li');

	aLi.forEach(function(oLi, index) {
		oLi.style.backgroundImage = `img/img${(index%9)+1}.jpg)`;

	})
</script>
```

#### 点赞

``` css
<style>
	#box {
		width: 20px;
		height: 20px;
		font-size: 20px;
		line-height: 20px;
		margin: 200px auto;
		position: relative;
		cursor: pointer;
		color: grey;
	}
	#box.active {
		color: red;
	}
	#box.active:after {
		content: "❤";
		width: 30px;
		height: 30px;
		font-size: 30px;
		line-height: 30px;
		position: absolute;
		left: -5px;
		top: -20px;
		color: red;
		animation: ani 2s forwards;
	}
	@keyframes ani {
		to {
			top: -100px;
			opacity: 0;
		}
	}
</style>
```

``` html
<div id="box">❤</div>
```

``` javascript
<script>
	var oBox = document.querySelector('div');

	oBox.onclick = function() {
		oBox.classList.toggle('active');
	}
</script>
```

高能版动画
``` css
<style>
	@keyframes ani {
		25% {
			transform: translate(0, -25px) rotate(20deg) scale(1.125);
			opacity: 0.75;
		}
		50% {
			transform: translate(0, -50px) rotate(-15deg) scale(1.25);
			opacity: 0.5;
		}
		75% {
			transform: translate(0, -75px) rotate(25deg) scale(1.375);
			opacity: 0.25;
		}
		100% {
			transform: translate(0, -100px) rotate(-10deg) scale(1.5);
			opacity: 0;
		}
	}
</style>
```

#### 动态时钟
``` css
<style>
	.container{
		width: 300px;
		height: 300px;
		border:  2px solid black;
		border-radius: 50%;
		margin: 20px auto;
		position: relative;
	}

	.hour{
		width: 10px;
		height: 50px;
		background-color: green;
		position: absolute;
		left: 145px;
		top: 100px;
		transform-origin: center bottom;
	}

	.minute{
		width: 8px;
		height: 80px;
		background-color: pink;
		position: absolute;
		left: 146px;
		top: 70px;
		transform-origin: center bottom;
	}

	.second{
		width: 4px;
		height: 100px;
		background-color: red;
		position: absolute;
		left: 148px;
		top: 50px;
		transform-origin: center bottom;
	}

	.cap{
		width: 20px;
		height: 20px;
		background: radial-gradient(white,silver);
		left: 140px;
		top: 140px;
		position: absolute;
		border-radius: 50%;
	}

	.mark{
		width: 4px;
		height: 10px;
		background-color: black;
		position: absolute;
		top: 0;
		left: 148px;
		transform-origin: 2px 150px;
	}

	.inner-block{
		width: 20px;
		height: 20px;
		text-align: center;
		position: absolute;
		left: -8px;
		top: 12px;
		line-height: 20px;
	}
</style>
```

``` html
<div class="container">
	<div class="hour"></div>
	<div class="minute"></div>
	<div class="second"></div>
	<div class="cap"></div>
</div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');
	var oHour = document.querySelector('.hour');
	var oMinute = document.querySelector('.minute');
	var oSecond = document.querySelector('.second');

	var count = 12;

	for (var i = 0; i < count; i++) {
		var oDiv = document.createElement('div');
		oDiv.classList.add('mark');
		oDiv.style.transform = `rotate(${i*360/count}deg)`

		var innerBlock = document.createElement('div');
		innerBlock.classList.add('inner-block');

		innerBlock.innerHTML = i;

		innerBlock.style.transform = `rotate(${-i*360/count}deg)`

		if (i == 0) {
			innerBlock.innerHTML = 12;
		}

		oDiv.appendChild(innerBlock);
		oContainer.appendChild(oDiv);
	}

	setInterval(function() {
		var oDate = new Date();

		var hour = oDate.getHours();
		var minute = oDate.getMinutes();
		var second = oDate.getSeconds();
		var millisecond = oDate.getMilliseconds();

		oHour.style.transform = `rotate(${
			(hour+minute/60)*360/12
		}deg)`

		oMinute.style.transform = `rotate(${
			(minute+second/60)/60*360
		}deg)`

		oSecond.style.transform = `rotate(${
			(second+millisecond/1000)/60*360
		}deg)`
	}, 1000)
</script>
```


#### 修改之前的分块运动

##### 之前的分块运动

1. 自定义行数R、列数C
2. 创建span
  计算oSpan的width、height、left、top、background-position

注意：先appendChild才能获取oSpan的offsetWidth和offsetHeight

``` javascript
<script>
	for(var r = 0; r < R; r++) {
		for(var c = 0; c < C; c++) {
			var oSpan = document.createElement('span');
			oSpan.style.width = oBox.offsetWidth / C + 'px';
			oSpan.style.height = oBox.offsetHeight / R + 'px';
			oBox.appendChild(oSpan);
			oSpan.style.left = oSpan.offsetWidth * c + 'px';
			oSpan.style.top = oSpan.offsetHeight * r + 'px';
			oSpan.style.backgroundPosition = - oSpan.offsetWidth * c + 'px ' + (-oSpan.offsetHeight * r) + 'px';
			oSpan.r = r;
			oSpan.c = c;
		}
	}
</script>
```

3. 分布运动，依次显示span

##### 修改后的分块运动

backface-visibility

[使用CSS3 BACKFACE-VISIBILITY属性制作翻转动画效果](http://www.html5cn.org/article-7978-1.html)

**假设分块运动的图片资源为3张，分别为0.jpg，1.jpg，2.jpg*

``` css
<style>
	.container{
		width: 700px;
		height: 400px;
		margin: 40px auto;
		perspective: 800px;
		transform-style: preserve-3d;
	}

	.wrapper{
		width: 100px;
		height: 100px;
		float: left;
		position: relative;
		transform-style: preserve-3d;
	}

	.front,.back{
		width: 100px;
		height: 100px;
		position: absolute;
		left: 0;
		top: 0;
	}

	.front{
		z-index: 999;
		backface-visibility: hidden;  /* 3d空间内生效 */
	}

	.back{
		z-index: 9;
		transform: scale(-1,1);  /* 水平翻转 */
	}
</style>
```

``` html
	<div class="container"></div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');

	var rows = 4;  // 自定义分块行数
	var cols = 7;  // 自定义分块列数

	var currentIndex = 0;	// 当前图片序号

	// 行列循环 -> 分块放置前后图片
	for (var row = 0; row < rows; row++) {
		for (var col = 0; col < cols; col++) {
			var oDiv = document.createElement('div');
			oDiv.classList.add('wrapper');

			// 前置图片
			var oFront = document.createElement('div');
			oFront.classList.add('front');

			oFront.style.backgroundImage = `url(img/${currentIndex}.jpg)`;

			// 按行列数移动背景图片摆放位置

			oFront.style.backgroundPosition = `${-col*100}px ${-row*100}px`

			// 后置图片
			var oBack = document.createElement('div');
			oBack.classList.add('back');

			oBack.style.backgroundImage = `url(img/${currentIndex+1}.jpg)`;

			oBack.style.backgroundPosition = `${-col*100}px ${-row*100}px`

			oDiv.dataset.col = col;
			oDiv.dataset.row = row;

			oDiv.appendChild(oFront);
			oDiv.appendChild(oBack);

			oContainer.appendChild(oDiv);
		}
	}

	var aWrapper = document.querySelectorAll('.wrapper');

	// 监听最后一个分块是否运动完毕
	// 运动完毕则将原后置图更至前置，后置图序列加1
	aWrapper[aWrapper.length - 1].addEventListener('transitionend', function() {

		currentIndex++;

		aWrapper.forEach(function(oWrapper) {

			// 防止后置更至前置时有动画
			oWrapper.style.transition = '0s';
			oWrapper.style.transform = '';

			// 原后置图更至前置
			oWrapper.children[0].style.backgroundImage = `url(img/${currentIndex%3}.jpg)`
			// 现后置图更换
			oWrapper.children[1].style.backgroundImage = `url(img/${(currentIndex+1)%3}.jpg)`
		})
	}, false)

	window.onclick = function() {
		aWrapper.forEach(function(oWrapper) {
			var row = oWrapper.dataset.row;
			var col = oWrapper.dataset.col;

			// dataset为字符串，先解析为Number数据类型再进行运算
			oWrapper.style.transition = `1s ${0.3*(Number(row)+Number(col))}s`;  // 控制各分块旋转延迟时间
			oWrapper.style.transform = `rotateY(180deg)`;
		})
	}
</script>
```

#### 爆炸轮播

**假设爆炸运动的图片资源为3张，分别为0.jpg，1.jpg，2.jpg*

``` css
<style>
	.container{
		width: 700px;
		height: 400px;
		margin: 40px auto;
		perspective: 800px;
		transform-style: preserve-3d;
	}

	.wrapper{
		width: 100px;
		height: 100px;
		/* background: green; */
		float: left;
	}
</style>
```

``` html
	<div class="container"></div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');

	var rows = 4; // 自定义分块行数
	var cols = 7; // 自定义分块列数

	var currentIndex = 0; // 当前图片序号

	var bReady = true; // 是否运动完成

	// 爆炸时显示的背景图
	oContainer.style.backgroundImage = `url(img/${currenIndex+1}.jpg)`;

	// 爆炸分块图
	for (var row = 0; row < rows; row++) {
		for (var col = 0; col < cols; col++) {
			var oDiv = document.createElement('div');
			oDiv.classList.add('wrapper');

			oDiv.style.backgroundImage = `url(img/${currenIndex}.jpg)`;
			oDiv.style.backgroundPosition = `${-col*100}px ${-100*row}px`

			oContainer.appendChild(oDiv);
		}
	}

	var aWrapper = document.querySelectorAll('.wrapper');

	window.onclick = function() {
		if (!bReady) return;

		bReady = false;

		aWrapper.forEach(function(oWrapper) {
			oWrapper.style.transition = `.6s ${rnd(0,300)}ms`;  // 运动时间600ms, 爆炸随机延迟0~300ms
			oWrapper.style.transform = `translateZ(600px) rotateX(${rnd(100,300)}deg) rotateY(${rnd(100,300)}deg)`;  // 爆炸效果
			oWrapper.style.opacity = '0';
		})

		// 900ms后运动完成，将原背景图更至爆炸图，背景图更换
		setTimeout(function() {
			currenIndex++;

			aWrapper.forEach(function(oWrapper) {
				oWrapper.style.transition = '0s';
				oWrapper.style.transform = '';
				oWrapper.style.opacity = '1';
				oWrapper.style.backgroundImage = `url(img/${currenIndex%3}.jpg)`;
			})

			oContainer.style.backgroundImage = `url(img/${(currenIndex+1)%3}.jpg)`;

			bReady = true;	// 更换完成
		}, 900)
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}
</script>
```

#### 立方体
``` css
<style>
	body{
		perspective: 800px;
		transform-style: preserve-3d;
		user-select: none;  /* 文本不能被选择 */
	}

	.container{
		width: 200px;
		height: 200px;
		margin: 200px auto;
		position: relative;
		/*transition: 2s;*/
		transform-style: preserve-3d;
	}

	.container > div{
		width: 200px;
		height: 200px;
		text-align: center;
		line-height: 200px;
		font-size: 40px;
		color: white;
		font-weight: bolder;
		position: absolute;
	}

	.container > div:nth-child(1){
		transform: translateZ(100px);  /* 距中心点往前伸一半的宽度 */
	}

	.container > div:nth-child(2){
		transform: rotateY(180deg) translateZ(100px);
	}

	.container > div:nth-child(3){
		transform: rotateY(90deg) translateZ(100px);
	}

	.container > div:nth-child(4){
		transform: rotateY(-90deg) translateZ(100px);
	}

	.container > div:nth-child(5){
		transform: rotateX(90deg) translateZ(100px);
	}

	.container > div:nth-child(6){
		transform: rotateX(-90deg) translateZ(100px);
	}

	.container:active{
		transform: rotateY(180deg) rotateX(180deg);
	}
</style>
```

``` html
	<div class="container">
		<div>1</div>
		<div>2</div>
		<div>3</div>
		<div>4</div>
		<div>5</div>
		<div>6</div>
	</div>
```

``` javascript
<script>
	var aDiv = document.querySelectorAll('.container > div');
	var oContainer = document.querySelector('.container');

	var transformX = 0;
	var transformY = 0;

	aDiv.forEach(function(oDiv) {
		oDiv.style.background = `rgba(${rnd(0,255)},${rnd(0,255)},${rnd(0,255)},0.3)`
	})

	document.onmousedown = function({
		clientX,
		clientY
	}) {
		var disX = clientX - transformX;
		var disY = clientY - transformY;

		document.onmousemove = function({
			clientX,
			clientY
		}) {
			var deltaX = clientX - disX;
			var deltaY = clientY - disY;

			transformX = deltaX;
			transformY = deltaY;

			oContainer.style.transform = `rotateY(${transformX}deg) rotateX(${-transformY}deg)`;	// 旋转
		}

		document.onmouseup = function() {
			document.onmousemove = null;
			document.onmouseup = null;
		}
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}
</script>
```

#### 翻页效果

**假设分块运动的图片资源为3张，分别为0.jpg，1.jpg，2.jpg*

``` css
<style>
	.container{
		width: 700px;
		height: 400px;
		margin: 40px auto;
		position: relative;
		perspective: 800px;
		transform-style: preserve-3d;
	}

	.left,.right{
		width: 350px;
		height: 400px;
		position: absolute;
		top: 0;
	}

	.left{
		left: 0;
		z-index: 99;
	}

	.right{
		right: 0;
		z-index: 99;
	}

	.card{
		width: 350px;
		height: 400px;
		position: absolute;
		right: 0;
		top: 0;
		z-index: 999;
		transform-origin: left center;  /* 旋转中心 */
		transform-style: preserve-3d;
	}

	.front,.back{
		width: 100%;
		height: 100%;
		position: absolute;
		top: 0;
		left: 0;
	}

	.front{
		z-index: 999;
		backface-visibility: hidden;
	}

	.back{
		z-index: 9;
		transform: scale(-1,1);
	}
</style>
```

``` html
	<div class="container">
		<!-- 前置左边 -->
		<div class="left"></div>
		<!-- 翻页卡 -->
		<div class="card">
			<!-- 前置右边 -->
			<div class="front"></div>
			<!-- 后置左边 -->
			<div class="back"></div>
		</div>
		<!-- 后置右边 -->
		<div class="right"></div>
	</div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');
	var oCard = document.querySelector('.card');
	var oFront = document.querySelector('.front');
	var oBack = document.querySelector('.back');
	var oRight = document.querySelector('.right');
	var oLeft = document.querySelector('.left');

	var currentIndex = 0;

	// 前置左边
	oLeft.style.backgroundImage = `url(img/${currentIndex}.jpg)`;

	// 后置右边
	oRight.style.backgroundImage = `url(img/${currentIndex+1}.jpg)`;
	oRight.style.backgroundPosition = `-350px 0px`;

	// 前置右边
	oFront.style.backgroundImage = `url(img/${currentIndex}.jpg)`;
	oFront.style.backgroundPosition = `-350px 0px`;

	// 后置左边
	oBack.style.backgroundImage = `url(img/${currentIndex+1}.jpg)`;

	// 翻页运动完毕则将原后置图更至前置，后置图序列加1
	oCard.addEventListener('transitionend', function() {

		currentIndex++;

		// 防止后置更至前置时有动画
		oCard.style.transition = "0s";
		oCard.style.transform = "";

		// 原后置图更至前置
		oLeft.style.backgroundImage = `url(img/${currentIndex%3}.jpg)`;

		// 现后置图更换
		oRight.style.backgroundImage = `url(img/${(currentIndex+1)%3}.jpg)`;

		// 原后置图更至前置
		oFront.style.backgroundImage = `url(img/${currentIndex%3}.jpg)`;

		// 现后置图更换
		oBack.style.backgroundImage = `url(img/${(currentIndex+1)%3}.jpg)`;


	}, false)

	window.onclick = function() {
		oCard.style.transition = `1s`;
		oCard.style.transform = `rotateY(-180deg)`;
	}
</script>
```

#### 3D图片环

**假设分块运动的图片资源为10张，分别为1.jpg，2.jpg，3.jpg，4.jpg，5.jpg，6.jpg，7.jpg，8.jpg，9.jpg，10.jpg*

``` css
<style>
	body{
		background-color: black;
		transform-style: preserve-3d;
		perspective: 2000px;
	}

	.container{
		width: 100px;
		height: 150px;
		margin: 200px auto;
		position: relative;
		transform-style: preserve-3d;
		transform: rotateX(-10deg);
	}

	.card{
		width: 100px;
		height: 150px;
		background-size: cover;
		position: absolute;
		left: 0;
		top: 0;
		border-radius: 10px;
		box-shadow: 0 0 10px grey;
		/*-webkit-box-reflect:below 20px linear-gradient(rgba(0,0,0,0),red);*/
	}

	.shadow{
		width: 100px;
		height: 150px;
		position: absolute;
		left: 0;
		bottom:-170px;
		border-radius: 10px;
		transform: scale(1,-1);
		-webkit-mask:linear-gradient(rgba(0,0,0,0) 60%,rgba(0,0,0,0.7));
	}
</style>
```

``` html
	<div class="container"></div>
```

``` javascript
<script>
	var oContainer = document.querySelector('.container');

	var amount = 10;

	// 拖拽变化值
	var rotateXDegree = 0;
	var rotateYDegree = 10;

	// 实时计算速度值
	var speedX = 0;
	var speedY = 0;

	// 用于计算速度值的上次值
	var lastX = 0;
	var lastY = 0;

	var timer = null;

	// 设置图片环
	for (var i = 0; i < amount; i++) {
		var oDiv = document.createElement('div');
		oDiv.classList.add('card');
		oDiv.style.backgroundImage = `url(statics/img/${i+1}.jpg)`;
		oDiv.style.transition = `0.8s ${(amount-i)*0.3}s`;

		// 设置倒影
		var oShadow = document.createElement('div');
		oShadow.classList.add('shadow');
		oShadow.style.backgroundImage = `url(statics/img/${i+1}.jpg)`;

		(function(ele, index) {
			setTimeout(function() {
				ele.style.transform = `rotateY(${index*360/amount}deg) translateZ(300px)`

			})
		})(oDiv, i)

		oDiv.appendChild(oShadow);
		oContainer.appendChild(oDiv);
	}

	var aCard = document.querySelectorAll('.card');

	aCard.forEach(function(oCard) {
		oCard.onmousedown = function(ev) {
			ev.preventDefault();
		}
	})

	// 监听最后一个图片是否运动完毕
	aCard[0].addEventListener('transitionend', function() {

		aCard.forEach(function(oCard, index) {

			// 防止delay值影响
			oCard.style.transition = '0.7s';

			/*
			 * 1. 角度 - 180
			 * 2. 角度取绝对值
			 * 3. 角度/180 得出透明度
			 */
			oCard.style.opacity = Math.abs(index * 36 - 180) / 180 + 0.4;
		})
	}, false)

	document.onmousedown = function({
		clientX,
		clientY
	}) {

		// 防止拖拽时有阻滞感
		clearTransition()

		// 防止多个定时器改变位置
		clearInterval(timer);

		var disX = clientX - rotateXDegree * 4;
		var disY = clientY - rotateYDegree * 4;

		document.onmousemove = function({
			clientX,
			clientY
		}) {
			var deltaX = clientX - disX;
			var deltaY = clientY - disY;

			rotateXDegree = deltaX * 0.25;
			rotateYDegree = deltaY * 0.25;

			setPosition()

			// 计算速度
			speedX = rotateXDegree - lastX;
			speedY = rotateYDegree - lastY;

			lastX = rotateXDegree;
			lastY = rotateYDegree;
		}

		document.onmouseup = function() {
			document.onmousemove = null;
			document.onmouseup = null;

			timer = setInterval(function() {
				rotateXDegree += speedX;
				rotateYDegree += speedY;

				// 衰减
				speedX *= 0.95;
				speedY *= 0.95;

				setPosition();
			}, 16);
		}
	}

	function setPosition() {
		aCard.forEach(function(oCard, index) {
			oCard.style.transform = `rotateY(${index*360/amount + rotateXDegree }deg) translateZ(300px)`

			/*
			 * 1. 角度(大于360时模360,小于0时取绝对值) - 180
			 * 2. 角度取绝对值
			 * 3. 角度/180 得出透明度
			 */

			oCard.style.opacity = Math.abs(Math.abs((index * 36 + rotateXDegree)) % 360 - 180) / 180 + 0.4;
		})

		// Y轴旋转
		oContainer.style.transform = `rotateX(${-rotateYDegree}deg)`;
	}

	function clearTransition() {
		aCard.forEach(function(oCard) {
			oCard.style.transition = '0s';
		})
	}
</script>
```

## 1.16

### H5地理位置 geolocation

LBS -> Location Based Service 基于位置服务

#### 测试用例

``` javascript
<script>
	window.navigator.geolocation.getCurrentPosition(function(res) {
		console.log(res);
	}, function(err) {
		console.log(err);
	})
</script>
```

##### PositionError
错误码 错误信息

code: 1
message: "User denied Geolocation" -> 用户拒绝授权

code: 1
message: "Only secure origins are allowed (see: https://goo.gl/Y0ZkNV). -> 仅允许HTTPS访问

code:2
message:"Network location provider at 'https://www.googleapis.com/' : No response received." -> 没翻墙

#### 百度地图API
timestamp 时间戳

coords -> 地理坐标
	accuracy:26 -> 精确度
	altitude:null -> 海拔
	altitudeAccuracy:null -> 海拔高度精确度
	heading:null -> 方向
	latitude:31.167638 -> 纬度
	longitude:121.423593 -> 经度
	speed:null -> 速度

```
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
	<style type="text/css">
		body, html,#allmap {
			user-select: none;
			width: 100%;
			height: 100%;
			overflow: hidden;
			margin: 0;
			font-family: "微软雅黑";
		}
	</style>
	<script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=wmwHFMPxi66GlPBVUrdgEhDzbLUqlSrM"></script>
	<title>上海师范大学 - 百度地图</title>
</head>
<body>
	<div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
	var map = new BMap.Map("allmap");

	map.centerAndZoom(new BMap.Point(121.423593, 31.167638), 20); // 初始化地图,设置中心点坐标和地图级别

	map.addControl(new BMap.MapTypeControl()); //添加地图类型控件
	map.setCurrentCity("上海"); // 设置地图显示的城市 此项是必须设置的
	map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放

	navigator.geolocation.getCurrentPosition(function(res) {
		var {
			coords: {
				longitude,
				latitude
			}
		} = res;

		var point = new BMap.Point(longitude, latitude);

		var marker = new BMap.Marker(point);
		map.addOverlay(marker);

		marker.setAnimation(BMAP_ANIMATION_BOUNCE)

		map.panTo(point)
	}, function(err) {
		console.log(err);
	})
</script>
```

### H5 audio

音频格式：mp3 wma flat ape wav ogg
#### 属性
src -> 音频路径
controls -> 显示自带控制进度条
loop -> 音频循环
autoplay -> 自动播放 只有pc端可以实现
muted -> 静音

currentTime -> 当前播放时间
duration -> 音频总时间
volume -> 音量 [0,1]

ontimeupdate -> 进度更新

play -> 是否在播放 返回true/false
pause -> 是否暂停 返回true/false

#### 方法
play() -> 播放歌曲
pause() -> 暂停歌曲
load() -> 重新加载歌曲
onended() -> 音频播放完毕

常见结构
``` html
<html>
	<audio src="xxx.mp3" controls></audio>  <!-- 显示音频自带播放器样式 -->
	<hr>
	<!-- 自定义播放器 -->
	<audio src="xxx.mp3" id="a1"></audio>  <!-- 只显示下面的按钮 -->
	<!-- 进度条 -->
	<div class="progress">
		<div class="inner"></div>
	</div>
	<input type="range" min="0" max="100" value="100">音量
	<button onclick="aPlay()">播放/暂停</button>
	<button onclick="aMute()">静音</button>
</html>
```

``` javascript
<script>
	var a1 = document.getElementById('a1');
	var progress = document.querySelector('.progress');
	var oInner = document.querySelector('.inner');
	var oRange = document.querySelector('[type=range]');

	// 自定义进度条
	// setInterval(function() {
	// 	oInner.style.width = (a1.currentTime / a1.duration) * 100 + '%';
	// }, 16);

	a1.ontimeupdate = function(){
		oInner.style.width = (a1.currentTime / a1.duration) * 100 + '%';
	}

	progress.onclick = function({
		clientX
	}) {
		var leftDelta = clientX - this.offsetLeft;

		var percentage = leftDelta / this.offsetWidth;

		a1.currentTime = a1.duration * percentage;
	}

	oRange.oninput = function(){
		a1.volume = this.value/100;
	}

	function aPlay() {
		if (a1.paused) {
			a1.play();
		} else {
			a1.pause();
		}
	}

	function aMute() {
		a1.muted = !oA.muted;
	}

</script>
```

#### 应用：钢琴弹奏

**sound.js**

钢琴示例

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>钢琴示例</title>
	<style>
		body {
			user-select: none;
		}
		ul, li {
			list-style: none;
			margin: 0;
			padding: 0;
		}
		ul {
			width: 400px;
			margin: 40px auto;
		}
		li {
			width: 38px;
			border: 1px solid black;
			height: 198px;
			float: left;
			text-align: center;
			line-height: 350px;
			margin-left: 10px;
			transform-origin: top center;
		}
		li:active {
			transform: perspective(800px) rotateX(-10deg);
		}
		li.active {
			transform: perspective(800px) rotateX(-10deg);
		}
	</style>
</head>
<body>
	<ul>
		<li>1</li>
		<li>2</li>
		<li>3</li>
		<li>4</li>
		<li>5</li>
		<li>6</li>
		<li>7</li>
		<li>8</li>
	</ul>
	<script src="statics/sound.js"></script>
	<script>
		var aLi = document.querySelectorAll('li');

		aLi.forEach(function(oLi, index) {
			oLi.onmousedown = function() {
				playSound(index + 49);
			}
		})

		window.onkeydown = function({
			keyCode
		}) {
			playSound(keyCode);

			aLi[keyCode - 49].classList.add('active');
		}

		window.onkeyup = function({
			keyCode
		}) {
			if (keyCode >= 49 && keyCode <= 56) {
				aLi[keyCode - 49].classList.remove('active');
			}
		}

		function playSound(index) {
			new Audio(oggSound[`sound${index}`]).play();
		}
	</script>
</body>
</html>
```

#### 应用：音乐播放器

##### 歌词显示

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		#box {
			width: 200px;
			margin: 40px auto;
			text-align: center;
			padding: 10px;
			border: 2px solid black;
			-webkit-background-clip: text;
			background-image: linear-gradient(90deg, red 30%, blue 30%);
			color: transparent;
		}
	</style>
</head>
<body>
	<div id="box">
		西湖的水我的泪
	</div>
	<script>
		var progress = 0;
		var oBox = document.querySelector('div');

		setInterval(function() {
			oBox.style.backgroundImage = `linear-gradient(90deg,red ${progress}%,blue ${progress}%)`

			progress += 0.4;
		}, 16)
	</script>
</body>
</html>
```

### H5 video
不同浏览器支持的格式不同，可能需要转码，在source标签里引入多种格式

FF不支持mp4，支持ogg

视频格式：
#### 属性
src -> 视频路径
controls -> 显示自带控制进度条
loop -> 视频循环
autoplay -> 自动播放
muted -> 静音

currentTime -> 当前播放时间
duration -> 视频总时间
volume -> 音量 [0,1]

ontimeupdate -> 进度更新

play -> 是否在播放 返回true/false
pause -> 是否暂停 返回true/false

#### 方法
play() -> 播放视频
pause() -> 暂停视频
load() -> 重新加载视频
onended() -> 视频播放完毕

常见结构
``` html
<html>
	<video src="xxx.mp4" controls></video>
	<hr>
	<video  controls>
		<source src="xxx.mp4">
		<source src="xxx.ogg">
	</video>
	<hr>
	<video src="xxx.mp4" id="v1" width="400px" height="200px"></video>
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var v1 = document.getElementById('v1');
	function play() {
		if(v1.paused) {
			v1.play();
		} else {
			v1.pause();
		}
	}
</script>
```

## 1.17

### H5 FileReader

#### 文件拖拽
ondragover -> 只要悬浮，一直触发
ondragenter -> 进入时触发，有子节点时有问题
ondragleave -> 离开时触发，有子节点时有问题
ondrop -> 释放鼠标时触发，对应DOM节点的dragover事件必须取消默认事件

#### File接口
`var reader = new FileReader();`  新建文件读取对象

方法
.readAsText(file) -> 读取文本文件
.readAsDataURL(file) -> 读取多媒体

.onload -> 资源读取完毕  reader.result
.onprogress -> 读取进度更新时触发
`<progress max="100"></progress>`
```
<script>
	reader.onprogress = function(ev){
		oProgress.value = ev.loaded/ev.total*100;
	}
</script>
```

.onloadstart -> 加载开始时触发
.onloadend -> 加载结束时触发
.onerror -> 出现错误时触发
.onabort -> 加载过程中中止时触发

.abort -> 手动中止加载


**示例**

文本
``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		reader.readAsText(file);	// 读取文本文件

		reader.onload = function(ev) {
			console.log(reader.result);
		}

		ev.preventDefault();
	}
</script>
```

多媒体
``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		reader.readAsDataURL(file);		// 读取多媒体

		reader.onload = function(ev) {
			new Audio(reader.result).play();
		}

		ev.preventDefault();
	}
</script>
```

处理文本/多媒体
``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		if (/text/.test(file.type)) {  // 处理文本

			reader.readAsText(file);

			reader.onload = function() {
				document.write(reader.result);
			}

			console.log('text');

		} else {  // 处理多媒体
			reader.readAsDataURL(file);

			reader.onload = function() {
				if (/image/.test(file.type)) {
					console.log('image');

					var oImage = new Image();
					oImage.src = reader.result;

					document.body.appendChild(oImage)

				} else if (/video/.test(file.type)) {

					console.log('video');

					oVideo.src = reader.result;
					oVideo.play();

				} else {

					console.log('audio');
					new Audio(reader.result).play();

				}
			}
		}

		ev.preventDefault();
	}
</script>
```

#### H5 web工作线程webworker
进程
线程

`var worker = new Worker('js文件');`  新建worker

> 	1. 需在服务器环境下
	2. 不会改变数据类型
	3. 不会改变父线程数据
	4. DOM/BOM 不可使用(console.log可用)
    5. 只能有一层子线程，子线程不可再开子线程

方法
worker.postMessage('Data')  向worker内传递数据 (1)
worker.onmessage 监听事件 (4)
worker.terminate 停止worker

worker内部
监听事件：
this.onmessage -> ev -> ev.data //'Data' (2)
this.postMessage 向父线程传递数据  (3)

示例

主程序
``` javascript
<script>
	var worker = new Worker('./calc.js');

	worker.postMessage(2);
</script>
```

calc.js
``` javascript
<script>
	this.onmessage = function(ev) {
		console.log(ev.data)
	}

	function fibonacci(n){
		if( n == 1 || n == 2 ) return 1;

		return fibonacci(n-1) + fibonacci(n-2);
	}
</script>
```

## 1.18

### H5 webSocket 网络套接字

客户端
1.发消息 -> emit
2.接消息 -> on

服务端
1.接消息 -> on
2.发消息 -> emit

### 映像劫持

## 1.19

### 移动端

#### viewport设置
`<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">`

window.innerWidth(度量viewport)

document.body.clientWidth(布局viewport)

width 设置布局viewport的特定值
  > width=device-width  布局viewport=设备宽度

initial-scale 设置页面的初始缩放
  > window.innerWidth/document.body.clientWidth=initial-scale=1.0  度量viewport=布局viewport

maximum-scale 最大缩放
minimum-scale 最小缩放
user-scalable 用户能否缩放

#### 移动端布局

##### 1. 定宽布局

- 定宽水平居中

``` css
<style>
	.container{
		width: 600px;
		height: 4000px;
		background-color: green;
		margin: 0 auto;
	}
</style>
```

``` css
<style>
	.container {
		width: 600px;
		height: 4000px;
		background-color: green;
		position: absolute;
		left: 50%;
		top: 0;
		margin-left: -300px;
	}
</style>
```

``` css
<style>
	.container {
		width: 600px;
		height: 4000px;
		background-color: green;
		position: absolute;
		left: 50%;
		top: 0;
		transform: translateX(-50%);
	}
</style>
```



##### 2. 流体/浮动布局

- 一侧定宽，一侧自适应

**calc() -> 计算布局**

``` css
<style>
	#box1 {
		width: 200px;
		height: 200px;
		display: inline-block;
		background-color: green;
	}
	#box2 {
		width: calc(100% - 200px);
		display: inline-block;
		height: 200px;
		background-color: blue;
	}
</style>
```

``` css
<style>
	#box1 {
		width: 200px;
		height: 200px;
		display: inline-block;
		background-color: green;
		position: absolute;
		left: 0;
		top: 0;
	}
	#box2 {
		width: calc(100% - 200px);
		display: inline-block;
		height: 200px;
		background-color: blue;
		margin-left: 200px;
	}
</style>
```

- 自适应5列等宽导航栏

``` css
<style>
	li{
		width: calc(20% - 10px);
		float: left;
		background-color: green;
		text-align: center;
		border: 5px solid black;
	}
</style>
```

``` css
<style>
	li{
		width: 20%;
		float: left;
		background-color: green;
		text-align: center;
		border: 5px solid black;
		box-sizing: border-box;
	}
</style>
```

##### 3. 等比布局

[css中的px、em、rem 详解](http://www.mamicode.com/info-detail-655497.html)

- px 像素  虚拟长度单位  px=1/dpi (英寸)
- em 相对长度单位 相对父节点的font-size

> 默认  1em = 16px(浏览器默认字体高) 12px=0.75e，10px=0.625em

  **若body选择器中声明font-size=62.5%，em值变为 16px*62.5%=10px -> 12px=1.2em，10px=1em**

> 1. em的值并不是固定的；
  2. **em会继承父级元素的字体大小再计算。

- pt 磅  物理长度单位  pt=1/72 (英寸)
- rem 根em(root em) 相对html的font-size  **IE9+**  **推荐**


1vh -> 视窗高度的1%
1vw -> 视窗宽度的1%
1vmax -> 视窗高度/视窗宽度 取大值的1%
1vmin -> 视窗高度/视窗宽度 取小值的1%

**重点：根据根字号和设计图设备尺寸写js**
document.documentElement.style.fontSize = (clientWidth/320(设备宽度))*10(根字号) + 'px';

``` css
<style>
	html{
		font-size: 100px;
	}
</style>
```

**resize.js**

``` javascript
<script>
	// ;(function() {

	// 	var doc = document.documentElement;

	// 	function reset() {
	// 		var {clientWidth} = doc;  // var clientWidth = doc.clientWidth

	// 		doc.style.fontSize = (clientWidth / 320) * 100 + 'px';
	// 	}

	// 	window.onresize = reset;
	// 	reset();
	// })();

	;(function() {
		var doc = document.documentElement;

		function resize() {
			doc.style.fontSize = doc.clientWidth / 320 * 100 + 'px';
		}

		window.addEventListener('resize', resize, false);

		resize();
	})();
</script>
```

``` javascript
<script>
	var json = {a:1};
	var {a} = json;  // var a = json.a

	var arr = [1,2];
	var [a,b] = arr; // a=1 b=2
</script>
```

##### 4. 弹性盒模型

[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)

display:flex

> 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。

**属性**
父级

- flex-direction flex方向

  row/row-reverse -> 行(水平方向)/转置

  column/column-reverse -> 列(竖直方向)/转置

- justify-content  对齐方式(水平方向)

	flex-start -> 开始端
	flex-end -> 结束端
	center -> 中间
	space-between -> 两端对齐 将两侧子元素顶到头，剩余空间均分
	space-around -> 空间均分给每个子元素,子元素均分给两侧

- align-items  对齐方式(垂直方向)
	flex-start -> 开始端
	flex-end -> 结束端
	center -> 中间
	stretch -> 拉伸以充满
	baseline -> 基线

- align-content

- flex-wrap 换行
	nowrap -> 超出不换行
	wrap -> 超出换行


子级

- flex:1/2/3  均分剩余空间的多少份

**兼容：IE11+**
[ CSS之flex兼容](http://blog.csdn.net/u010130282/article/details/52627661)

``` css
<style>
	.box{
	    display: -webkit-flex;  /* 新版本语法: Chrome 21+ */
	    display: flex;          /* 新版本语法: Opera 12.1, Firefox 22+ */
	    display: -webkit-box;   /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */
	    display: -moz-box;      /* 老版本语法: Firefox (buggy) */
	    display: -ms-flexbox;   /* 混合版本语法: IE 10 */

	 }

	.flex1 {
	    -webkit-flex: 1;        /* Chrome */
	    -ms-flex: 1             /* IE 10 */
	    flex: 1;                /* NEW, Spec - Opera 12.1, Firefox 20+ */
	    -webkit-box-flex: 1;     /* OLD - iOS 6-, Safari 3.1-6 */
	    -moz-box-flex: 1;       /* OLD - Firefox 19- */
	}
</style>
```

**应用**

1. 一侧定宽，一侧自适应

``` css
<style>
	.container{
		display: flex;
	}

	.left{
		width: 200px;
		height: 200px;
		background-color: green;
	}

	.right{
		flex: 1;
		height: 200px;
		background-color: blue;
	}
</style>
```

2. 三列 中间定宽 两侧3:1

``` css
<style>
	.container{
		display: flex;
	}

	.center{
		width: 200px;
		height: 200px;
		background-color: green;
	}

	.right{
		flex: 1;
		height: 200px;
		background-color: blue;
	}

	.left{
		flex: 3;
		height: 200px;
		background-color: blue;
	}
</style>
```

3. 自适应5列等宽导航栏

``` css
<style>
	ul{
		width: 100%;
		display: flex;
	}

	ul > li{
		flex: 1;
		background-color: green;
		text-align: center;
		border: 5px solid black;
	}
</style>
```

#### 移动端事件
**在手机WEB端，click会有 200~300 ms，所以用tap代替click作为点击事件。**

- touchstart 当手指触摸到屏幕触发

- touchmove  当手指在屏幕上移动时触发

- touchend   当手指离开屏幕时触发

- touchcancel  系统取消touch事件时触发

每个触摸事件被触发后，会生成一个event对象，event对象里额外包括触摸列表

targetTouches 当前dom元素上手指的列表


触摸列表的属性

clientX/clientY  触摸点相对浏览器窗口的位置

pageX/pageY  触摸点相对于页面的位置

screenX/screenY  触摸点相对于屏幕的位置

identifier  touch对象的ID

target  当前的DOM元素


##### 应用：移动端拖拽
``` javascript
<script>
	var oBox = document.querySelector('#box');

	oBox.addEventListener('touchstart', function(ev) {
		var clientX = ev.targetTouches[0].clientX;
		var clientY = ev.targetTouches[0].clientY;

		var disX = clientX - oBox.offsetLeft;
		var disY = clientY - oBox.offsetTop;

		document.addEventListener('touchmove', fnMove, false)

		document.addEventListener('touchend', fnEnd, false)

		function fnMove(ev) {
			var deltaX = ev.targetTouches[0].clientX - disX;
			var deltaY = ev.targetTouches[0].clientY - disY;

			oBox.style.left = deltaX + 'px';
			oBox.style.top = deltaY + 'px';

			ev.preventDefault();
		}

		function fnEnd() {
			document.removeEventListener('touchmove', fnMove, false)
			document.removeEventListener('touchend', fnEnd, false)

		}
	}, false)
</script>
```

##### 应用：移动端双击
``` javascript
<script>
	var oBox = document.querySelector('#box');
	var firstClicked = false;

	oBox.addEventListener('touchstart', function() {
		if (!firstClicked) {
			firstClicked = true;

			setTimeout(function() {
				firstClicked = false;
			}, 300)

		} else {
			alert(1);
		}
	}, false)
</script>
```

##### 应用：旋转缩放
``` javascript
<script>
	var oBox = document.querySelector('#box');

	var boxOriginX = oBox.offsetLeft + oBox.offsetWidth / 2;
	var boxOriginY = oBox.offsetTop + oBox.offsetHeight / 2;

	var scale = 1;    // 初始缩放比例
	var rotate = 0;   // 初始旋转度数

	document.addEventListener('touchstart', function(ev) {

		var startDis = getDistance(ev);
		var startDegree = getDegree(ev) - rotate;

		var oldScale = scale;

		document.addEventListener('touchmove', fnMove, false)

		function fnMove(ev) {

			// 缩放
			var endDis = getDistance(ev);

			scale = endDis / startDis + oldScale - 1;

			// 旋转
			var endDegree = getDegree(ev);
			var deltaDegree = startDegree - endDegree;

			rotate = -deltaDegree;

			oBox.style.transform = `scale(${scale}) rotate(${rotate}deg)`;
		}
	}, false);


	function getDistance(ev) {

		var clientX = ev.targetTouches[0].clientX;
		var clientY = ev.targetTouches[0].clientY;

		var deltaX = clientX - boxOriginX;
		var deltaY = clientY - boxOriginY;

		return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	}

	function getDegree(ev) {
		var clientX = ev.targetTouches[0].clientX;
		var clientY = ev.targetTouches[0].clientY;

		var deltaY = clientY - boxOriginY;
		var deltaX = clientX - boxOriginX;

		return a2d(Math.atan2(deltaY, deltaX));
	}

	function a2d(a) {
		return a / Math.PI * 180;
	}
</script>
```

##### 应用：双指旋转
``` javascript
<script>
	var oBox = document.querySelector('#box');
	var rotate = 0;

	oBox.addEventListener('touchstart', function(ev) {
		if (ev.targetTouches.length == 2) {
			document.addEventListener('touchmove', fnMove, false);
			document.addEventListener('touchend', fnEnd, false);

			var oldDegree = rotate;

			var startDegree = getDegree(ev);

			function fnMove(ev) {
				var endDegree = getDegree(ev);
				var delta = startDegree - endDegree;

				oBox.style.transform = `rotate(${oldDegree+delta}deg)`;

				rotate = oldDegree + delta;
			}

			function fnEnd() {
				document.removeEventListener('touchmove', fnMove, false);
				document.removeEventListener('touchend', fnEnd, false);
			}

			ev.preventDefault();
		}
	}, false)

	function getDegree(ev) {
		var targetTouches = ev.targetTouches;
		var firstTouch = targetTouches[0];
		var secondTouch = targetTouches[1];

		var deltaX = firstTouch.clientX - secondTouch.clientX;

		var deltaY = firstTouch.clientY - secondTouch.clientY;

		return a2d(Math.atan2(deltaX, deltaY));
	}

	function a2d(a) {
		return a / Math.PI * 180;
	}
</script>
```

##### 应用：双指缩放
``` javascript
<script>
	var oBox = document.querySelector('#box');
	var scale = 1;

	oBox.addEventListener('touchstart', function(ev) {
		if (ev.targetTouches.length == 2) {
			document.addEventListener('touchmove', fnMove, false);
			document.addEventListener('touchend', fnEnd, false);

			var oldScale = scale;

			var startDis = getDistance(ev);

			function fnMove(ev) {
				var endDis = getDistance(ev);
				scale = endDis / startDis + oldScale - 1;

				oBox.style.transform = `scale(${scale})`;
			}

			function fnEnd() {
				document.removeEventListener('touchmove', fnMove, false);
				document.removeEventListener('touchend', fnEnd, false);
			}

			ev.preventDefault();
		}
	}, false)

	function getDistance(ev) {
		var targetTouches = ev.targetTouches;

		var firstTouch = targetTouches[0];
		var secondTouch = targetTouches[1];

		var deltaX = secondTouch.clientX - firstTouch.clientX;

		var deltaY = secondTouch.clientY - firstTouch.clientY;

		return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	}

	function a2d(a) {
		return a / Math.PI * 180;
	}
</script>
```

##### 应用：双指一起拖拽
``` javascript
<script>
	var oBox = document.querySelector('#box');

	oBox.addEventListener('touchstart', function(ev) {

		if (ev.targetTouches.length == 2) {
			document.addEventListener('touchmove', fnMove, false);
			document.addEventListener('touchend', fnEnd, false);
		}

		var disX = ev.targetTouches[0].clientX - (oBox.dataset.left || 0);
		var disY = ev.targetTouches[0].clientY - (oBox.dataset.top || 0);

		function fnMove(ev) {
			var deltaX = ev.targetTouches[0].clientX - disX;
			var deltaY = ev.targetTouches[0].clientY - disY;

			oBox.dataset.left = deltaX;
			oBox.dataset.top = deltaY;

			oBox.style.transform = `translate(${deltaX}px,${deltaY}px)`
		}

		ev.preventDefault();

		function fnEnd() {
			document.removeEventListener('touchmove', fnMove, false);
			document.removeEventListener('touchend', fnEnd, false);

		}
	}, false)
</script>
```

##### 应用：双指分开拖拽
``` javascript
<script>
	var oLeft = document.querySelector('.left');
	var oRight = document.querySelector('.right');

	function setDrag(obj) {
		obj.addEventListener('touchstart', function(ev) {
			var disX = ev.targetTouches[0].clientX - obj.offsetLeft;
			var disY = ev.targetTouches[0].clientY - obj.offsetTop;

			var myId = ev.targetTouches[0].identifier;

			document.addEventListener('touchmove', fnMove, false);
			document.addEventListener('touchend', fnEnd, false);

			function fnMove(ev) {
				if (ev.targetTouches[0].identifier == myId) {

					var deltaX = ev.targetTouches[0].clientX - disX;
					var deltaY = ev.targetTouches[0].clientY - disY;

					obj.style.left = deltaX + 'px';
					obj.style.top = deltaY + 'px';
				}
			}

			function fnEnd() {
				document.removeEventListener('touchmove', fnMove, false);
				document.removeEventListener('touchend', fnEnd, false);
			}

			ev.preventDefault();
		}, false)
	}

	setDrag(oLeft);
	setDrag(oRight);
</script>
```

##### 应用：移动端轮播图

``` css
<style>
	html {
		font-size: 100px;
	}
	body {
		font-size: 0.16rem;
		margin: 0;
	}
	.container {
		width: 3.2rem;
		overflow: hidden;
	}
	ul, li {
		list-style: none;
		margin: 0;
		padding: 0;
	}
	ul {
		width: 22.4rem;
		display: flex;
		transform: translateX(-3.2rem);
	}
	ul > li {
		width: 3.2rem;
		height: 2rem;
		background-color: green;
		font-size: 0.3rem;
		text-align: center;
		line-height: 2rem;
		font-weight: bold;
		color: white;
	}
</style>
```

``` html
	<div class="container">
		<ul>
			<li>5</li>
			<li>1</li>
			<li>2</li>
			<li>3</li>
			<li>4</li>
			<li>5</li>
			<li>1</li>
			<!-- <li>
				<img src="img/slide_4.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_1.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_2.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_3.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_4.jpg" alt="">
			</li>
			<li>
				<img src="img/slide_1.jpg" alt="">
			</li> -->
		</ul>
	</div>
```


``` javascript
<script>
	var aLi = document.querySelectorAll('li');
	var oUl = document.querySelector('ul');
	var vw = aLi[0].offsetWidth;

	var currentIndex = 0;
	var bReady = true;

	oUl.addEventListener('touchstart', function(ev) {

		// 控制频率
		if (!bReady) return;
		bReady = false;

		oUl.style.transition = '0s';

		var startX = ev.targetTouches[0].clientX;
		var disX = startX - (oUl.dataset.left || -vw);

		oUl.addEventListener('touchmove', fnMove, false);
		oUl.addEventListener('touchend', fnEnd, false);

		function fnMove(ev) {
			var deltaX = ev.targetTouches[0].clientX - disX;

			oUl.dataset.left = deltaX;

			oUl.style.transform = `translateX(${deltaX}px)`;

			ev.preventDefault();
		}

		function fnEnd(ev) {
			var endX = ev.changedTouches[0].clientX;
			var deltaX = endX - startX;

			// 拖拽距离是否可以切换
			if (Math.abs(deltaX) > vw / 4) {

				oUl.style.transition = '0.3s';

				//判断正负确定切换方向
				if (deltaX > 0) {
					currentIndex--

					if (currentIndex < 0) {
						currentIndex = 0;
					}
				} else {
					currentIndex++

					if (currentIndex > aLi.length - 1) {
						currentIndex = aLi.length - 1;
					}
				}

				setPosition();
			} else {

				// 不切换
				oUl.style.transition = '0.3s';
				setPosition();
			}

			oUl.removeEventListener('touchmove', fnMove, false);
			oUl.removeEventListener('touchend', fnEnd, false);
		}
	}, false)

	// 播放完毕之后判断currentIndex，是否拉回
	oUl.addEventListener('transitionend', function() {
		if (currentIndex == 0) {
			currentIndex = aLi.length - 2
		} else if (currentIndex == aLi.length - 1) {
			currentIndex = 1
		}

		oUl.style.transition = '0s';
		setPosition();

		bReady = true;
	}, false)

	aLi.forEach(function(oLi) {
		oLi.style.backgroundColor = `rgb(${
			rnd(0,255)
		},${
			rnd(0,255)
		},${
			rnd(0,255)
		})`
	})

	function setPosition() {
		var translate = -currentIndex * vw;
		oUl.style.transform = `translateX(${translate}px)`
		oUl.dataset.left = translate;
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}
</script>
```


## 1.
[CSS 垂直水平完全居中手册](http://mp.weixin.qq.com/s/QxYEVHskAyCnZMJ20oUPJQ)

## 2.
**当background-color 与 background-image 共存时，背景颜色永远在最底层（于背景图片之下）。**

## 3.
**父类容器的 z-index 优于子类 z-index**

## 4. 行内标签 -> 块标签的方法
- `display: block;`
- `float: left/right;`
- `position: absolute/fixed;`

## 5. 关于浮动
### 浮动的9个特性：
1. 半脱离文档流
2. 共处一行
3. 元素变成块元素，支持设置宽高
4. 顶对齐
5. 方向可以改变
6. 一行放不下会自动换行
7. 一行元素都浮动但高度不一致时，从最高的后面依次往后排
8. 文本环绕
9. 元素无宽高时根据内容撑开

### 浮动3要素
- 清浮动
- 同级有一个浮动，都浮动
- 尽量设置宽度

### 清除浮动的多种方法
[CSS清除浮动大全共8种方法](http://www.jb51.net/css/173023.html)

1. 浮动元素父级`overflow: hidden;`
    > 不适用子级高度大过父级
      缺点：会产生新的浮动问题。

2. 浮动元素同级最后加一个空白块标签，并设置`clear: both;`
	> `<div style="clear: both"></div>`

	>  缺点：增加了无意义标签。
3. clearfix

``` css
<style>
	/* clearfix */
	.clearfix:after {
	   content: "."; /* Older browser do not support empty content */
	   visibility: hidden;
	   display: block;
	   height: 0;
	   clear: both;
	}
	.clearfix {zoom: 1;} /* 针对 IE 不支持 :after */
</style>
```

4. 父级也浮动
5. 父级加绝对定位

## 6.
[常见布局样例](https://li-xinyang.gitbooks.io/frontend-notebook/content/chapter1/04_09_layout_demo.html)

## 7.
取消加粗样式的做法为：`font-weight: normal;` 或 `font-weight:500;`

## 8.
css实现强制不换行、自动换行、强制换行

- 强制不换行 `p {white-space: nowrap;}`
- 自动换行   `p {word-wrap: break-word; word-break:normal;}`
- 强制英文单词换行 `p {word-break: break-all;}`
	若为行内元素 需`span {display: block;}`

## 9. 解决图片下方出现几像素的空白间隙

``` css
<style>
	img {
		display: block;
		vertical-align: top;
	}
</style>
```

## 10. IE6中float和margin同向时产生双边距
``` css
<style>
	div {
		width: 200px;
		height: 200px;
		background: red;
		float: left;
		margin-left: 50px;
		display: inline;  /* 解决 */
	}
</style>
```

``` html
	<div></div>
	<div></div>
```

## 11. border:0 && border:none
- `border: 0;` 在只是把border-width设置为0，标签依然有border-style和border-color。
	所以border: 0;没有清除干净border，浏览器会继续渲染，运行速度慢。

- `border: none;` 把border相关属性都清除了。
	浏览器不需要渲染，运行速度快。

## 12. 两个div并排的多种方法
- 定位
- margin负值
- 浮动
- 行内块
- table


## 13. css hacks
- `border: 1px solid red\9;`  IE6/7/8
- `*border: 1px solid red;`  IE6/7
- `_border: 1px solid red;`  IE6

### 条件注释
``` html

<!-- [if IE 6] -->
	注释/link/script

<![endif] -->

```

## 14. 通俗解释**渐进增强**和**优雅降级**
- 优雅降级
	在高版本浏览器让用户体验更舒适

- 渐进增强
	在低版本浏览器让用户正常使用

## 15. 视觉隐藏网页内容的多种方法
- `display: none;`
- `text-indent: -999em;`
- 定位
- `overflow: hidden;`
- `opacity: 0`
- `visibility: none;`
- margin-left
- 注释

## 16. css优先级
行间 > id > class > 标签 > 默认 > 继承 > *

## 17. table表现数据时比实际设置的宽度宽
解决：
``` html
<table cellpadding="0" cellspacing="0">
	
</table>
```

## 18.
- `display: inline;` 兼容所有浏览器
- `disolay: inline-block;`  不兼容

## 19. 文档类型声明种类
- `!<DOCTYPE html>`  HTML5型
- Transitional  过渡型
- Strict  严格型
- Frameset 框架型

## 20. 浏览器 标准模式 && 怪异模式
没有文档类型声明或者文档类型声明不正确的文档时为**怪异模式**。

怪异模式下总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin;。

``` css
<style>
	.box {
	    width: 200px;
	    height: 200px;
	    border: 20px solid black;
	    padding: 50px;
	    margin: 50px;
	}
</style>

```

[标准模式-盒模型](http://7vik63.com1.z0.glb.clouddn.com/wp-content/uploads/2013/06/2.png)

[怪异模式-盒模型](http://7vik63.com1.z0.glb.clouddn.com/wp-content/uploads/2013/06/1.png)

- 当设置为`box-sizing:content-box`时，将采用标准模式解析计算，也是默认模式；

- 当设置为`box-sizing:border-box`时，将采用怪异模式解析计算；


## 21. inline-block问题
inline-block元素间会有4px左右的间隙

原因：换行符导致

解决：
  父级 {font-size: 0; letter-spacing: -4px;}
  子级 {font-size: 值; letter-spacing: 值px;}

inline-block默认基线对齐，基线为各元素最后一行文字底部

> 注：flex的基线是第一行文字底部

## 22. resetting && normailzing
- resetting:直接重置所有格式，没有任何前提性质的。
- normalizing：重置部分格式的。

> 推荐normalize.css

## 23. BFC
### 什么是BFC
BFC就是“块级格式化上下文”的意思，创建了 BFC的元素就是一个独立的盒子，不过只有Block-level box可以参与创建BFC， 它规定了内部的Block-level Box如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素。

### 如何触发BFC
- float 除了none以外的值
- overflow 除了visible 以外的值（hidden，auto，scroll ）
- display (table-cell，table-caption，inline-block, flex, inline-flex)
- position值为（absolute，fixed）
- fieldset元素

### 哪些场景可以用到BFC

1.解决margin叠加问题 三P每个p之间的距离为50px，发生了外边距叠加。 要解决这个叠加问题即让每个P之间是100px，我们可以新建一个BFC，怎么建呢？可以给p元素添加一个父元素，让它触发BFC。

2.用于布局

从图中我们会发现上面BFC的第三个特性，就是元素的左外边距会触碰到包含块容器的做外边框，就算存在浮动也会如此。那么我们如何解决这个问题呢？看上面BFC第四个特性，就是BFC不会与浮动盒子叠加，那么我们是不是可以创建一个新的BFC来解决这个问题呢？来看看：

发现我们用overflow:hidden触发main元素的BFC之后，效果立马出现了,一个两栏布局就这么妥妥的

3.用于清除浮动，计算BFC高度。


## 24. 图片替换方法

[CSS——图片替换方法比较](http://www.cnblogs.com/wmhuang/p/image_change.html)

1. Fahrner图片替换法（FIR）

首先添加一个<span>标签，然后使用<span>标签的display属性把文字隐藏起来，最后指定<h1>的背景图片。

- 优点：使用CSS而不是标记语法提供图片，更改图片只需更改CSS。

- 缺点：（1）需要一组不具备任何语义的<span>标签才能运作（2）display属性影响屏幕阅读器使用者（3）关闭浏览器显示图片，同时启用CSS支持时，文字图片均不可显示。

2. Leahy/Langridge图片替换法（LIR）

首先将padding-top设置为图片高度，将h1高度设置为0（IE5下设置为图片高度），根据盒子模型可知，文字内容将被排挤到指定高度之外，同时设置overflow：hidden将溢出文字隐藏。

- 优点：（1）去掉冗余的<span>标签（2）不影响屏幕阅读器使用者

- 缺点：（1）关闭浏览器显示图片，同时启用CSS支持时，文字图片均不可显示（2）要为IE5 for Windows使用盒模型Hack。

3. phark图片替换法

设置text-indent属性为很大的负值，将文字显示在屏幕之外，达到隐藏的效果。

- 优点：（1）不需要额外标签（2）不影响屏幕阅读器使用者

- 缺点：关闭浏览器显示图片，同时启用CSS支持时，文字图片均不可显示

## 25. 隐藏内容同时保证屏幕阅读器可用

[有哪些的隐藏内容的方法（如果同时还要保证屏幕阅读器可用呢？）](http://blog.csdn.net/xujie_0311/article/details/42246931)

1. `display:none;`

搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略

屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字，同时不利于搜索引擎。

2. `visibility: hidden ;`

这个大家应该比较熟悉就是隐藏的内容会占据他所应该占据物理空间

3. `overflow:hidden;`  推荐

.texthidden { display:block;/*统一转化为块级元素*/ overflow: hidden; width: 0; height: 0; }

## 26. 栅格系统
[详解CSS中的栅格系统](http://www.jb51.net/css/362199.html)

- Bootstrap

- Foundation

- Block Grid

- Toast栅格

## 27. 如果设计中使用了非标准的字体，你该如何去实现？

[如果设计中使用了非标准的字体，你该如何去实现？](http://blog.csdn.net/xujie_0311/article/details/42368371)

1. 用图片代替

2. web

3. @font-face

## 28. 浏览器是如何判断元素是否匹配某个 CSS 选择器

[浏览器是如何判断元素是否匹配某个 CSS 选择器](https://www.zhihu.com/question/24959507)

**从后往前判断**

eg:
`body.ready #wrapper > .lol233`

先把所有 class 中有 lol233 的元素拿出来组成一个集合，然后上一层，对每一个集合中的元素，如果元素的 parent id 不为 #wrapper 则把元素从集合中删去。 再向上，从这个元素的父元素开始向上找，没有找到一个 tagName 为 body 且 class 中有 ready 的元素，就把原来的元素从集合中删去。


## 29. 响应式与自适应

iPad 768 * 1024
iPhone 宽度 320(iPhone5) ~ 414(iPhone6P)

[BESD:响应式与自适应设计:设计师的最佳选择是什么?](http://www.ui.cn/detail/50798.html)

6种常见的屏幕布局。
	- 320
	- 480
	- 760
	- 960
	- 1200
	- 1600

- 响应式使用CSS media queries的方法，根据目标设备自动改变风格如显示类型,宽度、高度等，这能很好解决不同屏幕尺寸的显示问题。

> 响应式 采用流体＋断点，在断点之间，页面依然会随窗口大小自动缩放（通过 fluid grid ），直到遇到断点改变界面样式。相对的，自适应 只在针对几种分辨率（如1280，800，640，320px）进行优化，在断点之间的自动过渡比较少。

- 自适应直接让容器宽度相对于父级或者窗口进行缩放
  方式：浮动/定位(百分比)/flex/rem


## 30. retina

[前端开发之retina屏幕](https://segmentfault.com/a/1190000006999004)

## 31.
- 在Blink和WebKit的浏览器中，某个元素具有3D或透视变换（perspective transform）的CSS属性，会让浏览器创建单独的图层。

- 我们平常会使用left和top属性来修改元素的位置，但left和top会触发重布局，取而代之的更好方法是使用translate，这个不会触发重布局。

- HTTP2协议
  - 所有http请求都建立在一个TCP请求上，实现多路复用
  - 可以给请求添加优先级
  - 服务器主动推送 server push
  - HTTP2的头部会减小，从而减少流量传输

- DNS
  - DNS的作用是域名和IP地址的相互映射
  - DNS协议运行在UDP协议之上
  - DNS协议端口号为53


## 32. websocket
在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header。

WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。

> Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议


## 33. 前端工程化
- 开发规范
- 模块化开发
- 组件化开发
- 组件仓库
- 性能优化
- 项目部署
- 开发流程
- 开发工具


## 34. 实现以下代码
// 写一个 function 让下面两行代码输出的结果都为 5
console.log(sum(2, 3));
console.log(sum(2)(3));

```
<script>
	var sum = function sum() {
	    var cache;
	    if (arguments.length === 1) {
	        cache = arguments[0];
	        return function ( number ) {return cache + number;};
	    }
	    else return arguments[0] + arguments[1];
	};
</script>
```

---

## 35. 前端开发面试题总结之——HTML

[以下内容摘自：前端开发面试题总结之——HTML](http://www.jianshu.com/p/872f8fb425ce)

### 1. Doctype作用？严格模式与混杂模式如何区分？它们有何意义?
（1）<!DOCTYPE>声明位于HTML文档中的第一行，处于<html>标签之前，用于告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
（2）标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。
（3）如果HTML文档包含形式完整的DOCTYPE，那么他一般以标准模式呈现。对于HTML4.01文档，包含严格DTD的DOCTYPE常常导致页面以标准模式呈现。DOCTYPE不存在或者格式不正确会导致文档已混杂模式呈现。

### 2. HTML5 为什么只需要写 <!DOCTYPE HTML>？
（1）HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；
（2）HTML4.01基于SGML，所以需要对DTD进行引用，才能让浏览器知道该文档所使用的文档类型。

### 3. 介绍一下你对浏览器内核的理解？
浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。

### 4. 常见的浏览器内核有哪些？
- Trident [ˈtraɪdnt] 内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
- Gecko[ˈgekəʊ]内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等。
- Presto [ˈprestəʊ] 内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
- Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]
- EdgeHTML内核：Microsoft Edge。  [此内核其实是从MSHTML fork而来，删掉了几乎所有的IE私有特性]

### 5. HTML5的离线存储怎么使用？能否解释一下工作原理？
在用户没有连接英特网时，可以正常访问站点和应用；在用户连接英特网时，更新用户机器上的缓存文件。
`原理`：HTML5的离线存储是基于一个新建的 `.appcache` 文件的缓存机制（并非存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储下来。之后当网络处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。
使用方法：
(1) 在页面头部像下面一样加入一个 manifest 的属性
  `<html manifest = "cache.manifest"></html>`
(2) 在 cache.manifest 文件里编写离线存储资源；
   CACHE MANIFEST
   #v0.11
   CACHE：
     js/app.js
     css/style.css
   NETWORK:
     resource/logo.png
   FALLBACK：
     / /offline.html
(3) 在离线状态时，操作 window.applicationCache 进行需求实现

### 6. 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？
- 在线情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
- 离线情况下，浏览器就直接使用离线存储的资源。

### 7. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？
Web Storage有两种形式：LocalStorage（本地存储）和sessionStorage（会话存储）。这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。

（1）与cookie不同的是：Web Storage数据完全存储在客户端，不需要通过浏览器的请求将数据传给服务器，因此x相比cookie来说能够存储更多的数据，大概5M左右。

（2）LocalStorage和sessionStorage功能上是一样的，但是存储持久时间不一样。
LocalStorage：浏览器关闭了数据仍然可以保存下来，并可用于所有同源（相同的域名、协议和端口）窗口（或标签页）；
sessionStorage：数据存储在窗口对象中，窗口关闭后对应的窗口对象消失，存储的数据也会丢失。

	> 注意：sessionStorage 都可以用localStorage 来代替，但需要记住的是，在窗口或者标签页关闭时，使用sessionStorage 存储的数据会丢失。

（3）使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage. 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。

### 8. iframe 有哪些缺点？
（1）iframe会阻塞主页面的Onload事件；
（2）搜索引擎的检索程序无法解读这种页面，不利于SEO；
（3）iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
（4）使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好通过JavaScript动态给iframe添加src属性值，这样可以绕开以上两个问题。

### 9. 如何实现浏览器内多个标签页之间的通信？（阿里）
调用 localStorage、cookies 等本地存储方式

### 10. webSocket 如何兼容低浏览器？（阿里）
- Adobe Flash Socket
- ActiveX HTMLFile（IE）
- 基于 multipart 编码发送 XHR
- 基于长轮询的 XHR

### 11. 如何在页面上实现一个圆形的可点击区域？
(1) map + area 或者 svg
(2) border-radius
(3) 纯js实现，需要求一个点在不在圆上的简单算法、获取鼠标坐标等等

### 12. 实现 不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？
`<div style="height:1px;overflow:hidden;background:#ccc"></div>`

## 36. 前端开发面试题总结之——CSS3

[以下内容摘自：前端开发面试题总结之——CSS3](http://www.jianshu.com/p/f60b619aa52b)

### 1. 如何理解CSS的盒子模型？
每个HTML元素都是长方形盒子。
（1）盒子模型有两种：IE盒子模型、标准W3C盒子模型；IE的content部分包含了border和pading。
（2）标准W3C盒模型包含：内容(content)、填充(padding)、边界(margin)、边框(border)。

### 2. link和@import的区别？
（1）link属于XHTML标签，而@import是CSS提供的。
（2）页面被加载时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载。
（3）import只在IE 5以上才能识别，而link是XHTML标签，无兼容问题。
（4）link方式的样式权重高于@import的权重。
（5）使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。

### 3. CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS 3新增伪类有哪些？
- id选择器（#myid）
- 类选择器（.myclassname）
- 标签选择器（div、h1、p）
- 相邻选择器（h1 + p）
- 子选择器（ul > li）
- 后代选择器（li a）
- 通配符选择器（ * ）
- 属性选择器（a[rel = "external"]）
- 伪类选择器（a: hover, li: nth - child）

- 可继承： font-size font-family color, UL LI DL DD DT;
- 不可继承 ：border padding margin width height ;

优先级就近原则，样式定义最近者为准，载入样式以最后载入的定位为准。
优先级为：
     !important >  id > class > tag
     important 比 内联优先级高

CSS3新增伪类举例：
- p:first-of-type 选择属于其父元素的首个<p>元素的每个<p>元素。
- p:last-of-type  选择属于其父元素的最后<p>元素的每个<p>元素。
- p:only-of-type  选择属于其父元素唯一的<p>元素的每个<p>元素。
- p:only-child    选择属于其父元素的唯一子元素的每个<p>元素。
- p:nth-child(2)  选择属于其父元素的第二个子元素的每个<p>元素。
- :enabled、:disabled 控制表单控件的禁用状态。
- :checked  单选框或复选框被选中。

### 4. 如何居中一个浮动元素

```
<style>
	.div {
	   width:500px ;
	   height:300px; /* 高度可以不设 */
	   margin: -150px 0 0 -250px;
	   position:relative;  /* 相对定位 */
	   background-color:pink;  /* 方便看效果 */
	   left:50%;
	   top:50%;
	 }
</style>
```

### 5. 经常遇到的浏览器的兼容性有哪些？原因、解决方法是什么？

（1）png24为的图片在IE6浏览器上出现背景，解决方案是做成PNG8。
（2）浏览器默认的margin和padding不同，解决方案是加一个全局的*{margin:0;padding:0;}来统一。
（3）IE6双边距bug:块属性标签float后，又有横行的margin情况下，在IE 6显示margin比设置的大。
（4）浮动ie产生的双边距问题：块级元素就加display：inline；行内元素转块级元素display：inline后面再加display：table。
```
<style>
    .bb{
	     background-color:#f1ee18;        /*所有识别*/
	    .background-color:#00deff\9;        /*IE6、7、8识别*/
	    +background-color:#a200ff;        /*IE6、7识别*/
	    _background-color:#1e0bd1;        /*IE6识别*/
    }
</style>
```

### 6. 常用Hack的技巧
（1）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；
（2）Firefox下，只能使用getAttribute()获取自定义属性。解决方法：统一通过getAttribute()获取自定义属性。
（3）IE下，event对象有x,y属性，但是没有pageX,pageY属性；
（4）Firefox下，event对象有pageX,pageY属性，但是没有x,y属性。解决方法是条件注释，缺点是在IE浏览器下可能会增加额外的HTTP请求数。
（5）Chrome 中文界面下默认会将小于12px的文本强制按照12px显示，可通过加入 CSS属性-webkit-text-size-adjust: none;来解决。
（6）超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不再具有hover和active了，解决方法是改变CSS属性的排列顺序：
L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}

### 7. 为什么要初始化CSS样式？
因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。
最简单的初始化方法就是：* {padding: 0; margin: 0;} （笔者不建议这样）

> 淘宝的样式初始化：

```
<style>
  body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }
  body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
  h1, h2, h3, h4, h5, h6{ font-size:100%; }
  address, cite, dfn, em, var { font-style:normal; }
  code, kbd, pre, samp { font-family:couriernew, courier, monospace; }
  small{ font-size:12px; }
  ul, ol { list-style:none; }
  a { text-decoration:none; }
  a:hover { text-decoration:underline; }
  sup { vertical-align:text-top; }
  sub{ vertical-align:text-bottom; }
  legend { color:#000; }
  fieldset, img { border:0; }
  button, input, select, textarea { font-size:100%; }
  table { border-collapse:collapse; border-spacing:0; }
</style>
```

### 8. CSS是怎样定义权重规则的？
以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：
/*权重为1*/
div{
}
/*权重为10*/
.class1{
}
/*权重为100*/
#id1{
}
/*权重为100+1=101*/
#id1 div{
}
/*权重为10+1=11*/
.class1 div{
}
/*权重为10+10+1=21*/
.class1 .class2 div{
} 
如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现。

### 9. 如何定义高度为1px的容器？
```
<style>
	div{
		height: 1px;
		width: 10px;
		background: #000;
		overflow: hidden;
	}
</style>
```

IE 6下这个问题是默认行高造成的，overflow:hidden | zoom:0.08 | line- height:1px这样也可以解决。

### 10. 如何解决IE 6的3px问题？
```
<style>
	_zoom:1;
	margin-left: value;
	_margin-left: value-3px;
</style>
```

### 11. Firefox下文本无法撑开容器的高度，如何解决？

清除浮动

```
<style>
	.clear{
		clear:both;
		height:0px;
		overflow:hidden;
	}
</style>
```

### 12. 在IE中内容会自适应高度，而FF不会自适应高度，怎么办？

在要自适应高度的层中加一个层，样式为
```
<style>
	.clear{
		clear:both;
		font-size:0px;
		height:1px
	}
</style>
```

这样解决有一个小小的问题，高度会多一个像素。还有一种解决方法，给当前层加上一个伪类。
```
<style>
	#test:after {
	  content: ".";
	  display: block;
	  height: 0;
	  clear: both;
	  visibility: hidden;
	}
</style>
```

### 13. 用纯 CSS 创建一个三角形的原理是什么？
把上、左、右三条边隐藏掉（颜色设为 transparent）

```
<style>
	#demo {
	width:0;
	height: 0;
	border-width: 20px;
	border-style: solid;
	border-color: transparent transparent red transparent;
	}
</style>
```

### 14. 怎么让Chrome支持小于12px 的文字？

`body{-webkit-text-size-adjust:none}`

### 15. 前端页面有哪三层构成，分别是什么？作用是什么？
最准确的网页设计思路是把网页分成三个层次，即：结构层、表示层、行为层。

- 网页的结构层（structural layer）由HTML或XHTML之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”
- 网页的表示层（presentation layer）由CSS负责创建。 CSS对“如何显示有关内容”的问题做出了回答。
- 网页的行为层（behavior layer）负责回答“内容应该如何对事件做出反应”这一问题。这是JavaScript语言和DOM主宰的领域。

### 16. ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。
单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。

伪元素由双冒号和伪元素名称组成。双冒号是在css3规范中引入的，用于区分伪类和伪元素。但是伪类兼容现存样式，浏览器需要同时支持旧的伪类，比如:first-line、:first-letter、:before、:after等。
对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。

> 提醒，如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。

### 17. 现在HTML5中css3可以写出一个旋转的立方体，请写出要用到的CSS属性。
```
<style>
	-webkit-transform-style: preserve-3d;
	-webkit-transform: rotateY(30deg) rotateX(10deg);
	-webkit-animation:  rot 4s linear infinite;
</style>
```

### 18. 介绍一下 Sass 和 Less 是什么？它们有何区别？
- Sass (Syntactically Awesome Stylesheets)是一种动态样式语言，语法跟css一样(但多了些功能)，比css好写，而且更容易阅读。Sass语法类似与Haml，属于缩排语法（makeup），用意就是为了快速写Html和Css。

- Less一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。

区别：
(1)Sass是基于Ruby的，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出Css到浏览器，也可以在开发环节使用Less，然后编译成Css文件，直接放到项目中，也有Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。
(2)变量符不一样，less是@，而Scss是$，而且变量的作用域也不一样，后面会讲到。
(3)输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。
(4)Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。

### 19. 常见ie6的浏览器兼容bug（3-5个）？
#### 文字本身的大小不兼容。
同样是font-size:14px的宋体文字，在不同浏览器下占的空间是不一样的，ie下实际占高16px，下留白3px，ff 下实际占高17px，上留白1px，下留白3px，opera下就更不一样了。解决方案：给文字设定 line-height 。确保所有文字都有默认的 line-height 值。

#### IE6吞吃现象
上下两个div，上面的div设置背景，却发现下面没有设置背景的div 也有了背景，这就是吞吃现象。对应上面的背景吞吃现象，还有滚动下边框缺失的现象。解决方案：使用zoom:1。这个zoom好象是专门为解决ie6 bug而生的。

#### IE6注释bug
ie6的这个bug下，大家会在页面看到字出现两遍，重复的内容量因注释的多少而变。
解决方案：用“<!–[if !IE]> picRotate start <![endif]–>”方法写注释。

#### img 下的留白，如下代码：

```
<div>
	<img src=“1.jpg” />
</div>
```
把div的border打开，你发现图片底部不是紧贴着容器底部的，是img后面的空白字符造成，要消除必须这样写

```
<div>
<img src=”1.jpg” /></div>
```
后面两个标签要紧挨着。ie7下这个bug 依然存在。解决方案：给img设定 display:block。

#### 失去line-height
<div style=”line-height:20px”><img />文字</div>，很遗憾，在ie6下单行文字 line-height 效果消失了。原因是<img />这个inline-block元素和inline元素写在一起了。

解决方案：让img 和文字都 float起来。

#### clear层应该单独使用。也许你为了节省代码把clear属性直接放到下面的一个内容层，这样有问题，不仅仅是ff和op下失去margin效果，ie下某些margin值也会失效。
```
<div style=”background:red;float:left;”>dd</div>
<div style=”clear:both;margin-top:18px;background:green”>ff</div>
```

#### ie 下overflow:hidden对其下的绝对层position:absolute或者相对层 position:relative无效。

解决方案：给overflow:hidden加position:relative或者position: absolute。
另，ie6支持overflow-x或者overflow-y的特性，ie7、ff不支持。

## 37. 前端开发面试题总结之——JAVASCRIPT

[以下内容摘自：前端开发面试题总结之——JAVASCRIPT](http://www.jianshu.com/p/fc1faa8730b2)

### 1. 介绍一下 JS 有哪些内置对象
- Object 是 JavaScript 中所有对象的父对象
- 数据封装类对象：Object、Array、Boolean、Number、String
- 其他对象：Function、Argument、Math、Date、RegExp、Error

### 2. 列举几条 JavaScript 的基本代码规范。
（1）不要在同一行声明多个变量
（2）如果你不知道数组的长度，使用 push
（3）请使用 ===/!== 来比较 true/false 或者数值
（4）对字符串使用单引号 ''(因为大多时候我们的字符串。特别html会出现")
（5）使用对象字面量替代 new Array 这种形式
（6）绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同
（7）不要使用全局函数
（8）总是使用 var 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间
（9）Switch 语句必须带有 default 分支
（10）使用 /**...*/ 进行多行注释，包括描述，指定类型以及参数值和返回值
（11）函数不应该有时候有返回值，有时候没有返回值
（12）语句结束一定要加分号
（13）for 循环必须使用大括号
（14）if 语句必须使用大括号
（15）for-in 循环中的变量应该使用 var 关键字明确限定作用域，从而避免作用域污染
（16）避免单个字符名，让你的变量名有描述意义
（17）当命名对象、函数和实例时使用驼峰命名规则
（18）给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题
（19）当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里，而不用找出并更新那个事件的事件处理器

### 3. 表述您对javascript this工作原理的理解
在函数中：this 通常是一个隐含的参数。

在函数外（顶级作用域中）：在浏览器中this 指的是全局对象；在Node.js中指的是模块(module)的导出(exports)。

传递到eval()中的字符串：如果eval()是被直接调用的，this 指的是当前对象；如果eval()是被间接调用的，this 就是指全局对象。

### 4. 介绍一下 JavaScript 原型，原型链，它们有何特点？
每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。

关系：instance.constructor.prototype = instance.__proto__

特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一改变。

当我们需要一个属性时，JavaScript引擎会先看当前对象中是否有这个属性，如果没有的话，就会查找它的prototype对象是否有这个属性，如此递推下去，一致检索到Object内建对象。

```
<script>
	function Func() {}
	Func.prototype.name = "Xiaosong";
	Func.prototype.getInfo = function() {
		return this.name;
	}
	var person = new Func();
	console.log(person.getInfo()); //"Xiaosong"
	console.log(Func.prototype); //Func { name = "Xiaosong", getInfo = function() }
</script>
```

### 5. JavaScript 有几种类型的值？能否画一下它们的内存图？
- 栈：原始数据类型（Undefined，Null，Boolean，Number，String）
- 堆：引用数据类型（对象、数组、函数）

两种类型的区别： 存储位置不同

- 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

### 6. JavaScript 如何实现继承？
(1)构造继承
(2)原型继承
(3)实例继承
(4)拷贝继承

//原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。

```
<script>
	function Parent() {
		this.name = 'song';
	}

	function Child() {
		this.age = 28;
	}

	Child.prototype = new Parent(); //通过原型,继承了Parent
	var demo = new Child();
	alert(demo.age);
	alert(demo.name); //得到被继承的属性
</script>
```

### 7. JavaScript 有哪几种创建对象的方式？
javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。

- (1)对象字面量的方式
`person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};`

- (2)用function来模拟无参的构造函数

```
<script>
	function Person() {}
	var person = new Person(); //定义一个function，如果使用new"实例化",该function可以看作是一个Class
	person.name = "Xiaosong";
	person.age = "23";
	person.work = function() {
		alert("Hello " + person.name);
	}
	person.work();
</script>
```

- (3)用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）

```
<script>
	function Person(name, age, hobby) {
		this.name = name; //this作用域：当前对象
		this.age = age;
		this.work = work;
		this.info = function() {
			alert("我叫" + this.name + "，今年" + this.age + "岁，是个" + this.work);
		}
	}
	var Xiaosong = new Person("WooKong", 23, "程序猿"); //实例化、创建对象
	Xiaosong.info(); //调用info()方法
</script>
```

- (4)用工厂方式来创建（内置对象）

```
<script>
	var jsCreater = new Object();
	jsCreater.name = "Brendan Eich"; //JavaScript的发明者
	jsCreater.work = "JavaScript";
	jsCreater.info = function() {
		alert("我是" + this.work + "的发明者" + this.name);
	}
	jsCreater.info();
</script>
```

- (5)用原型方式来创建

```
<script>
	function Standard() {}
	Standard.prototype.name = "ECMAScript";
	Standard.prototype.event = function() {
		alert(this.name + "是脚本语言标准规范");
	}
	var jiaoben = new Standard();
	jiaoben.event();
</script>
```

- (6)用混合方式来创建

```
<script>
	function iPhone(name, event) {
		this.name = name;
		this.event = event;
	}
	iPhone.prototype.sell = function() {
		alert("我是" + this.name + "，我是iPhone5s的" + this.event + "~ haha!");
	}
	var SE = new iPhone("iPhone SE", "官方翻新机");
	SE.sell();
</script>
```

### 8. eval 是做什么的？
它的功能是把对应的字符串解析成JS代码并运行。

应该避免使用eval，因为不安全，非常**耗性能**（2次，一次解析成js语句，一次执行）。

### 9. 能否写一个通用的事件侦听器函数？
Event工具集，from:github.com/markyunmarkyun

```
<script>
	Event = {
		//页面加载完成后
		readyEvent: function(fn) {
			if (fn == null) {
				fn = document;
			}
			var oldonload = window.onload;
			if (typeof window.onload != 'function') {
				window.onload = fn;
			} else {
				window.onload = function() {
					oldonload();
					fn();
				};
			}
		},
		//视能力分别使用 demo0 || demo1 || IE 方式来绑定事件 
		//参数：操作的元素，事件名称，事件处理程序 
		addEvent: function(element, type, handler) {
			if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉   
				element.addEventListener(type, handler, false);
			} else if (element.attachEvent) {
				element.attachEvent('on' + type, function() {
					handler.call(element);
				});
			} else {
				element['on' + type] = handler;
			}
		},
		//移除事件 
		removeEvent: function(element, type, handler) {
			if (element.removeEventListener) {
				element.removeEventListener(type, handler, false);
			} else if (element.datachEvent) {
				element.datachEvent('on' + type, handler);
			} else {
				element['on' + type] = null;
			}
		},
		//阻止事件（主要是事件冒泡，因为IE不支持事件捕获） 
		stopPropagation: function(ev) {
			if (ev.stopPropagation) {
				ev.stopPropagation();
			} else {
				ev.cancelBubble = true;
			}
		},
		//取消事件的默认行为
		preventDefault: function(event) {
			if (event.preventDefault) {
				event.preventDefault();
			} else {
				event.returnValue = false;
			}
		},
		//获取事件目标 
		getTarget: function(event) {
			return event.target || event.srcElemnt;
		},
		//获取event对象的引用，取到事件的所有信息，确保随时能使用event； 
		getEvent: function(e) {
			var ev = e || window.event;
			if (!ev) {
				var c = this.getEvent.caller;
				while (c) {
					ev = c.argument[0];
					if (ev && Event == ev.constructor) {
						break;
					}
					c = c.caller;
				}
			}
			retrun ev;
		}
	};
</script>
```

### 10. ["1","2","3"].map(parseInt) 的答案是多少？
`[1,NaN,NaN]`

因为 parseInt 需要两个参数(val,radix)，其中 radix 表示解析时用的基数。
map 传了3个(element,index,array)，对应的 radix 不合法导致解析失败。

### 11. 事件是什么？IE与火狐的事件机制有何区别？如何阻止冒泡？
(1)我们在网页中的某个操作（有的操作对应多个事件）。
  例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
(2)事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；
(3)ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）

### 12. 什么是闭包(closure)，为什么要用它？
闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以**突破作用链域，将函数内部的变量和方法传递到外部**。

闭包特性：
(1)函数内再嵌套函数
(2)内部函数可以**引用外层的参数和变量**
(3)**参数和变量不会被垃圾回收机制回收**

//li节点的onclick事件都能正确的弹出当前被点击的li索引

```
<ul>
  <li> index = 0 </li>
  <li> index = 1 </li>
  <li> index = 2 </li>
  <li> index = 3 </li>
</ul>
<script type="text/javascript">
  var nodes = document.getElementsByTagName('li');
  for (i = 0; i < nodes.length; i += 1) {
  	nodes[i].onclick = function() {
  		console.log(i + 1); //不使用闭包的话，值每次都是4 
  	}(4);
  }
</script>
```


### 13. new 操作符具体干了什么呢？
(1)创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
(2)属性和方法被加入到 this 引用的对象中。
(3)新创建的对象由 this 所引用，并且最后隐式的返回 this 。

```
<script>
	var obj = {};
	obj.__proto__ = Base.prototype;
	Base.call(obj);
</script>
```

### 14. JavaScript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是哪个？
`hasOwnProperty`

JavaScript 中 hasOwnProperty 函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。

使用方法：object.hasOwnProperty(proName)其中参数object是必选项，一个对象的实例。proName是必选项，一个属性名称的字符串值。

如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。

### 15. 你对 JSON 了解吗？
JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。

它是基于JavaScript的一个子集。数据格式简单，易于读写，占用带宽小。

如：`{"age":"12", "name":"back"}`

### 16. Ajax 是什么？如何创建一个 Ajax ？
ajax的全称：Asynchronous Javascript And XML，异步传输+js+xml。

所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。

(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
(3)设置响应HTTP请求状态变化的函数
(4)发送HTTP请求
(5)获取异步调用返回的数据
(6)使用JavaScript和DOM实现局部刷新

### 17. 同步和异步的区别？
同步的概念应该是来自于操作系统中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式)。

**同步强调的是顺序性，谁先谁后；异步则不存在这种顺序性。**

- 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。

- 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。

### 18. 如何解决跨域问题？
jsonp、iframe、window.name、window.postMessage、服务器上设置代理页面

### 19. ECMAScript 6 怎么写 class ，为何会出现 class？
ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

```
<script>
	//定义类
	class Point {
		constructor(x, y) {
			//构造方法
			this.x = x; //this关键字代表实例对象
			this.y = y;
		}
		toString() {
			return '(' + this.x + ',' + this.y + ')';
		}
	}
</script>
```

### 20. 异步加载 JS 的方式有哪些？
(1)defer，只支持 IE
(2)async:
(3)创建 script，插入到 DOM 中，加载完毕后 callBack

async：
创建script，插入到DOM中，加载完毕后callBack，见代码：
```
<script>
	function loadScript(url, callback) {
		var script = document.createElement("script")
		script.type = "text/javascript";
		if (script.readyState) { //IE
			script.onreadystatechange = function() {
				if (script.readyState == "loaded" || script.readyState == "complete") {
					script.onreadystatechange = null;
					callback();
				}
			};
		} else {
			//Others: Firefox, Safari, Chrome, and Opera
			script.onload = function() {
				callback();
			};
		}
		script.src = url;
		document.body.appendChild(script);
	}
</script>

### 21. document.write 和 innerHTML 有何区别？
- document.write 只能重绘整个页面
- innerHTML 可以重绘页面的一部分

### 22. 哪些操作会造成内存泄漏？
内存泄漏是指任何对象在您不再拥有或需要它之后任然存在。

垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量，如果一个对象的引用数量为0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。

闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）

### 23. jQuery 中如何将数组转化为 json 字符串，然后再转化回来？
jQuery 中没有提供这个功能，所以需要先编写两个 jQuery 的扩展：

```
<script>
	$.fn.stringifyArray = function(array) {
		return JSON.stringify(array)
	}

	$.fn.parseArray = function(array) {
		return JSON.parse(array)
	}

	//然后调用:
	$("").stringifyArray(array)
</script>
```

### 24. jQuery.extend 与 jQuery.fn.extend 有何区别？
- jQuery.extend  用一个或多个其他对象来扩展一个对象，返回被扩展的对象

```
<script>
	jQuery.extend(object);　 //为jQuery类添加类方法，可以理解为添加静态方法
	jQuery.extend({
		min: function(a, b) {
			return a < b ? a : b;
		},
		max: function(a, b) {
			return a > b ? a : b;
		}
	});
	jQuery.min(2, 3); //  2
	jQuery.max(4, 5); //  5
	jQuery.extend(target, object1, [objectN])
</script>
```

- jQuery.fn.extend(object) 对jQuery.prototype进行的扩展，就是为jQuery类添加“**成员函数**”。jQuery类的实例可以使用这个“成员函数”。

比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert 当前编辑框里的内容。可以这么做：
```
<script>
	$.fn.extend({
		alertWhileClick: function() {
			$(this).click(function() {
				alert($(this).val());
			});
		}
	});

	$("#input1").alertWhileClick();
	// 页面上为$("#input1")为一个jQuery实例，当它调用成员方法 alertWhileClick后，便实现了扩展，每次被点击时它会先弹出目前编辑里的内容。
</script>
```

### 25. 是否了解针对 jQuery 性能的优化方法？

- 基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。

- 频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。
比如：`var str = $("a").attr("href");`

```
<script>
	for (var i = size; i < arr.length; i++) {}

	//for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
	for (var i = size, length = arr.length; i < length; i++) {}
</script>
```

### 26. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）
通过判断 Global 对象是否为 window ，如果不为 window ，当前脚本没有运行在浏览器中。

### 27. 怎样用js实现千位分隔符？
正则 + replace
```
<script>
	function commafy(num) {
		num = num + '';
		var reg = /(-?d+)(d{3})/;
		if (reg.test(num)) {
			num = num.replace(reg, '$1,$2');
		}
		return num;
	}
</script>
```

### 28. Canvas和SVG的比较
|                Canvas             |                SVG                 |
|   :----: 	 		 			    | :---:                              |
|        位图技术，可以保存为.png   |      矢量图技术，不能保存为位图 |
|        善于表现颜色和线条细节     |      可以缩放，不善于表现细节|
|        网页游戏，统计图           |       图标，统计图，地图              |
| 一个标签(canvas)+一个对象(getcontext)，所有图形图像都靠ctx绘制 |   几十个标签---每个图形对应一个标签    |
| 不能被搜索引擎爬虫所访问          |          可以  			           |
| 只能为整个 Canvas绑定监听函数     | 每个图形（标签）可以绑定事件监听函数 |

### 29. 前端 MVC、MVVM

1. MVC
![MVC](http://upload-images.jianshu.io/upload_images/4749582-b49cc8f09e938eaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

模型（Model）：数据保存
视图（View）：用户界面
控制器（Controller）：业务逻辑
(1)View 传送指令到 Controller
(2)Controller 完成业务逻辑后，要求 Model 改变状态
(3)Model 将新的数据发送到 View ，用户得到反馈所有通信都是单向的。

2. MVVM
![MVVM](http://upload-images.jianshu.io/upload_images/4749582-5f80f772360f2ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

模型（Model）
视图（View）
视图模型（ViewModel）
(1)各部分间都是双向通信
(2)View 与 Model 不发生联系，都通过 ViewModel 传递
(3)View 非常薄，不部署任何业务逻辑，称为“被动视图”（Passive View），即没有任何主动性；而 ViewModel 非常厚，所有逻辑都部署在那里。
采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel ，反之亦然。

### 30. 写出下面的运算结果

```
<script>
	alert(typeof(null)); // object
	alert(typeof(undefined)); // undefined
	alert(typeof(NaN)); // number
	alert(NaN == undefined); // false
	alert(NaN == NaN); // false
	var str = "123abc";
	alert(typeof(str++)); // number
	alert(str); // NaN
</script>
```

### 31. 如何阻止事件的冒泡?

```
<script>
	//阻止冒泡的方法
	function stopPP(e) {
		var evt = e || window.event;
		//IE用cancelBubble=true来阻止而FF下需要用stopPropagation方法
		evt.stopPropagation ? evt.stopPropagation() : (evt.cancelBubble = true);
	}
</script>
```

### 32. 编写一个方法 求一个字符串的字节长度

```
<script>
	/*假设：一个英文字符占用一个字节，一个中文字符占用两个字节*/
	function getBytes(str) {
		var len = str.length,
			bytes = len,
			i = 0;
		for (; i < len; i++) {
			if (str.charCodeAt(i) > 255) bytes++;
		}
		return bytes;
	}
	alert(getBytes("玩,as"));
</script>
```

### 33. JavaScript中如何对一个对象进行深度clone？

```
<script>
	function cloneObject(o) {
		if (!o || 'object' !== typeof o) {
			return o;
		}
		var c = 'function' === typeof o.pop ? [] : {};
		var p, v;
		for (p in o) {
			if (o.hasOwnProperty(p)) {
				v = o[p];
				if (v && 'object' === typeof v) {
					c[p] = Ext.ux.clone(v);
				} else {
					c[p] = v;
				}
			}
		}
		return c;
	}
</script>
```

深克隆原理

```
<script>
	Object.clone = function(obj) { //深克隆
		if (typeof(obj) == "object") { //如果obj是对象
			var o = //有必要区分数组和普通对象
				Object.prototype.toString.call(obj) == "[object Array]" ? [] : {};
			for (var key in obj) { //遍历obj的自有属性
				//如果key是obj的自有属性
				if (obj.hasOwnProperty(key)) {
					o[key] = arguments.callee(obj[key]); //arguments.callee调的是当前的Object.clone函数
				}
			}
			return o;
		} else { //如果obj是原始类型的值，就直接返回副本
			return obj;
		}
	}
</script>
```

### 34. 请编写一个JavaScript函数 parseQueryString，它的用途是把URL参数解析为一个对象
如：`var url = “http://witmax.cn/index.php?key0=0&key1=1&key2=2″;`

```
<script>
	function parseQueryString(url) {
		var params = {},
			arr = url.split("?");
		if (arr.length <= 1)
			return params;
		arr = arr[1].split("&");
		for (var i = 0, l = arr.length; i < l; i++) {
			var a = arr[i].split("=");
			params[a[0]] = a[1];
		}
		return params;
	}

	var url = "http://witmax.cn/index.php?key0=0&key1=1&key2=2",
		ps = parseQueryString(url);
	console.log(ps["key1"]);
</script>
```
### 35. 以下代码运行结果

```
<script>
	function say() {
		// Local variable that ends up within closure
		var num = 888;
		var sayAlert = function() {
			alert(num);
		}
		num++;
		return sayAlert;
	}
	var sayAlert = say();
	sayAlert(); //889
</script>
```

### 36. 请实现ECMAScript 5中的Object.getPrototypeOf() 函数

```
<script>
	function proto(object) {
		  return !object?                null
		      : '__proto__' in object?  object.__proto__
		      : /* not exposed? */      object.constructor.prototype
	}
</script>
```

###  37. 如何实现Array.prototype.forEach

```
<script>
	if (!Array.prototype.forEach) {
		Array.prototype.forEach = function(fn) {
			for (var i = 0; i < this.length; i++) {
				fn(this[i], i, this);
			}
		};
	}

	["a", "b", "c"].forEach(function(value, index, array) {
		assert(value, "Is in position " + index + " out of " + (array.length - 1));
	});
</script>
```

### 38. 如何将arguments转为数组

```
<script>
	Object.prototype.slice.call(arguments);
</script>
```

### 39. 以下程序运行结果

```
<script>
	var ninja = function myNinja() {
		alert(ninja == myNinja);
	};
	ninja();
	myNinja();

	//true、 报错（ error - myNinja is not defined.）
</script>
```

### 40. 如何获取光标的水平位置

```
<script>
	function getX(e) {
		e = e || window.event;
		//先检查非IE浏览器，在检查IE的位置
		return e.pageX || e.clentX + document.body.scrollLeft;
	}
</script>
```

### 41. 以下程序运行结果

```
<script>
	var b = parseInt("01");
	alert("b=" + b);
	var c = parseInt("09/08/2009");
	alert("c=" + c);

	// b=1、c=9
</script>
```

```
<script>
	var foo = 'hello';
	(function() {
		var foo = foo || 'world';
		console.log(foo);
	})();

	//world
</script>
```

### 42. AJAX请求总共有多少种CALLBACK
Ajax请求总共有八种Callback
- onSuccess
- onFailure
- onUninitialized
- onLoading
- onLoaded
- onInteractive
- onComplete
- onException

### 43. 判断质数

```
<script>
	// 方法一:
	function isPrime1(n) {
		if (n <= 3) {
			return true
		} else {
			for (var i = 2; i < Math.sqrt(n); i++) {
				if (n % i == 0) {
					return false;
				}
			}
			return true;
		}
	}
	// 方法二: hash
	var isPrime2 = (function() { //hash
		var hash = {};
		return function(n) {
			if (n <= 3) {
				return true
			} else if (hash[n] !== undefined) {
				return hash[n];
			} else {
				for (var i = 2; i < Math.sqrt(n); i++) {
					if (n % i == 0) {
						return hash[n] = false
					}
				}
				return hash[n] = true;
			}
		}
	})();
</script>
```

### 44. 数组去重
```
<script>
	// 方法一:
	var arr1 = [1, 2, 3, 2, 1, 2];

	function repeat1(arr) {
		for (var i = 0, arr2 = []; i < arr.length; i++) {
			if (arr2.indexOf(arr[i]) == -1) {
				arr2.push(arr[i]);
			}
		} //(遍历结束)
		return arr2;
	}
	// 方法二:hash
	function repeat2(arr) {
		//遍历arr中每个元素，同时声明hash
		for (var i = 0, hash = {}; i < arr.length; i++) {
			//hash中是否包含当前元素值的建
			//如果不包含,就hash添加一个新元素，以当前元素值为key，value默认为1
			if (hash[arr[i]] === undefined) {
				hash[arr[i]] = 1;
			}
		} //(遍历结束)
		//将hash转为索引:
		var i = 0;
		var arr2 = [];
		for (arr2[i++] in hash);
		return arr2;
	}
	// 方法三:[这个好像有点问题]
	function repeat3(arr) {
		return arr.sort()
			.join(",,")
			.replace(
				/(^|,,)([^,]+)(,,\2)*/g,
				"$1$2")
			.split(",,");
	}
	console.log(repeat3(arr1));
</script>
```

### 45. 统计字符串中每种字符出现的次数,出现次数最多的是? 出现?次

```
<script>
	  var str = "helloworld";
	  // 方法一：用hash
	  for (var i = 0, hash = {}; i < str.length; i++) {
	  	if (hash[str[i]]) {
	  		hash[str[i]]++
	  	} else {
	  		hash[str[i]] = 1;
	  	}
	  }
	  console.dir(hash);

	  // 方法二：用正则
	  var arr = str.split("")
	  	.sort()
	  	.join("")
	  	.match(/([a-z])\1*/g)
	  	.sort(function(a, b) {
	  		return b.length - a.length;
	  	})
	  console.log("出现最多的是: " + arr[0][0] + "共" + arr[0].length + "次");
	  var hash = {};
	  arr.forEach(function(val) {
	  	hash[val[0]] = val.length;
	  });
	  console.dir(hash);
</script>
```

### 46. 数组降维

```
<script>
	var arr = [
		[0, 0, 0, 0],
		[0, 0, 0, 0],
		[0, 0, 0, 0],
		[0, 0, 0, 0],
	];
	//method 1:
	for (var r = 0, arr1 = []; r < arr.length; r++) {
		for (var c = 0; c < arr[r].length; c++) {
			arr1.push(arr[r][c]);
		}
	}
	console.dir(arr1);
	//method 2: 
	for (var r = 0, arr2 = []; r < arr.length; r++) {
		arr2 = arr2.concat(arr[r]);
	}
	console.dir(arr2);
	//method 3:
	var arr2 = [].concat.apply([], arr);
	console.dir(arr2);
</script>
```

### 47. Function赋值

```
<script>
	var f1 = function() {
		var a = b = 1;
	}
	f1();
	console.log(b); //1
	console.log(a); // 报错

	var f2 = function() {
		var c = d = 1;
	}
	setTimeout(f2, 0);
	console.log(d); // 报错

	var e, f = 0,
		f3 = function() {
			var e = f = 2;
		}
	f3();
	console.log(e); //undefined
	console.log(f); //2
</script>
```

### 48. 函数currying(柯里华)

```
<script>
	var getN;

	function add(n) {
		getN = function() {
			console.log(n);
		}
		return function(m) {
			n += m;
			arguments.callee.toString = function() {
				return n;
			}
			return arguments.callee;
		}
	}
	add(1)(2)(3);
	getN(); //6
	add(1)(2)(3)(4);
	getN(); //10
</script>
```

### 49. 递归

```
<script>
	var emp = {
		work: function() { //3,2,1
			var sum = 0; //+3+2+1 +2+1  +1
			for (var i = 0; i < arguments.length && arguments[0] > 0; i++) {
				sum += arguments[i] + arguments.callee(
					--arguments[i]
				);
			}
			return sum;
		}
	}
	console.log(emp.work(3, 2, 1)); //10
</script>
```

### 50. 闭包

```
<script>
	// （1）
	function fun(n, o) { //外层函数
		console.log(o);
		return {
			fun: function(m) { //内层函数 n
				return fun(m, n);
			}
		}
	}
	var a = fun(0);
	a.fun(1);
	a.fun(2);
	a.fun(3);
	//undefined  0      0       0
	var a = fun(0).fun(1).fun(2).fun(3);
	//undefined   0    1    2
	var a = fun(0).fun(1);
	a.fun(2);
	a.fun(3);
	//undefined  0       1      1
</script>
```

```
<script>
	// （2）
	var a = 0,
		b = 0;

	function A(a) {
		A = function(b) {
			console.log('进内层');
			console.log(a);
			console.log(a + b++);
		};
		console.log(a);
	}
	A(1); //1
	A(12); //进内层 1 13
</script>
```

### 51. OOP

```
<script>
	// （1）
	window.a = 300;

	function fn1() {
		this.a = 100;
		this.b = 200;
		return function() {
			console.log(this.a)
		}.call(arguments[0])
	}

	function fn2() {
		this.a = new fn1();
	}
	var a = new fn1().b; //300
	var v = new fn1(fn2()); // 200，[object Object]
</script>
```

```
<script>
	// （2）
	var number = 2; //4  8
	var obj = {
		number: 4, //8
		fn1: (function() {
			//var number;
			this.number *= 2;
			number *= 2; //声明提前  undefined
			var number = 3;
			return function() {
				this.number *= 2;
				number *= 3;
				console.log(number);
			}
		})()
	}
	var fn1 = obj.fn1;
	console.log(number);
	fn1();
	obj.fn1();
	//4           9      27
	console.log(window.number); //8
	console.log(obj.number); //8
</script>
```

```
<script>
	// （3）
	function Foo() {
		getName = function() {
			console.log(1);
		};
		return this;
	}
	Foo.getName = function() {
		console.log(2);
	};
	Foo.prototype.getName = function() {
		console.log(3);
	};
	var getName = function() {
		console.log(4);
	};

	function getName() {
		console.log(5);
	};
	Foo.getName(); //2
	getName(); //4
	Foo().getName(); //1
	getName(); //1
	new Foo.getName(); //2
	new Foo().getName(); //3
	new new Foo().getName(); //3
</script>
```

```
<script>
	// （4）
	var a = 1;
	var b = {
		a: 2,
		b: function() {
			console.log(this.a); //1
		}(),
		f: this.f = function() {
			console.log(this.a);
		}
	};

	function f() {
		console.log(3);
	}
	f(); //1
	b.f(); //2
	(b.f)(); //2
	(0, b.f)(); //1
</script>
```

```
<script>
	// （5）
	var foo = function() {
		console.log(this.a);
	}
	var obj = {
		a: 2,
		foo: foo
	};
	var a = 10;
	var bar = obj.foo;
	var bar2 = foo.bind(obj);
	bar(); //10
	bar2(); //2
	foo(); //10
	obj.foo(); //2
	setTimeout(bar, 0); //10
</script>
```

```
<script>
	// （6）
	function MyObj() {
		this.p.pid++;
	}

	MyObj.prototype.p = {
			"pid": 0
		} //2

	MyObj.prototype.getNum = function(num) {
		return this.p.pid + num;
	}

	var _obj1 = new MyObj(); //创建新对象，继承原型pid+1
	var _obj2 = new MyObj(); //创建新对象，继承原型pid+2
	console.log(
		_obj1.getNum(1) + _obj2.getNum(2)
	); //7      2+1   +    2+2
</script>
```

### 52. 判断一个对象是不是数组类型，有五种方法

(1) typeof 无法判断 只能判断原始类型的值和函数
(2)isPrototypeOf 判断父及对象   可检查整个原型链 //可能继承自数组

```
<script>
	console.log(Array.prototype.isPrototypeOf([]) ? "是数组" : "不是数组");  // 是
	console.log(Array.prototype.isPrototypeOf({}) ? "是数组" : "不是数组");
	console.log(Array.prototype.isPrototypeOf(function() {}) ? "是数组" : "不是数组");
</script>
```
(3)constructor 检查指定对象的构造函数 可检查整个原型链  //可能继承自数组

```
<script>
	var father = {};
	var son = {};
	father.__proto__ = Array.prototype;
	son.__proto__ = father;
	console.log(son.contructor == Array ? "是数组" : "不是数组")  // 不是
	console.log({}.contructor == Array ? "是数组" : "不是数组");  // 不是
	console.log(function() {}.contructor == Array ? "是数组" : "不是数组");  // 不是
</script>
```

(4)instanceof 检查一个对象是否是制定构造函数的实例 可检查整个原型链 //可能继承自数组
```
<script>
	var father = {};
	var son = {};
	father.__proto__ = Array.prototype;
	son.__proto__ = father;
	console.log(son instanceof Array ? "是数组" : "不是数组");  // 是数组
	console.log({}
		instanceof Array ? "是数组" : "不是数组");  // 不是
	console.log(function() {}
		instanceof Array ? "是数组" : "不是数组");  // 不是
</script>
```

(5)强行用要检查的对象，调用原始的toString方法  不检查整个原型链
 ```
<script>
	//[object class]: class-Array Date Object
	//只能检查最初就是数组创建的对象。
	console.log(Object.prototype.toString.call([]) == "[object Array]" ? "是数组" : "不是数组");  // 是
	console.log(Object.prototype.toString.call({}));
	console.log(Object.prototype.toString.call(function() {}));
	console.log(Object.prototype.toString.call(/\d/));
	var father = {};
	var son = {};
	father.__proto__ = Array.prototype;
	son.__proto__ = father;
	console.log(Object.prototype.toString.call(son) == "[object Array]" ? "是数组" : "不是数组"); //不是
	//结论: 对象一旦创建，class属性就无法修改
	//修改继承关系，也无法修改class属性
</script>
```
(6) Array.isArray(obj)  不检查整个原型链
```
<script>
	console.log(Array.isArray([]));  // true
	console.log(Array.isArray({}));  // false
	//如果浏览器不支持isArray
	if (Array.prototype.isArray === undefined) { //if(!Array.isArray)
		//给?添加isArray方法
		Array.prototype.isArray = function(arg) {
			//强行调用原始toString方法，和"[object Array]"比较
			return Object.prototype.toString.call(arg) == "[object Array]" ? "是数组" : "不是数组";
		}
	}
</script>
```

### 53. 自定义Object.create()

```
<script>
	Object.create = function(father, props) {
		// 使用setPrototypeOf方法
		// var o = Object(); //1. 创建空对象
		// Object.setPrototypeOf(o, father); //2. 继承father

		// 不使用setPrototypeOf方法
		function Constructor() {}
		Constructor.prototype = father;
		var o = new Constructor();

		Object.defineProperties(o, props); //3. 定义新属性
		return o;
	}
</script>
```

### 54. Array.every原理

```
<script>
	if (Array.prototype.every === undefined) {
		Array.prototype.every = function(fun) {
			//遍历当前数组中每个元素
			for (var i = 0; i < this.length; i++) {
				if (this[i] !== undefined) {
					//调用fun,依次传入当前元素值,位置i,当前数组作为参数  ，将返回值，保存在变量r中
					var r = fun(this[i], i, this);
					if (r == false) { //如果r为false
						return false; //返回false
					}
				}
			} //(遍历结束)
			return true; //返回true
		}
	}
</script>
```

### 55. Array.some原理

```
<script>
	if (Array.prototype.some === undefined) {
		Array.prototype.some = function(fun) {
			for (var i = 0; i < this.length; i++) {
				if (this[i] !== unefined) {
					var r = fun(this[i], i, this);
					if (r == true) {
						return true;
					}
				}
			}
			return false;
		}
	}
</script>
```

### 56. Array.map原理

```
<script>
	if (Array.prototype.map === undefined) {
		Array.prototype.map = function(fun) {
			//创建空数组: newArr
			var newArr = [];
			//遍历当前数组中每个元素
			for (var i = 0; i < this.length; i++) {
				//如果当前元素不是undefined
				if (this[i] !== undefined) { //判断稀疏数组
					//调用fun传入当前元素值，位置i，当前数组，将结果保存在r中
					//将newArr的i位置赋值为r
					var r = fun(this[i], i, this);
					newArr[i] = r;
				}
			} //(遍历结束)
			return newArr; //返回newArr
		}
	}
</script>
```

### 57. Array.reduce原理

```
<script>
	if (Array.prototype.reduce === undefined) {
		Array.prototype.reduce = function(fun, base) {
			base === undefined && (base = 0);
			for (var i = 0; i < this.length; i++) {
				if (this[i] !== undefined) {
					base = fun(base, this[i], i, this);
				}
			}
			return base;
		}
	}
</script>
```

### 58. bind原理

```
<script>
	if (Function.prototype.bind === undefined) {
		Function.prototype.bind = function(obj /*，参数列表*/ ) {
			var fun = this; //留住this
			//*****将类数组对象，转化为普通数组
			var args = Array.prototype.slice.call(arguments, 1);
			//args保存的就是提前绑定的参数列表
			/*function slice(1){
			   var sub=[];
			   for(var i=0;i<length;i++){
			    sub.push(arguments[i]);
			   }
			   return sub;
			}*/
			return function() {
				//将后传入的参数值，转为普通数组      
				var innerArgs = Array.prototype.slice.call(arguments); //将之前绑定的参数值和新传入的参数值，拼接为完整参数之列表
				var allArgs = args.concat(innerArgs)
					//调用原始函数fun，替换this为obj，传入所有参数
				fun.apply(obj, allArgs);
			}
		}
	}
</script>
```

## 38. 

```
<script>
	
</script>
```


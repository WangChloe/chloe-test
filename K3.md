##12.5

###cookie(数据类型：string)		需要在服务器环境 !important
####1.放在服务器环境中
####2.不安全
####3.过期时间：默认关闭浏览器时清空 session
####  expires 过期时间
延迟三天
var oDate = new Date();
oDate.setDate(oDate.getDate()+3);
document.cookie = 'expires=' + oDate;
####4.容量小 4k
####5.返回的是字符串 eval() !important
####6.内部能访问外部cookie
####  外部不能访问内部cookie
####  -> path统一设置到根目录
####	 document.cookie = 'name=value;path=/';

!update
####7. domain 设置域名访问
#### domain = baidu.com(需在上一级域名设置domain)
baidu.com
fanyi.baidu.com  setCookie
baike.baidu.com  getCookie

####8. 有缓存


###封装cookie.js
function setCookie(name, value, iDay) {
	if(iDay) {
		var oDate = new Date();
		oDate.setDate(oDate.getDate() + iDay);
		document.cookie = name + '=' + value + ';path=/;expires=' + oDate;
		// document.cookie = name + '=' + value + ';path=/;expires=' + oDate + ';domain=localhost';	//!update 设置只能在localhost下setCookie
	} else {
		document.cookie = name + '=' + value + ';path=/';	//!update 关闭浏览器时清空
	}
}

function getCookie(name) {
	var str = document.cookie;
	var arr = str.split('; ');		<!-- 分号后有空格 -->
	for(var i = 0; i < arr.length; i++) {
		var arr2 = arr[i].split('=');
		if(arr2[0] == name) {
			return arr2[1];
		}
	}
	return '';		<!-- 没有对应name即返回空字符串 -->
}

function removeCookie(name) {
	setCookie(name, 'xxx', -10);	//!update -0不能达到清除cookie目的
}

---
###模块化
####sea.js
####采用CMD(同步)

####require.js
####采用AMD(异步)
www.requirejs.cn
好处：1.解决命名冲突
	  2.解决文件彼此依赖
	  3.自动引入js

####异步加载，可维护性高，只发送一个请求，最终引用文件命名为init.js
####				或者<script src="require.js" data-main="init"></script>
####因专用于js，引用时可省略文件名后缀.js
示例：
1.
define(funtion() {
	console.log(1);
})

require(['js/1.js']);	//注意路径

2.
define(function() {
	return {a:1, b:2};
})
require(['js/1.js'], function(json) {
	console.log(json.b);
})

3.
define(['js/2.js'], function(a) {
	return a;
})

require(['js/1.js'], function(b) {
	console.log(b);
})

4.
define(function(require) {
	var mod1 = require('js/1');
	return {
		a:mod1,
		b:2
	}
})
####1.定义模块
define(function(require, exports, module) {
	//引入模块，导出模块，批量导出(一般不用)
	exports.a = 1;
});

####2.使用模块
require(['1.js'], function(mod) {	//可不写函数
	console.log(mod.a);	 //1
})

require(['1.js', '2.js']), function(mod1, mod2) {

})

####3.引用模块
define(function(require, exports, module) {
	var mod1 = require('1.js');
	var mod2 = require('2.js');
	exports.sum = function() {
		return mod1.a + mod2.b;
	}
});

---
###数据交互
####1.form 提交数据	缺点：1.会刷新页面  2.不能取出数据
####2.ajax (Asynchronous JavaScript and XML)	需要在服务器环境  !important
####	(1)取出的是字符串	需要eval(data)  若为json需eval('('+data+')')
####	(2)编码要一致
####	(3)url若为文件名，不关心文件名的后缀
####	(4)缓存(get方法)
####			清除缓存 ctrl + F5  ctrl+alt+delete
####			防止IE缓存 路径+随机因子  '
####				路径?t='+oDate.getTime()
####				t=Math.random();或者t=oDate.getTime();
ajax.js
调用
ajax(url, function(data){
	//成功的回调函数
	//数据data
},function(){
	//失败的回调函数
});

###XML	可扩展标记语言(数据格式)	用处：传输、存储数据	现在json更普遍


##12.6

###eval的替代用法
function eval2(str) {
	var fn = new Function('return' + str);
	return fn();
}
---
``` javascript
var URL = 'user.php?act=login&user=' + logU.value + '&pass=' + logP.value + '&t=' + new Date().getTime();
```
###注册登录输入中文问题
####IE兼容写法：
####中文需转换URL编码 encodeURIComponent(str)
####解编码：decodeURIComponent(str)
``` javascript
var URL = 'user.php?act=login&user=' + encodeURIComponent(logU.value) + '&pass=' + encodeURIComponent(logP.value) + '&t=' + new Date().getTime();
```

---
###ajax.js
####XMLHttpRequest
####    兼容：除IE6
####	IE6：报错
####readyState
- 0 uninitialized ajax对象创建成功
- 1	loading	打开连接(已经建立连接)
- 2 loaded 发送数据
- 3 interactive 下载内容
- 4 complete 完成

####HTTP状态码
- 200 ok
- 304 not modified
- 403 Forbidden
- 404 not found
- 405 Not allowed
- 414 Request-URI Too Long
- 500 Internal Server Error
- 502 Bad Gateway

``` javascript
function ajax(url, data, fnSucc, fnError) {	//data 数据格式为json

	// 1.获得ajax
	if(window.XMLHttpRequest){	//查看当前浏览器XMLHttpRequest是否是全局变量
		var oAjax = new XMLHttpResquest();
	} else {
		var oAjax = new ActiveXObject('Microsoft.XMLHTTP');	//IE6,传入微软参数
	}

	// 2.打开地址
	oAjax.open('GET', url, true);	//提交方式(大写)，url，是否异步

	// 3.发送
	oAjax.send();

	// 4.接收数据
	oAjax.onreadystatechange = function() {	//监控状态
		if(oAjax.readyState == 4) {
			if(oAjax.readyState == 4) {
				if(oAjax.status >= 200 && oAjax.status < 300 || 
					oAjax.status == 304) {
						fnSucc && fnSucc(oAjax.responseText);	//执行成功的回调函数, responseText为响应内容
				} else {
					fnError && fnError(oAjax.status);		//执行失败的回调函数
				}
			}
		}
	}
}

function jsonToUrl(json) {
	var arr = [];
	for(var name in json) {
		arr.push(name + '=' + json[name]);
	}
	return arr.join('&');
}

```

##12.7

###Ajax提交方式
####GET	 数据在open提交
####		载体：url
####POST 数据在send提交
####		载体：请求头
####		oAjax.open('POST', url, true);
####		//设置请求头
####		oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
####		oAjax.send('a=1&b=2');

```

function ajax(json) {
	//url, data, type, success, error, time, loading, complete
	//路径, 数据, 方式, 成功回调函数, 失败回调函数, 超时时间, 等待函数，ajax完成后执行的函数
	json = json || {};
    if(!json.url){
        console.log('url is null');
        return;
    }
	json.data = json.data || {};
	json.type = json.type || 'get';
	json.time = json.time || 3000;

	var timer = null;
	clearTimeout(timer);

	if (window.XMLHttpRequest) {
		var oAjax = new XMLHttpRequest();
	} else {
		var oAjax = new ActiveXObject("Microsoft.XMLHTTP");
	}

	switch (json.type.toLowerCase()) {
		case 'get':
			oAjax.open('GET', json.url + '?' + jsonToURL(json.data), true);
			oAjax.send();
			break;
		case 'post':
			oAjax.open('POST', json.url, true);
			oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			oAjax.send(jsonToURL(json.data));
			break;
	}

	json.loading && json.loading();
	oAjax.onreadystatechange = function() {
		if (oAjax.readyState == 4) {
			json.complete && json.complete();
			if (oAjax.status >= 200 && oAjax.status < 300 ||
				oAjax.status == 304) {
				json.success && json.success(oAjax.responseText);
			} else {
				json.error && json.error(oAjax.status);
			}
			clearTimeout(timer);
		}
	};

	timer = null;
	timer = setTimeout(function() {
		console.log('请求超时');
		oAjax.onreadystatechange = null;
	}, json.time);
}

function jsonToURL(json) {
	var arr = [];
	for (var name in json) {
		arr.push(name + '=' + json[name]);
	}
	return arr.join('&');
}

```

###网络超时
```
var timer = null;
timer = setTimeout(function() {
	console.log('请求超时');
	oAjax.onreadystatechange = null;
}, json.time);

```

###loading

##12.8

###ajax服务器相关
####oAjax.getAllResponseHeaders();  获取ajax服务器全部信息
####oAjax.getResponseHeader('xxx');	获取ajax服务器相关信息

###ajax2.0事件
####oAjax.onload 	替代	oAjax.onreadystatechange
####oAjax.onerror   发生错误
####                网络层级的错误才会触发
####oAjax.onprogress 上传进度
####       ev.loaded/ev.total
####oAjax.onabort   中断

###ajax跨域
####ajax只能同域名下取数据，同源策略
####跨域需使用jsonp(json width padding)

###应用：刷新保留分页页码
####1.cookie 4k
####2.锚点hash
```

var hash = window.location.hash;
var index = hash.substring(1);
if (hash) {
    tab(index - 1);
}
for (var i = 0; i < aA.length; i++) {
    aA[i].index = i;
    aA[i].onclick = function() {
        var index = this.index;
        tab(index);
        window.location.hash = '#' + (this.index + 1);
    };
}

```

##12.9

###ajax跨域
####ajax只能同域名下取数据，同源策略
####跨域需使用jsonp(json width padding)

###jsonp原理
####动态创建script标签，利用script:src属性可以跨域
####不需要服务器环境 !important

###坑：预解析例子
####变量和函数的定义会预先解析,解析在script标签内的最上面
####作用域：(1)script (2)函数
eg:
var a = 111;
function show() {
	alert(a);		//相当于var a;
	var a = 12;		//		alert(a);
					//		a = 12;
}
show();	//返回undefined

eg:
<script>show(12)</script>	//show is not defined
<script>
	//函数预解析在该script标签最上面
	function show(12) {
		alert(a);
	}
</script>

###jsonp接口网址
www.asilu.com

###jsonp.js封装
``` javascript
<script>
	function jsonp(json) {
	// url, data, cbName, success
	//路径，参数，回调函数名字，回调函数
	json = json || {};
	if(!json.url) {
		return;
	}
	json.data = json.data || {};
	json.cbName = json.cbName || 'cb';

	var fnName = 'jsonp_' + Math.random();
	fnName = fnName.replace('.', '');

	//全局函数防止与外部函数jsonp()重名
	window[fnName] = function(json2) {
		json.success && json.success(json2);
		oHead.removeChild(oS);
	};
	json.data[json.cbName] = fnName;2
	var arr = [];
	for(var name in json.data) {
		arr.push(name + '=' + json.data[name]);
	}
	var oS = document.createElement('script');
	var oHead = document.getElementsByTagName('head')[0];
	oS.src = json.url + '?' + arr.join('&');
	oHead.appendChild(oS);
}
</script>

```

##12.12

周磊
QQ：1171984509
微信：15811109684
手机：17600186896

###ajax
####Fetch

###服务器环境
####php: wamp(集成环境)
####asp.net: IIS
####java: tomcat

###cookie(数据类型：string)		需要在服务器环境 !important
####1.放在服务器环境中
####2.不安全
####3.过期时间：默认关闭浏览器时清空 session
####  expires 过期时间
延迟三天
var oDate = new Date();
oDate.setDate(oDate.getDate()+3);
document.cookie = 'expires=' + oDate;
####4.容量小 4k
####5.返回的是字符串 eval() !important
####6.内部能访问外部cookie
####  外部不能访问内部cookie
####  -> path统一设置到根目录
####	 document.cookie = 'name=value;path=/';

!update
####7. domain 设置域名访问
#### domain = baidu.com(需在上一级域名设置domain)
baidu.com
fanyi.baidu.com  setCookie
baike.baidu.com  getCookie

####8. 有缓存


###封装cookie.js
function setCookie(name, value, iDay) {
	if(iDay) {
		var oDate = new Date();
		oDate.setDate(oDate.getDate() + iDay);
		document.cookie = name + '=' + value + ';path=/;expires=' + oDate;
		// document.cookie = name + '=' + value + ';path=/;expires=' + oDate + ';domain=localhost';	//!update 设置只能在localhost下setCookie
	} else {
		document.cookie = name + '=' + value + ';path=/';	//!update 关闭浏览器时清空
	}
}

function getCookie(name) {
	var str = document.cookie;
	var arr = str.split('; ');		<!-- 分号后有空格 -->
	for(var i = 0; i < arr.length; i++) {
		var arr2 = arr[i].split('=');
		if(arr2[0] == name) {
			return arr2[1];
		}
	}
	return '';		<!-- 没有对应name即返回空字符串 -->
}

function removeCookie(name) {
	setCookie(name, 'xxx', -10);	//!update -0不能达到清除cookie目的
}

---
###模块化
####sea.js
####采用CMD(同步)

####require.js
####采用AMD(异步)
www.requirejs.cn
好处：1.解决命名冲突
	  2.解决文件彼此依赖
	  3.自动引入js

####异步加载，可维护性高，只发送一个请求，最终引用文件命名为init.js
####				或者<script src="require.js" data-main="init"></script>
####因专用于js，引用时可省略文件名后缀.js
示例：
1.
define(funtion() {
	console.log(1);
})

require(['js/1.js']);	//注意路径

2.
define(function() {
	return {a:1, b:2};
})
require(['js/1.js'], function(json) {
	console.log(json.b);
})

3.
define(['js/2.js'], function(a) {
	return a;
})

require(['js/1.js'], function(b) {
	console.log(b);
})

4.
define(function(require) {
	var mod1 = require('js/1');
	return {
		a:mod1,
		b:2
	}
})
####1.定义模块
define(function(require, exports, module) {
	//引入模块，导出模块，批量导出(一般不用)
	exports.a = 1;
});

####2.使用模块
require(['1.js'], function(mod) {	//可不写函数
	console.log(mod.a);	 //1
})

require(['1.js', '2.js']), function(mod1, mod2) {

})

####3.引用模块
define(function(require, exports, module) {
	var mod1 = require('1.js');
	var mod2 = require('2.js');
	exports.sum = function() {
		return mod1.a + mod2.b;
	}
});

##12.13

###jQuery
		 		jquery					js
onload 		 $(function() {});	window.onload = function(){};
获取元素         $('div');   document.getElementsByTagName('div');
事件   		 	click(fn);  		onclick = fn;
this    		$(this)					this
索引    	$(this).index()       aDiv[i].index=i;...
操作属性	1. 获取attr(name)				(1) . (2) []  (3) getAttribute()
			2. 设置attr(name, value)
####jQuery方法
.hide();		// 隐藏
.show();		// 显示
.slideDown(); 	// 下滑
.slideUp();		// 上滑
.fadeIn();		// 淡入
.fadeOut();		// 淡出

参数：time时间，easing运动方式，fn回调函数

.animate(params, [speed], [easing], fn);

.animate({width: '100px', opacity: 1}, 'slow', {duration: 1000, easing: 'linear', complete: function() {

}})

animate记得清除定时器
$('ul').stop().animate(...);

####jQuery选择器
1. 伪类选择器
$('li:first');	第一个
$('li:last');	最后一个
$('li:eq(n)');	第n+1个
$('li:odd');	第奇数个
$('li:even');	第偶数个
$('li:contains(xxx)');  包含文本xxx的li标签
$('li:has(p)');	包含p标签的li标签

2. 属性选择器
$('input[type==password]');

####jQuery操作CSS属性
获取  .css('name');

设置
单一样式  .css('name', 'value');
多个样式  .css({'name': 'value', 'name2': 'value2'});
			eg: .css('background-color': 'red');
			或者.css('backgroundColor': 'red');

####jQuery操作内容
非表单  获取  .html();		//innerHTML
		设置  .html('xxx');
表单    获取  .val();		//value
		设置  .val('xxx');

####jQuery操作类名
添加	addClass('xxx');
删除	removeClass('xxx');

####jQuery操作属性
获取  attr(name)

设置
单一属性  attr('name', 'value');
多个属性  attr({'name': 'value', 'name2': 'value2'});

##12.14

###拓展
模拟数据 mock.js
http://www.webhek.com/
17素材

###jQuery DOM

####创建元素
$('<div>text</div>');

####添加元素
append()    parent.append(child);		父级添加子级至末尾
appendTo()  child.appendTo(parent);     子级追加至父级末尾

prepend()   parent.prepend(child);      父级添加子级至最前
prependTo() child.prependTo(parent);    子级追加至父级最前

before()    sib1.before(sib2)           sib2添加至同级sib1前面
after()     sib1.after(sib2)            sib2添加至同级sib1后面

insertBefore()    sib1.insertBefore(sib2)           sib1添加至同级sib2前面
insertAfter()     sib1.insertAfter(sib2)            sib1添加至同级sib2后面

wrap()      child.wrap(parent);		   子元素被父元素包裹
unwrap()    child.unwrap();			   子元素移出上级父元素

####删除元素
remove()    obj.remove();    			删除obj节点
empty()     obj.empty();                删除obj内所有子节点
detach     $('p').detach();   			删除所有p标签及其中内容
		   $('p').detach('.hello'); 	删除所有类为hello的p标签及其中内容

###jQuery 事件
jQuery中所有事件都是绑定的

change()
click()
dblclick()    双击dbl
contextmenu() 右击
hover()
mouseover()
mouseout()
mousedown()
mouseup()
mousewheel	 鼠标滚轮 //jQuery没有封装这个函数，需用on事件绑定
keydown()
keypress()
keyup()


>最好不用jQuery封装的方法，都用on事件绑定

hover(over, out)可以绑定两个方法
obj.hover(function() {
	// 移入
}, function() {
	// 移出
})


绑定 on()
解绑 off()

委托
第一种方法  .on(events, selector, callback);
			eg:$('table td').on('hover', function() {
				$(this).toggleClass("active");
			})
			eg:$('table').on('hover', 'td', function() {
				$(this).toggleClass("active");
			})
第二种方法  .delegate()
			eg:$("table").delegate("td", "hover", function(){
			 	$(this).toggleClass("active");
			});
// bind() unbind()  不常用
// live() die()     jQuery 1.7+被删除

####阻止默认事件、阻止冒泡
return false;

####阻止默认事件
ev.preventDefault();

####阻止冒泡
ev.stopPropagation();

###jQuery 获取物体信息
js
obj.offsetWidth
obj.offsetHeight
obj.offsetLeft
obj.offsetTop

jq(只封装了以下方法)
//js处理小数较弱，取出时取整Math.round()
obj.width();	  // 纯width
obj.height();	  // 纯height
obj.outerWidth(); // 盒子模型的width  (width+padding+border)  offsetWidth
obj.outerHeight();// 盒子模型的height (height+padding+border) offsetHeight

obj.position().left; // 距离定位父级left值 offsetLeft  不包括margin
obj.position().top;	 // 距离定位父级top值 offsetTop    不包括margin

obj.offset().left;   // 包括margin
obj.offset().top;    // 包括margin

obj.scrollTop();  	 // 元素相对滚动条顶部的偏移
obj.scrollLeft();  	 // 元素相对滚动条左侧的偏移

父级：
parent();		// 结构上的父级
offsetParent(); // 定位上的父级

###jQuery 筛选
####过滤
.eq(index);   
	当参数大于等于0时为正向选取，比如0代表第一个，1代表第二个。当参数为负数时为反向选取，比如-1为倒数第一个
.first();
.last();
.hasClass(className);


###查找
.find(tagName/className/id);	eg:oBox.find('ol li');


###原生js转jquery对象
$()包裹
this -> $(this)
document -> $(document)

var oDiv = document.getElementById('div1');
->
$(oDiv).html('xxx');

###jquery转原生js对象
[] / get()
$('div')[0].innerHTML = 'xxx';
$('div').get(0).innerHTML = 'xxx';

###jQuery链式运动
.css().html().attr().click();

###jQuery循环
eg:
$("div").each(function (index,element) {	//索引，当前元素
 	console.log($(element).html());		// element是原生对象，需转成jq对象
 	$(this);	//当前对象
});

###jQuery工具
$.trim(str);		// 去掉字符串起始和结尾的空格
$.browser.version;	// 浏览器版本

eg:if($.browse.version.substring(0, 1) == '6') {} //判断是否是IE6

###jQuery Ajax
$.ajax({
	url: URL,
	data: {},
	type: 'get',
	error: fn,
	complete: fn,
	time: 3000;
	success: function(str) {
		console.log(str);
	}
})

###jQuery jsonp
$.ajax({
	url: URL,
	data: {},
	dataType: 'jsonp',
	cbName: 'callback',
	success: function(json) {
		console.log(json);
	}
});

##12.15

###写插件
$:jq
fn:帮助

####jq里面除了插件里的this以外，其他都是原生的js

####一个插件
$.fn.插件名 = function() {
	this.css('name', 'value');	// 插件中的this不用加$
}
$('div').插件名();

####一组插件
$.fn.extend({
	插件名1: function() {
		this.css('name', 'value');
	},
	插件名2: function() {
		this.css('name', 'value');
	}
})

插件调用不能用链式 !important

$('div').插件名1();
$('div').插件名2();

###html/css/js压缩
YUI Compressor

###正则
处理字符串

####RegExp对象
var reg = new RegExp('字符串', [选项]);  (可选选项)

选项：
i ignore 忽略大小写
g global 全局匹配
m 		 多行匹配

#####字符串为正则表达式时，不能用选项，直接在正则表达式//后增加选项

str.search('w') 找到w返回下标，没找到返回-1
str.match('w');	匹配w  成功返回匹配的w，否则返回null
	返回值类型：数组(object)

转义：
\n 换行符
\d 数字   digital  (不认识小数)
\\ \	  eg: \\\\\ -> \\  会报错

var reg = /\d/; -> 选项 /\d/g; -> 匹配一次或多次 -> /\d+/g


##12.16

###正则
处理字符串

####RegExp对象
var reg = new RegExp('字符串', [选项]);  (可选选项)

选项：(可选多个)
i ignore 		忽略大小写
m multi-line	多行匹配
g global 		全局匹配

>字符串为正则表达式时，不能用选项，直接在正则表达式//后增加选项

####正则定义
1. var a = 'aaa';
   var reg = new RegExp(a, 'g');	// 正则可以使用变量形式
2. var reg = /\d+/g;				// 正则不可以使用变量形式
3. str.replace(/\d/g, '');


####正则校验
reg.test(str);
true -> 校验通过
false -> 校验不通过

####正则使用的字符串相关方法
str.search('w')  		找到w返回下标，没找到返回-1
str.match('w');	 		匹配w  成功返回匹配的w，否则返回null
			     		返回值类型：数组(object)
str.replace('xxx', 'yyy');  被替换内容,替换内容  (注意该方法要重新声明)
	eg:var str = 'aaa';  str = str.replace('a', 'b'); -> 'baa'
str.replace('xxx', function(s){
	console.log(s);	//被替换字符，数据类型：string
	var star = '';
	for(var i = 0; i < s.length; i++) {
		star += '*';
	}
	return star;	//替换内容
})

####转义字符：
\\ \	  eg: \\\\\ -> \\  会报错
\n 			 换行符
\r			 回车符
\f			 换页符
\d  digital  数字(不认识小数) [0-9]
\w  word	 单词(包括下划线) [A-Za-z0-9_]
\s  space    空白字符

\D           非数字			  [^0-9]
\W           非单词           [^A-Za-z0-9_]
\S			 非空白字符

var reg = /\d/; -> 选项 /\d/g; -> 匹配一次或多次 -> /\d+/g

####特殊字符
. 	 匹配任何单字符(除换行符\n)
^ 	 匹配开始位置
		不选m，匹配字符串的开始位置
		选m，  识别字符串的换行，并匹配字符串每行的开始位置
$ 	 匹配结束位置
()   标记子表达式
[] 	 标记元字符表达式
{}   标记限定符表达式

####限定符
{n}  匹配n个
{n,} 最少匹配n个
{,m} 最多匹配m个
{n, m} 最少匹配n个，最多匹配m个   n,m为非负整数(n<=m)

*    匹配{0,}  eg:'zo*' -> 'z'及'zo'、'zoooooo'
+ 	 匹配{1,}  eg:'zo+' -> 'zo'及'zoo'、'zoooooo'
?    匹配{0,1} eg:'do(es)?' -> 'do'或'does'

####元字符(一个字符)
[abc]    字符集合 -> /a|b|c/
[^abc]   负值字符集合 -> 除了abc
[0-9]    字符范围 -> /0|1|2|3|4|5|6|7|8|9/	eg:[1-29] -> [1-2]或者[1-9]
[^0-9]   负值字符范围 -> 非数字

####示例
/\d+/    一串数字
/\d\d+/  最少2个才能匹配
/.+/     任意多个
/.*/     可有可无

#####应用：校验座机号码
021-8888888
0791-88888888
区号-：(0[1-9]\d{1,2}-)?	3/4位数字 首位数字为0、第二位非0  区号-可有可无
号码：[1-9]\d{6,7}          7/8位数字 首位数字非0

/^(0[1-9]\d{1,2}-)?[1-9]\d{6,7}$/

#####应用：校验邮箱
wangchloe@yeah.net
123123123@163.com.cn
用户名 + @ + 域名 +      . + 后缀
\w+      @   [a-z0-9-]+  (\. [a-z]{2,8}){1,2}

/^\w+@[a-z0-9-]+(\. [a-z]{2,8}){1,2}$/

#####应用：校验年龄 18-100
18-19  20-99  100
1[89]|[2-9]\d|100

/^1[89]|[2-9]\d|100$/
^优先级比|高,会先执行^1[89]和100$  并且^与超过两个|同时出现就会错乱，需要加括号包裹多个条件，提升优先级

/^(1[89]|[2-9]\d|100)$/

#####应用：trim()去除首尾空格
去首空格
^\s+

去尾空格
\s+$

去掉 开头为空格 或者 空格为结尾
/^\s+|\s+$/

#####应用：校验名字
str.fromCharCode('0x4e00')	第一个中文 	 0x4e00 一
								最后一个中文 0x9fa5	龥(yu)

unicode编码：统一编码 utf-8 utf-16 utf-32	以\u开头 \u4e00(一) ~ \u9fa5(龥)

GB2312编码

utf-8统称：unicode

两个到七个汉字
/^[\u4e00-\u9fa5]{2,7}$/

#####应用：首字母大写
var str = 'welcome to china';

str.replace(/\w+/g, function(s) {
	return s.charAt(0).toUpperCase() + s.substring(1);
})

#####应用：过滤html的标签
var str = oBox.innerHTML;
var str2 = str.replace(/<[^>]+>/g, '');
console.log(str2);

##12.19

###正则
####单词边界
找确定单词时加单词边界 \b 在正则中需转义 \\b

var reg = new RegExp('\\bAAA\\b');

####正则getByClass等方法
``` javascript
<script>
	function getByClass(oParent,sClass){
	if (oParent.getElementsByClassName) {
		return oParent.getElementsByClassName(sClass);
	} else{
		var arr=[];
		var aEle=oParent.getElementsByTagName('*');
		var reg=new RegExp('\\b'+sClass+'\\b');
		for (var i = 0; i < aEle.length; i++) {
			if(reg.test(aEle[i].className)){
				arr.push(aEle[i]);
			}
		}
		return arr;
	}
};
function hasClass(obj,sClass){
	var reg=new RegExp('\\b'+sClass+'\\b');
	return reg.test(obj.className);
};
function addClass(obj,sClass){
	if(obj.className){
		if(!hasClass(obj,sClass)){
			obj.className+=' '+sClass;
		}
	}else{
		obj.className=sClass;
	}
};
function removeClass(obj,sClass){
	var reg=new RegExp('\\b'+sClass+'\\b');
	if(hasClass(obj,sClass)){
		obj.className=obj.className.replace(reg,'').replace(/\s+/g,' ').replace(/^\s+|\s+$/,'');
		//obj.className=obj.className.replace(reg,'').replace(/^\s+/g,'');
	}
};
</script>
```

###性能优化
####垃圾回收 GC(Gabage Collection)
js中的垃圾回收：(宿主环境)
浏览器会自动回收垃圾

底层语言不会自动回收垃圾

垃圾的评判标准:生存周期

生存周期：作用域
1. 全局变量，生存周期长，直到浏览器关闭时清除  占资源
2. 局部变量，生存周期短，方法调用完即清除
3. 闭包(子函数可以使用父函数的局部变量)
	子函数若没有释放，整条作用域链上的局部变量都会保留
	作用域链：从内一级一级往外找，直到全局

``` javascript
<script>
	// 作用域链
	function show1() {
		var a = 12;
		function show2() {
			var b = 1;
			function show3() {
				var c = 2;
				document.onclick = function() {
					var d = 3;
					alert(a);
				}
			}
			show3();
		}
		show2();
	}

	show1();
</script>
```

####递归(函数自己调用自己)
核心思想：把一个大问题，拆成一个一个小问题，逐个解决

数列：斐波那契数列(Fibonacci sequence)

``` javascript
<script>
	var arr=[];
	function fn(n){		// n为当前月份
		if(n<=2){
			return 1;
		}else{
			if(arr[n]){
				return arr[n];
			}else{
				arr[n]=fn(n-1)+fn(n-2);
				return arr[n];	// 返回截止当前月份的总数
			}
		}
	}
</script>
```

##12.20

###性能优化

####js

项目：1.稳定性
	  2.可维护性
	  3.性能优化

性能：1.执行性能
	  2.网络性能

#####执行性能
1. 不用的东西删除
2. 尽量不用全局变量 命名冲突，耗资源
3. 能用系统自带的一定不用自己写的 getByClass
4. 尽量使用正则操作字符串

DOM操作耗性能，尽量减少DOM操作
属性用的越多，性能越低
DOM操作：
全局变量：
局部变量：
属性：
json：
数组arr.length存与不存：差不多

Math.floor比parseInt快
变量性能消耗：属性>全局变量>局部变量


#####网络性能
######查看性能 F12 -> network
Status 状态码
Type  资源类型
	主类型/次类型
	text/html
	text/css
	image/png/gif
Initiator 发起人
Size 资源大小
Time 请求耗时
Timeline 时间轴
	Queueing 排队
	Stalled  停滞
	Request sent 请求发送
	Waiting 等待
	Content Download 内容下载

######工具：
FF -> firebug -> yslow(网站评分)
Chrome -> Audits(查看网站性能)

#####网络性能提升方法
1.减少http请求：
	js -> 合并
	css -> 合并
	图片 -> css sprites
2.http请求越小越好
	压缩
	1. 工具 开源中国工具
	2. 前端自动化工具
3.图片延迟加载
4.CDN(Content Delivery Network, 内容分发网络)加速
5.阻塞加载
- 非阻塞加载(异步加载，并行加载)
css、html、图片
- 阻塞加载(同步加载)
js
解决：引用其他网站的js放在body最后

###面向对象
面向对象：只管用，不用管内部实现
对象组成：1.属性(变量)	2.方法(函数)

this: 当前方法属于谁，this就是谁
**this默认属于window**

####严格模式
'use strict';	IE6不识别但不报错
好处：
1. 修复局部this的问题
2. 不允许if/while/for里面定义函数
3. 去掉了with(){}
4. 定义变量必须加var

作用范围：
1. 最大不出script标签
2. 放在哪就作用在哪

坑
``` javascript
<script>
	var a = 5;  // 单数
	if(a % 2) {
		function show() {
			alert('单数');
		}
	} else {
		function show() {
			alert('双数');
		}
	}
	show();	// 单数 最新版高级浏览器中预解析不会覆盖，之前版本预解析后此例预解析覆盖 弹出双数
</script>
```

``` javascript
<script>
	'use strict';
	var a = 5;
	if(a % 2) {
		function show() {
			alert('单数');
		}
	} else {
		function show() {
			alert('双数');
		}
	}
	show();	// show is not defined，严格模式不允许if/for里面定义函数
</script>
```

####系统内置对象
Array Json RegExp Date

####构造函数
函数名首字母大写 -> 区分普通函数

#####工厂模式
``` javascript
<script>
	function CreateObject(name, age) {
		// 1.原料
		var obj = new Object();

		// 2.加工
		// 属性
		obj.name = name;
		obj.age = age;
		// 方法
		obj.getName = function() {
			return this.name;
		}
		obj.getAge = function() {
			return this.age;
		}

		// 3.出厂
		return obj;
	}

	var p = CreateObject('x', 11);
	alert(p.getName());
</script>
```

##12.21

###面向对象

####构造函数
``` javascript
<script>
	function CreateObject(name, age) {
		// 1.原料
		// var obj = new Object();

		// 2.加工
		// 属性
		this.name = name;
		this.age = age;
		// 方法
		this.getName = function() {
			return this.name;
		}
		this.getAge = function() {
			return this.age;
		}

		// 3.出厂
		//return obj;

		// 自动返回this
	}

	var p = new CreateObject('x', 11);	// 创建对象，并赋值给this
	alert(p.getName());
</script>
```

####关于new
1. 创建一个空对象，并赋值给this
2. 返回this

``` javascript
<script>
	function show() {
		alert(this);
	}
	new show();	// object
</script>
```

####原型及原型链

``` javascript
<script>
	var arr = [1, 2, 3];
	Array.prototype.sum = function() {
		var sum = 0;
		for(var i = 0; i < this.length; i++) {
			sum += this[i];
		}
		return sum;
	}
	alert(arr.sum());
</script>
```
构造函数+原型

**面向对象**
1. 构造函数添加属性
2. 原型添加方法

``` javascript
<script>
	function CreatePerson(name, age) {
		this.name = name;
		this.age = age;
	}

	CreatePerson.prototype.getName = function() {
		return this.name;
	};

	CreatePerson.prototype.getAge = function() {
		return this.age;
	};

	var p1 = new CreatePerson('a1', 1);
	var p2 = new CreatePerson('a2', 2);
	alert(p1.getName());	// a1
	alert(p2.getName());	// a2
	alert(p1.getName == p2.getName);	// true
</script>
```

#####原型应用
1. 数组arr.indexOf兼容问题

兼容：高级浏览器
IE8- 报错

``` javascript
<script>
	var arr = [1, 2, 3, 4];
	Array.prototype.indexOf = Array.prototype.indexOf || function(item) {	// 如果有indexOf()方法就用系统自带的
		for(var i = 0; i < this.length; i++) {
			if(this[i] == item) {
				return i;
			}
		}

	};

	alert(arr.indexOf(3));
</script>
```

2. 字符串str.trim()兼容问题

兼容：高级浏览器
IE8- 报错

``` javascript
<script>
	var str = '  aaa  ';
	String.prototype.trim = String.prototype.trim || function() {	// 如果有trim()方法就用系统自带的
		return this.replace(/^\s+|\s+$/g, '');
	}
	alert('去空格' + str.trim() + '去空格');
</script>
```

###面向对象
特征：
封装：
继承：子级可以继承父类的一切东西
多态：子级可以继承多个父级

###对象相关方法
####判断是否属于该类型
instanceof
true -> 属于
false -> 不属于
eg: arr instanceof Array;	// true

####查找对象的父级
constructor 查找对象的父级
eg:arr.constructor == Array;	// true

**Json不是一个类型，其父类型就是Object**
alert(json.constructor == Json);    // false
alert(json.constructor == Object);  // true

#坑
``` javascript
<script>
	var arr = [1, 2];
	var json = {};
	var oDate = new Date();

    alert(arr.constructor == Array);    // true
    alert(json.constructor == Json);    // false
    alert(json.constructor == Object);  // true


	alert(typeof oDate);	// object
	alert(oDate instanceof Date);	// true
	alert(typeof Date);	// function
	alert(Date instanceof Function);	// true
	alert(oDate instanceof Function);	// false

	alert(typeof Image);	// function
	alert(Image instanceof Function);	// true

	alert(Function instanceof Object);	// true
	alert(Object instanceof Function);	// true
	alert(Object instanceof Object);	// true
	alert(Function instanceof Function);	// true

	alert(arr instanceof Array);	// true
	alert(Array instanceof Object);	// true
	alert(arr instanceof Object);	// true

	alert(arr instanceof Array);	// true
	alert(Array instanceof Function);	// true
	alert(arr instanceof Function);		// false

    Object.prototype.run = 7;
    var run = 5;
    var arr = [];
    alert(run); // 5
    alert(typeof run);  // number
    alert(run instanceof Number);   // false
    alert(Number instanceof Object);    // true
    alert(Boolean instanceof Object);   // false
    alert(run instanceof Object);   // false
    alert(arr.run); // 7
</script>
```

###关于this

this: 当前方法属于谁，this就是谁
**this默认属于window**

**this的优先级**：
1. new -> object
2. 定时器 -> window
3. 事件 -> 事件对象
4. 方法 -> 方法对象

(多包一层时优先级失效)

``` javascript
<script>
	function show() {
		alert(this);
	}

	var arr = [1, 2];
	arr.show = show();

	document.onclick = arr.show;	// document
	new arr.show();	// object
	new show();	// object
	new document.onclick();	// object

	setTimeout(show, 1000);	// window
	setTimeout(arr.show, 1000);	// window

	setTimeout(new arr.show, 1000);	// object

	var oDate = new Date();
	oDate.show = show;
	document.show = show;
	document.onclick = show;
	setTimeout(function() {		// setTimeout多包一层优先级失效
		oDate.show();	// 时间
		new oDate.show();	// object
		document.show();	// document
		document.onclick();	// document
	}, 100);
</script>
```

###面向对象程序
1. 写一个构造函数
2. 把方法挂在原型上(不能有方法嵌套)
3. 把全局变量变成属性
4. 调整this

``` javascript
<script>
	function ToRed() {
		this.oDiv = document.body.children[0];
		var _this = this;
		// document.onclick = this.fnClick;
		// 上句相当于
		// document.onclick = function() {
		// 	alert(this);	// document
		// 	this.oDiv.style.background = '#f00';	// 当前的this指向document
		// }

		document.onclick = function() {
			_this.fnClick();
		}
	}

	ToRed.prototype.fnClick = function() {
		this.oDiv.style.background = '#f00';
	}

	new ToRed();
</script>
```

###面向对象应用

##12.22

###sublime快捷键
ctrl+shift+d  复制粘贴当前行
ctrl+shift+[  折叠代码
ctrl+shift+]  展开代码
ctrl+shift+v  粘贴并格式化
ctrl+g        跳转到第几行
ctrl+m        跳转到对应括号
ctrl+w        关闭当前文件
ctrl+r 		  前往method
alt+数字      切换至当前窗口的第N个文件
alt+.     	  闭合标签
alt+F3        选中所有相同的词
ctrl+鼠标左键点击 标记多个光标

###面向对象：继承
强制改变this指向

call  改变this指向
call(a);  改变this指向，指向a
call(a, p1, p2);	改变this指向并传参p1, p2

apply 改变this指向
apply(a, [p1, p2]);	改变this指向并传参数数组
apply(a, arguments);改变this指向并传入当前方法的参数数组

####继承
1. 属性的继承
- 父级的构造函数.call(this, 参数1, 参数2, ...);
- 父级的构造函数.apply(this, arguments);

2. 方法的继承
- 子级.prototype = 父级.prototype;	// 引用  子级新方法在前面写会被清空

	问题：子级改了，父级也改了

- for(var name in 父级.prototype) {
	子级.prototype[name] = 父级.prototype[name];	// 循环复制一遍
 }

    问题：子级 instanceof 父级; // false

- 子级.prototype = new 父级的构造函数();
  子级.prototype.constructor = 子级的构造函数;
  (推荐使用)

应用：选项卡(继承)

###单例模式/单体模式(需要重新指定父级)
``` javascript
<script>
	var proson={};
	//加属性
	proson.name='zns';
	//加方法
	proson.showName=function(){
		return this.name;
	};
</script>

```

###原型另一种写法
``` javascript
<script>
	function Person(name, age) {
			this.name = name;
			this.age = age;
		}

	Person.prototype = {
		getName: function() {
			return this.name;
		},
		getAge: function() {
			return this.age;
		},
		constructor: Person		// 需指定父级
	};

	var p1 = new Person('a', 1);
	alert(p1 instanceof Person);	 // true
	alert(p1.constructor == Person); // 若不指定父级，constructor为false
</script>
```
###变量名冲突
1. 封闭空间
	// 自执行函数、闭包
	(function(){})();
	(function(){}());
	~function(){}();	// 加符号为防止报错，不仅是~
2. 面向对象
3. 命名空间
4. 模块化


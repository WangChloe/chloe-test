##12.5

###cookie(数据类型：string)		需要在服务器环境 !important
####1.放在服务器环境中
####2.不安全
####3.过期时间：默认关闭浏览器时清空 session
####  expires 过期时间
延迟三天
var oDate = new Date();
oDate.setDate(oDate.getDate()+3);
document.cookie = 'expires=' + oDate;
####4.容量小 4k
####5.返回的是字符串 eval() !important
####6.内部能访问外部cookie
####  外部不能访问内部cookie
####  -> path统一设置到根目录
####	 document.cookie = 'name=value;path=/';

!update
####7. domain 设置域名访问
#### domain = baidu.com(需在上一级域名设置domain)
baidu.com
fanyi.baidu.com  setCookie
baike.baidu.com  getCookie

####8. 有缓存


###封装cookie.js
function setCookie(name, value, iDay) {
	if(iDay) {
		var oDate = new Date();
		oDate.setDate(oDate.getDate() + iDay);
		document.cookie = name + '=' + value + ';path=/;expires=' + oDate;
		// document.cookie = name + '=' + value + ';path=/;expires=' + oDate + ';domain=localhost';	//!update 设置只能在localhost下setCookie
	} else {
		document.cookie = name + '=' + value + ';path=/';	//!update 关闭浏览器时清空
	}
}

function getCookie(name) {
	var str = document.cookie;
	var arr = str.split('; ');		<!-- 分号后有空格 -->
	for(var i = 0; i < arr.length; i++) {
		var arr2 = arr[i].split('=');
		if(arr2[0] == name) {
			return arr2[1];
		}
	}
	return '';		<!-- 没有对应name即返回空字符串 -->
}

function removeCookie(name) {
	setCookie(name, 'xxx', -10);	//!update -0不能达到清除cookie目的
}

---
###模块化
####sea.js
####采用CMD

####require.js
####采用AMD
www.requirejs.cn
好处：1.解决命名冲突
	  2.解决文件彼此依赖
	  3.自动引入js

####异步加载，可维护性高，只发送一个请求，最终引用文件命名为init.js
####				或者<script src="require.js" data-main="init"></script>
####因专用于js，引用时可省略文件名后缀.js
示例：
1.
define(funtion() {
	console.log(1);
})

require(['js/1.js']);	//注意路径

2.
define(function() {
	return {a:1, b:2};
})
require(['js/1.js'], function(json) {
	console.log(json.b);
})

3.
define(['js/2.js'], function(a) {
	return a;
})

require(['js/1.js'], function(b) {
	console.log(b);
})

4.
define(function(require) {
	var mod1 = require('js/1');
	return {
		a:mod1,
		b:2
	}
})
####1.定义模块
define(function(require, exports, module) {
	//引入模块，导出模块，批量导出(一般不用)
	exports.a = 1;
});

####2.使用模块
require(['1.js'], function(mod) {	//可不写函数
	console.log(mod.a);	 //1
})

require(['1.js', '2.js']), function(mod1, mod2) {

})

####3.引用模块
define(function(require, exports, module) {
	var mod1 = require('1.js');
	var mod2 = require('2.js');
	exports.sum = function() {
		return mod1.a + mod2.b;
	}
});

---
###数据交互
####1.form 提交数据	缺点：1.会刷新页面  2.不能取出数据
####2.ajax (Asynchronous JavaScript and XML)	需要在服务器环境  !important
####	(1)取出的是字符串	需要eval(data)  若为json需eval('('+data+')')
####	(2)编码要一致
####	(3)url若为文件名，不关心文件名的后缀
####	(4)缓存(get方法)
####			清除缓存 ctrl + F5  ctrl+alt+delete
####			防止IE缓存 路径+随机因子  '
####				路径?t='+oDate.getTime()
####				t=Math.random();或者t=oDate.getTime();
ajax.js
调用
ajax(url, function(data){
	//成功的回调函数
	//数据data
},function(){
	//失败的回调函数
});

###XML	可扩展标记语言(数据格式)	用处：传输、存储数据	现在json更普遍


##12.6

###eval的替代用法
function eval2(str) {
	var fn = new Function('return' + str);
	return fn();
}
---
``` javascript
var URL = 'user.php?act=login&user=' + logU.value + '&pass=' + logP.value + '&t=' + new Date().getTime();
```
###注册登录输入中文问题
####IE兼容写法：
####中文需转换URL编码 encodeURIComponent(str)
####解编码：decodeURIComponent(str)
``` javascript
var URL = 'user.php?act=login&user=' + encodeURIComponent(logU.value) + '&pass=' + encodeURIComponent(logP.value) + '&t=' + new Date().getTime();
```

---
###ajax.js
####XMLHttpRequest
####    兼容：除IE6
####	IE6：报错
####readyState
- 0 uninitialized ajax对象创建成功
- 1	loading	打开连接(已经建立连接)
- 2 loaded 发送数据
- 3 interactive 下载内容
- 4 complete 完成

####HTTP状态码
- 200 ok
- 304 not modified
- 403 Forbidden
- 404 not found
- 405 Not allowed
- 414 Request-URI Too Long
- 500 Internal Server Error
- 502 Bad Gateway

'100': 'Continue',
'101': 'Switching Protocols',
'102': 'Processing',
'200': 'OK',
'201': 'Created',
'202': 'Accepted',
'203': 'Non-Authoritative Information',
'204': 'No Content',
'205': 'Reset Content',
'206': 'Partial Content',
'207': 'Multi-Status',
'208': 'Already Reported',
'226': 'IM Used',
'300': 'Multiple Choices',
'301': 'Moved Permanently',
'302': 'Found',
'303': 'See Other',
'304': 'Not Modified',
'305': 'Use Proxy',
'307': 'Temporary Redirect',
'308': 'Permanent Redirect',
'400': 'Bad Request',
'401': 'Unauthorized',
'402': 'Payment Required',
'403': 'Forbidden',
'404': 'Not Found',
'405': 'Method Not Allowed',
'406': 'Not Acceptable',
'407': 'Proxy Authentication Required',
'408': 'Request Timeout',
'409': 'Conflict',
'410': 'Gone',
'411': 'Length Required',
'412': 'Precondition Failed',
'413': 'Payload Too Large',
'414': 'URI Too Long',
'415': 'Unsupported Media Type',
'416': 'Range Not Satisfiable',
'417': 'Expectation Failed',
'418': 'I\'m a teapot',
'421': 'Misdirected Request',
'422': 'Unprocessable Entity',
'423': 'Locked',
'424': 'Failed Dependency',
'425': 'Unordered Collection',
'426': 'Upgrade Required',
'428': 'Precondition Required',
'429': 'Too Many Requests',
'431': 'Request Header Fields Too Large',
'451': 'Unavailable For Legal Reasons',
'500': 'Internal Server Error',
'501': 'Not Implemented',
'502': 'Bad Gateway',
'503': 'Service Unavailable',
'504': 'Gateway Timeout',
'505': 'HTTP Version Not Supported',
'506': 'Variant Also Negotiates',
'507': 'Insufficient Storage',
'508': 'Loop Detected',
'509': 'Bandwidth Limit Exceeded',
'510': 'Not Extended',
'511': 'Network Authentication Required'

``` javascript
function ajax(url, data, fnSucc, fnError) {	//data 数据格式为json

	// 1.获得ajax
	if(window.XMLHttpRequest){	//查看当前浏览器XMLHttpRequest是否是全局变量
		var oAjax = new XMLHttpRequest();
	} else {
		var oAjax = new ActiveXObject('Microsoft.XMLHTTP');	//IE6,传入微软参数
	}

	// 2.打开地址
	oAjax.open('GET', url, true);	//提交方式(大写)，url，是否异步

	// 3.发送
	oAjax.send();

	// 4.接收数据
	oAjax.onreadystatechange = function() {	//监控状态
		if(oAjax.readyState == 4) {
			if(oAjax.status >= 200 && oAjax.status < 300 || 
				oAjax.status == 304) {
					fnSucc && fnSucc(oAjax.responseText);	//执行成功的回调函数, responseText为响应内容
			} else {
				fnError && fnError(oAjax.status);		//执行失败的回调函数
			}
		}
	}
}

function jsonToUrl(json) {
	var arr = [];
	for(var name in json) {
		arr.push(name + '=' + json[name]);
	}
	return arr.join('&');
}

```

##12.7

###Ajax提交方式
####GET	 数据在open提交
####		载体：url
####POST 数据在send提交
####		载体：请求头
####		oAjax.open('POST', url, true);
####		//设置请求头
####		oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
####		oAjax.send('a=1&b=2');

```

function ajax(json) {
	//url, data, type, success, error, time, loading, complete
	//路径, 数据, 方式, 成功回调函数, 失败回调函数, 超时时间, 等待函数，ajax完成后执行的函数
	json = json || {};
    if(!json.url){
        console.log('url is null');
        return;
    }
	json.data = json.data || {};
	json.type = json.type || 'get';
	json.time = json.time || 3000;

	var timer = null;
	clearTimeout(timer);

	if (window.XMLHttpRequest) {
		var oAjax = new XMLHttpRequest();
	} else {
		var oAjax = new ActiveXObject("Microsoft.XMLHTTP");
	}

	switch (json.type.toLowerCase()) {
		case 'get':
			oAjax.open('GET', json.url + '?' + jsonToURL(json.data), true);
			oAjax.send();
			break;
		case 'post':
			oAjax.open('POST', json.url, true);
			oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			oAjax.send(jsonToURL(json.data));
			break;
	}

	json.loading && json.loading();
	oAjax.onreadystatechange = function() {
		if (oAjax.readyState == 4) {
			json.complete && json.complete();
			if (oAjax.status >= 200 && oAjax.status < 300 ||
				oAjax.status == 304) {
				json.success && json.success(oAjax.responseText);
			} else {
				json.error && json.error(oAjax.status);
			}
			clearTimeout(timer);
		}
	};

	timer = null;
	timer = setTimeout(function() {
		console.log('请求超时');
		oAjax.onreadystatechange = null;
	}, json.time);
}

function jsonToURL(json) {
	var arr = [];
	for (var name in json) {
		arr.push(name + '=' + json[name]);
	}
	return arr.join('&');
}

```

###网络超时
```
var timer = null;
timer = setTimeout(function() {
	console.log('请求超时');
	oAjax.onreadystatechange = null;
}, json.time);

```

###loading

##12.8

###ajax服务器相关
####oAjax.getAllResponseHeaders();  获取ajax服务器全部信息
####oAjax.getResponseHeader('xxx');	获取ajax服务器相关信息

###ajax2.0事件
####oAjax.onload 	替代	oAjax.onreadystatechange
####oAjax.onerror   发生错误
####                网络层级的错误才会触发
####oAjax.onprogress 上传进度
####       ev.loaded/ev.total
####oAjax.onabort   中断

###ajax跨域
####ajax只能同域名下取数据，同源策略
####跨域需使用jsonp(json width padding)

###应用：刷新保留分页页码
####1.cookie 4k
####2.锚点hash
```

var hash = window.location.hash;
var index = hash.substring(1);
if (hash) {
    tab(index - 1);
}
for (var i = 0; i < aA.length; i++) {
    aA[i].index = i;
    aA[i].onclick = function() {
        var index = this.index;
        tab(index);
        window.location.hash = '#' + (this.index + 1);
    };
}

```

##12.9

###ajax跨域
####ajax只能同域名下取数据，同源策略
####跨域需使用jsonp(json width padding)

###jsonp原理
####动态创建script标签，利用script:src属性可以跨域
####不需要服务器环境 !important

###坑：预解析例子
####变量和函数的定义会预先解析,解析在script标签内的最上面
####作用域：(1)script (2)函数
eg:
var a = 111;
function show() {
	alert(a);		//相当于var a;
	var a = 12;		//		alert(a);
					//		a = 12;
}
show();	//返回undefined

eg:
<script>show(12)</script>	//show is not defined
<script>
	//函数预解析在该script标签最上面
	function show(a) {
		alert(a);
	}
</script>

###jsonp接口网址
www.asilu.com

###jsonp.js封装
``` javascript
<script>
	function jsonp(json) {
	// url, data, cbName, success
	//路径，参数，回调函数名字，回调函数
	json = json || {};
	if(!json.url) {
		return;
	}
	json.data = json.data || {};
	json.cbName = json.cbName || 'cb';

	var fnName = 'jsonp_' + Math.random();
	fnName = fnName.replace('.', '');

	//全局函数防止与外部函数jsonp()重名
	window[fnName] = function(json2) {
		json.success && json.success(json2);
		oHead.removeChild(oS);
	};
	json.data[json.cbName] = fnName;
	var arr = [];
	for(var name in json.data) {
		arr.push(name + '=' + json.data[name]);
	}
	var oS = document.createElement('script');
	var oHead = document.getElementsByTagName('head')[0];
	oS.src = json.url + '?' + arr.join('&');
	oHead.appendChild(oS);
}
</script>

```

##12.12

周磊
QQ：1171984509
微信：15811109684
手机：17600186896

###ajax
####Fetch

###服务器环境
####php: wamp(集成环境)
####asp.net: IIS
####java: tomcat

###cookie(数据类型：string)		需要在服务器环境 !important
####1.放在服务器环境中
####2.不安全
####3.过期时间：默认关闭浏览器时清空 session
####  expires 过期时间
延迟三天
var oDate = new Date();
oDate.setDate(oDate.getDate()+3);
document.cookie = 'expires=' + oDate;
####4.容量小 4k
####5.返回的是字符串 eval() !important
####6.内部能访问外部cookie
####  外部不能访问内部cookie
####  -> path统一设置到根目录
####	 document.cookie = 'name=value;path=/';

!update
####7. domain 设置域名访问
#### domain = baidu.com(需在上一级域名设置domain)
baidu.com
fanyi.baidu.com  setCookie
baike.baidu.com  getCookie

####8. 有缓存


###封装cookie.js
function setCookie(name, value, iDay) {
	if(iDay) {
		var oDate = new Date();
		oDate.setDate(oDate.getDate() + iDay);
		document.cookie = name + '=' + value + ';path=/;expires=' + oDate;
		// document.cookie = name + '=' + value + ';path=/;expires=' + oDate + ';domain=localhost';	//!update 设置只能在localhost下setCookie
	} else {
		document.cookie = name + '=' + value + ';path=/';	//!update 关闭浏览器时清空
	}
}

function getCookie(name) {
	var str = document.cookie;
	var arr = str.split('; ');		<!-- 分号后有空格 -->
	for(var i = 0; i < arr.length; i++) {
		var arr2 = arr[i].split('=');
		if(arr2[0] == name) {
			return arr2[1];
		}
	}
	return '';		<!-- 没有对应name即返回空字符串 -->
}

function removeCookie(name) {
	setCookie(name, 'xxx', -10);	//!update -0不能达到清除cookie目的
}

---
###模块化
####sea.js
####采用CMD(同步)

####require.js
####采用AMD(异步)
www.requirejs.cn
好处：1.解决命名冲突
	  2.解决文件彼此依赖
	  3.自动引入js

####异步加载，可维护性高，只发送一个请求，最终引用文件命名为init.js
####				或者<script src="require.js" data-main="init"></script>
####因专用于js，引用时可省略文件名后缀.js
示例：
1.
define(funtion() {
	console.log(1);
})

require(['js/1.js']);	//注意路径

2.
define(function() {
	return {a:1, b:2};
})
require(['js/1.js'], function(json) {
	console.log(json.b);
})

3.
define(['js/2.js'], function(a) {
	return a;
})

require(['js/1.js'], function(b) {
	console.log(b);
})

4.
define(function(require) {
	var mod1 = require('js/1');
	return {
		a:mod1,
		b:2
	}
})
####1.定义模块
define(function(require, exports, module) {
	//引入模块，导出模块，批量导出(一般不用)
	exports.a = 1;
});

####2.使用模块
require(['1.js'], function(mod) {	//可不写函数
	console.log(mod.a);	 //1
})

require(['1.js', '2.js']), function(mod1, mod2) {

})

####3.引用模块
define(function(require, exports, module) {
	var mod1 = require('1.js');
	var mod2 = require('2.js');
	exports.sum = function() {
		return mod1.a + mod2.b;
	}
});

##12.13


###jQuery
		 		jquery					js
onload 		 $(function() {});	window.onload = function(){};
获取元素         $('div');   document.getElementsByTagName('div');
事件   		 	click(fn);  		onclick = fn;
this    		$(this)					this
索引    	$(this).index()       aDiv[i].index=i;...
操作属性	1. 获取attr(name)				(1) . (2) []  (3) getAttribute()
			2. 设置attr(name, value)
####jQuery方法
.hide();		// 隐藏
.show();		// 显示
.slideDown(); 	// 下滑
.slideUp();		// 上滑
.fadeIn();		// 淡入
.fadeOut();		// 淡出

参数：time时间，easing运动方式，fn回调函数

.animate(params, [speed], [easing], fn);

.animate({width: '100px', opacity: 1}, 'slow', {duration: 1000, easing: 'linear', complete: function() {

}})

animate记得清除定时器
$('ul').stop().animate(...);

####jQuery选择器
1. 伪类选择器
$('li:first');	第一个
$('li:last');	最后一个
$('li:eq(n)');	第n+1个
$('li:odd');	第奇数个
$('li:even');	第偶数个
$('li:contains(xxx)');  包含文本xxx的li标签
$('li:has(p)');	包含p标签的li标签

2. 属性选择器
$('input[type==password]');

####jQuery操作CSS属性
获取  .css('name');

设置
单一样式  .css('name', 'value');
多个样式  .css({'name': 'value', 'name2': 'value2'});
			eg: .css('background-color': 'red');
			或者.css('backgroundColor': 'red');

####jQuery操作内容
非表单  获取  .html();		//innerHTML
		设置  .html('xxx');
表单    获取  .val();		//value
		设置  .val('xxx');

####jQuery操作类名
添加	addClass('xxx');
删除	removeClass('xxx');

####jQuery操作属性
获取  attr(name)

设置
单一属性  attr('name', 'value');
多个属性  attr({'name': 'value', 'name2': 'value2'});

##12.14

###拓展
模拟数据 mock.js
http://www.webhek.com/
17素材

###jQuery DOM

####创建元素
$('<div>text</div>');

####添加元素
append()    parent.append(child);		父级添加子级至末尾
appendTo()  child.appendTo(parent);     子级追加至父级末尾

prepend()   parent.prepend(child);      父级添加子级至最前
prependTo() child.prependTo(parent);    子级追加至父级最前

before()    sib1.before(sib2)           sib2添加至同级sib1前面
after()     sib1.after(sib2)            sib2添加至同级sib1后面

insertBefore()    sib1.insertBefore(sib2)           sib1添加至同级sib2前面
insertAfter()     sib1.insertAfter(sib2)            sib1添加至同级sib2后面

wrap()      child.wrap(parent);		   子元素被父元素包裹
unwrap()    child.unwrap();			   子元素移出上级父元素

####删除元素
remove()    obj.remove();    			删除obj节点
empty()     obj.empty();                删除obj内所有子节点
detach     $('p').detach();   			删除所有p标签及其中内容
		   $('p').detach('.hello'); 	删除所有类为hello的p标签及其中内容

###jQuery 事件
jQuery中所有事件都是绑定的

change()
click()
dblclick()    双击dbl
contextmenu() 右击
hover()
mouseover()
mouseout()
mousedown()
mouseup()
mousewheel	 鼠标滚轮 //jQuery没有封装这个函数，需用on事件绑定
keydown()
keypress()
keyup()


>最好不用jQuery封装的方法，都用on事件绑定

hover(over, out)可以绑定两个方法
obj.hover(function() {
	// 移入
}, function() {
	// 移出
})


绑定 on()
解绑 off()

委托
第一种方法  .on(events, selector, callback);
			eg:$('table td').on('hover', function() {
				$(this).toggleClass("active");
			})
			eg:$('table').on('hover', 'td', function() {
				$(this).toggleClass("active");
			})
第二种方法  .delegate()
			eg:$("table").delegate("td", "hover", function(){
			 	$(this).toggleClass("active");
			});
// bind() unbind()  不常用
// live() die()     jQuery 1.7+被删除

####阻止默认事件、阻止冒泡
return false;

####阻止默认事件
ev.preventDefault();

####阻止冒泡
ev.stopPropagation();

###jQuery 获取物体信息
js
obj.offsetWidth
obj.offsetHeight
obj.offsetLeft
obj.offsetTop

jq(只封装了以下方法)
//js处理小数较弱，取出时取整Math.round()
obj.width();	  // 纯width
obj.height();	  // 纯height
obj.outerWidth(); // 盒子模型的width  (width+padding+border)  offsetWidth
obj.outerHeight();// 盒子模型的height (height+padding+border) offsetHeight

obj.position().left; // 距离定位父级left值 offsetLeft  不包括margin
obj.position().top;	 // 距离定位父级top值 offsetTop    不包括margin

obj.offset().left;   // 包括margin
obj.offset().top;    // 包括margin

obj.scrollTop();  	 // 元素相对滚动条顶部的偏移
obj.scrollLeft();  	 // 元素相对滚动条左侧的偏移

父级：
parent();		// 结构上的父级
offsetParent(); // 定位上的父级

###jQuery 筛选
####过滤
.eq(index);
	当参数大于等于0时为正向选取，比如0代表第一个，1代表第二个。当参数为负数时为反向选取，比如-1为倒数第一个
.first();
.last();
.hasClass(className);


###查找
.find(tagName/className/id);	eg:oBox.find('ol li');


###原生js转jquery对象
$()包裹
this -> $(this)
document -> $(document)

var oDiv = document.getElementById('div1');
->
$(oDiv).html('xxx');

###jquery转原生js对象
[] / get()
$('div')[0].innerHTML = 'xxx';
$('div').get(0).innerHTML = 'xxx';

###jQuery链式运动
.css().html().attr().click();

###jQuery循环
eg:
$("div").each(function (index,element) {	//索引，当前元素
 	console.log($(element).html());		// element是原生对象，需转成jq对象
 	$(this);	//当前对象
});

###jQuery工具
$.trim(str);		// 去掉字符串起始和结尾的空格
$.browser.version;	// 浏览器版本

eg:if($.browse.version.substring(0, 1) == '6') {} //判断是否是IE6

###jQuery Ajax
$.ajax({
	url: URL,
	data: {},
	type: 'get',
	error: fn,
	complete: fn,
	time: 3000;
	success: function(str) {
		console.log(str);
	}
})

###jQuery jsonp
$.ajax({
	url: URL,
	data: {},
	dataType: 'jsonp',
	cbName: 'callback',
	success: function(json) {
		console.log(json);
	}
});

##12.15

###写插件
$:jq
fn:帮助

####jq里面除了插件里的this以外，其他都是原生的js

####一个插件
$.fn.插件名 = function() {
	this.css('name', 'value');	// 插件中的this不用加$
}
$('div').插件名();

####一组插件
$.fn.extend({
	插件名1: function() {
		this.css('name', 'value');
	},
	插件名2: function() {
		this.css('name', 'value');
	}
})

插件调用不能用链式 !important

$('div').插件名1();
$('div').插件名2();

###html/css/js压缩
YUI Compressor

###正则
处理字符串

####RegExp对象
var reg = new RegExp('字符串', [选项]);  (可选选项)

选项：
i ignore 忽略大小写
g global 全局匹配
m 		 多行匹配

#####字符串为正则表达式时，不能用选项，直接在正则表达式//后增加选项

str.search('w') 找到w返回下标，没找到返回-1
str.match('w');	匹配w  成功返回匹配的w，否则返回null
	返回值类型：数组(object)

转义：
\n 换行符
\d 数字   digital  (不认识小数)
\\ \	  eg: \\\\\ -> \\  会报错

var reg = /\d/; -> 选项 /\d/g; -> 匹配一次或多次 -> /\d+/g


##12.16

###正则
处理字符串

####RegExp对象
var reg = new RegExp('字符串', [选项]);  (可选选项)

选项：(可选多个)
i ignore 		忽略大小写
m multi-line	多行匹配
g global 		全局匹配

>字符串为正则表达式时，不能用选项，直接在正则表达式//后增加选项

####正则定义
1. var a = 'aaa';
   var reg = new RegExp(a, 'g');	// 正则可以使用变量形式
2. var reg = /\d+/g;				// 正则不可以使用变量形式
3. str.replace(/\d/g, '');


####正则校验
reg.test(str);
true -> 校验通过
false -> 校验不通过

####正则使用的字符串相关方法
str.search('w')  		找到w返回下标，没找到返回-1
str.match('w');	 		匹配w  成功返回匹配的w，否则返回null
			     		返回值类型：数组(object)
str.replace('xxx', 'yyy');  被替换内容,替换内容  (注意该方法要重新声明)
	eg:var str = 'aaa';  str = str.replace('a', 'b'); -> 'baa'
str.replace('xxx', function(s){
	console.log(s);	//被替换字符，数据类型：string
	var star = '';
	for(var i = 0; i < s.length; i++) {
		star += '*';
	}
	return star;	//替换内容
})

####转义字符：
\\ \	  eg: \\\\\ -> \\  会报错
\n 			 换行符
\r			 回车符
\f			 换页符
\d  digital  数字(不认识小数) [0-9]
\w  word	 单词(包括下划线) [A-Za-z0-9_]
\s  space    空白字符

\D           非数字			  [^0-9]
\W           非单词           [^A-Za-z0-9_]
\S			 非空白字符

var reg = /\d/; -> 选项 /\d/g; -> 匹配一次或多次 -> /\d+/g

####特殊字符
. 	 匹配任何单字符(除换行符\n)
^ 	 匹配开始位置
		不选m，匹配字符串的开始位置
		选m，  识别字符串的换行，并匹配字符串每行的开始位置
$ 	 匹配结束位置
()   标记子表达式
[] 	 标记元字符表达式
{}   标记限定符表达式

####限定符
{n}  匹配n个
{n,} 最少匹配n个
{,m} 最多匹配m个
{n, m} 最少匹配n个，最多匹配m个   n,m为非负整数(n<=m)

*    匹配{0,}  eg:'zo*' -> 'z'及'zo'、'zoooooo'
+ 	 匹配{1,}  eg:'zo+' -> 'zo'及'zoo'、'zoooooo'
?    匹配{0,1} eg:'do(es)?' -> 'do'或'does'

####元字符(一个字符)
[abc]    字符集合 -> /a|b|c/
[^abc]   负值字符集合 -> 除了abc
[0-9]    字符范围 -> /0|1|2|3|4|5|6|7|8|9/	eg:[1-29] -> [1-2]或者[1-9]
[^0-9]   负值字符范围 -> 非数字

####示例
/\d+/    一串数字
/\d\d+/  最少2个才能匹配
/.+/     任意多个
/.*/     可有可无

#####应用：校验座机号码
021-8888888
0791-88888888
区号-：(0[1-9]\d{1,2}-)?	3/4位数字 首位数字为0、第二位非0  区号-可有可无
号码：[1-9]\d{6,7}          7/8位数字 首位数字非0

/^(0[1-9]\d{1,2}-)?[1-9]\d{6,7}$/

#####应用：校验邮箱
wangchloe@yeah.net
123123123@163.com.cn
用户名 + @ + 域名 +      . + 后缀
\w+      @   [a-z0-9-]+  (\. [a-z]{2,8}){1,2}

/^\w+@[a-z0-9-]+(\. [a-z]{2,8}){1,2}$/

#####应用：校验年龄 18-100
18-19  20-99  100
1[89]|[2-9]\d|100

/^1[89]|[2-9]\d|100$/
^优先级比|高,会先执行^1[89]和100$  并且^与超过两个|同时出现就会错乱，需要加括号包裹多个条件，提升优先级

/^(1[89]|[2-9]\d|100)$/

#####应用：trim()去除首尾空格
去首空格
^\s+

去尾空格
\s+$

去掉 开头为空格 或者 空格为结尾
/^\s+|\s+$/

#####应用：校验名字
str.fromCharCode('0x4e00')	第一个中文 	 0x4e00 一
								最后一个中文 0x9fa5	龥(yu)

unicode编码：统一编码 utf-8 utf-16 utf-32	以\u开头 \u4e00(一) ~ \u9fa5(龥)

GB2312编码

utf-8统称：unicode

两个到七个汉字
/^[\u4e00-\u9fa5]{2,7}$/

#####应用：首字母大写
var str = 'welcome to china';

str.replace(/\w+/g, function(s) {
	return s.charAt(0).toUpperCase() + s.substring(1);
})

#####应用：过滤html的标签
var str = oBox.innerHTML;
var str2 = str.replace(/<[^>]+>/g, '');
console.log(str2);

##12.19

###正则
####单词边界
找确定单词时加单词边界 \b 在正则中需转义 \\b

var reg = new RegExp('\\bAAA\\b');

####正则getByClass等方法
``` javascript
<script>
	function getByClass(oParent, sClass) {
		if (oParent.getElementsByClassName) {
			return oParent.getElementsByClassName(sClass);
		} else {
			var arr = [];
			var aEle = oParent.getElementsByTagName('*');
			var reg = new RegExp('\\b' + sClass + '\\b');
			for (var i = 0; i < aEle.length; i++) {
				if (reg.test(aEle[i].className)) {
					arr.push(aEle[i]);
				}
			}
			return arr;
		}
	};

	function hasClass(obj, sClass) {
		var reg = new RegExp('\\b' + sClass + '\\b');
		return reg.test(obj.className);
	};

	function addClass(obj, sClass) {
		if (obj.className) {
			if (!hasClass(obj, sClass)) {
				obj.className += ' ' + sClass;
			}
		} else {
			obj.className = sClass;
		}
	};

	function removeClass(obj, sClass) {
		var reg = new RegExp('\\b' + sClass + '\\b');
		if (hasClass(obj, sClass)) {
			obj.className = obj.className.replace(reg, '').replace(/\s+/g, ' ').replace(/^\s+|\s+$/, '');
			//obj.className=obj.className.replace(reg,'').replace(/^\s+/g,'');
		}
	};
</script>
```

###性能优化
####垃圾回收 GC(Gabage Collection)
js中的垃圾回收：(宿主环境)
浏览器会自动回收垃圾

底层语言不会自动回收垃圾

垃圾的评判标准:生存周期

生存周期：作用域
1. 全局变量，生存周期长，直到浏览器关闭时清除  占资源
2. 局部变量，生存周期短，方法调用完即清除
3. 闭包(子函数可以使用父函数的局部变量)
	子函数若没有释放，整条作用域链上的局部变量都会保留
	作用域链：从内一级一级往外找，直到全局

``` javascript
<script>
	// 作用域链
	function show1() {
		var a = 12;
		function show2() {
			var b = 1;
			function show3() {
				var c = 2;
				document.onclick = function() {
					var d = 3;
					alert(a);
				}
			}
			show3();
		}
		show2();
	}

	show1();
</script>
```

####递归(函数自己调用自己)
核心思想：把一个大问题，拆成一个一个小问题，逐个解决

数列：斐波那契数列(Fibonacci sequence)

``` javascript
<script>
	var arr=[];
	function fn(n){		// n为当前月份
		if(n<=2){
			return 1;
		}else{
			if(arr[n]){
				return arr[n];
			}else{
				arr[n]=fn(n-1)+fn(n-2);
				return arr[n];	// 返回截止当前月份的总数
			}
		}
	}
</script>
```

##12.20

###性能优化

####js

项目：1.稳定性
	  2.可维护性
	  3.性能优化

性能：1.执行性能
	  2.网络性能

#####执行性能
1. 不用的东西删除
2. 尽量不用全局变量 命名冲突，耗资源
3. 能用系统自带的一定不用自己写的 getByClass
4. 尽量使用正则操作字符串

DOM操作耗性能，尽量减少DOM操作
属性用的越多，性能越低
DOM操作：
全局变量：
局部变量：
属性：
json：
数组arr.length存与不存：差不多

Math.floor比parseInt快
变量性能消耗：属性>全局变量>局部变量


#####网络性能
######查看性能 F12 -> network
Status 状态码
Type  资源类型
	主类型/次类型
	text/html
	text/css
	image/png/gif
Initiator 发起人
Size 资源大小
Time 请求耗时
Timeline 时间轴
	Queueing 排队
	Stalled  停滞
	Request sent 请求发送
	Waiting 等待
	Content Download 内容下载

######工具：
FF -> firebug -> yslow(网站评分)
Chrome -> Audits(查看网站性能)

#####网络性能提升方法
1.减少http请求：
	js -> 合并
	css -> 合并
	图片 -> css sprites
2.http请求越小越好
	压缩
	1. 工具 开源中国工具
	2. 前端自动化工具
3.图片延迟加载
4.CDN(Content Delivery Network, 内容分发网络)加速
5.阻塞加载
- 非阻塞加载(异步加载，并行加载)
css、html、图片
- 阻塞加载(同步加载)
js
解决：引用其他网站的js放在body最后

###面向对象
面向对象：只管用，不用管内部实现
对象组成：1.属性(变量)	2.方法(函数)

this: 当前方法属于谁，this就是谁
**this默认属于window**

####严格模式
'use strict';	IE6不识别但不报错
好处：
1. 修复局部this的问题
2. 不允许if/while/for里面定义函数
3. 去掉了with(){}
4. 定义变量必须加var

作用范围：
1. 最大不出script标签
2. 放在哪就作用在哪

坑
``` javascript
<script>
	var a = 5;  // 单数
	if(a % 2) {
		function show() {
			alert('单数');
		}
	} else {
		function show() {
			alert('双数');
		}
	}
	show();	// 单数 最新版高级浏览器中预解析不会覆盖，之前版本预解析后此例预解析覆盖 弹出双数
</script>
```

``` javascript
<script>
	'use strict';
	var a = 5;
	if(a % 2) {
		function show() {
			alert('单数');
		}
	} else {
		function show() {
			alert('双数');
		}
	}
	show();	// show is not defined，严格模式不允许if/for里面定义函数
</script>
```

####系统内置对象
Array Json RegExp Date

####构造函数
函数名首字母大写 -> 区分普通函数

#####工厂模式
``` javascript
<script>
	function CreateObject(name, age) {
		// 1.原料
		var obj = new Object();

		// 2.加工
		// 属性
		obj.name = name;
		obj.age = age;
		// 方法
		obj.getName = function() {
			return this.name;
		}
		obj.getAge = function() {
			return this.age;
		}

		// 3.出厂
		return obj;
	}

	var p = CreateObject('x', 11);
	alert(p.getName());
</script>
```

##12.21

###面向对象

####构造函数
``` javascript
<script>
	function CreateObject(name, age) {
		// 1.原料
		// var obj = new Object();

		// 2.加工
		// 属性
		this.name = name;
		this.age = age;
		// 方法
		this.getName = function() {
			return this.name;
		}
		this.getAge = function() {
			return this.age;
		}

		// 3.出厂
		//return obj;

		// 自动返回this
	}

	var p = new CreateObject('x', 11);	// 创建对象，并赋值给this
	alert(p.getName());
</script>
```

####关于new
1. 创建一个空对象，并赋值给this
2. 返回this

``` javascript
<script>
	function show() {
		alert(this);
	}
	new show();	// object
</script>
```

####原型及原型链

``` javascript
<script>
	var arr = [1, 2, 3];
	Array.prototype.sum = function() {
		var sum = 0;
		for(var i = 0; i < this.length; i++) {
			sum += this[i];
		}
		return sum;
	}
	alert(arr.sum());
</script>
```
构造函数+原型

**面向对象**
1. 构造函数添加属性
2. 原型添加方法

``` javascript
<script>
	function CreatePerson(name, age) {
		this.name = name;
		this.age = age;
	}

	CreatePerson.prototype.getName = function() {
		return this.name;
	};

	CreatePerson.prototype.getAge = function() {
		return this.age;
	};

	var p1 = new CreatePerson('a1', 1);
	var p2 = new CreatePerson('a2', 2);
	alert(p1.getName());	// a1
	alert(p2.getName());	// a2
	alert(p1.getName == p2.getName);	// true
</script>
```

#####原型应用
1. 数组arr.indexOf兼容问题

兼容：高级浏览器
IE8- 报错

``` javascript
<script>
	var arr = [1, 2, 3, 4];
	Array.prototype.indexOf = Array.prototype.indexOf || function(item) {	// 如果有indexOf()方法就用系统自带的
		for(var i = 0; i < this.length; i++) {
			if(this[i] == item) {
				return i;
			}
		}

	};

	alert(arr.indexOf(3));
</script>
```

2. 字符串str.trim()兼容问题

兼容：高级浏览器
IE8- 报错

``` javascript
<script>
	var str = '  aaa  ';
	String.prototype.trim = String.prototype.trim || function() {	// 如果有trim()方法就用系统自带的
		return this.replace(/^\s+|\s+$/g, '');
	}
	alert('去空格' + str.trim() + '去空格');
</script>
```

###面向对象
特征：
封装：
继承：子级可以继承父类的一切东西
多态：子级可以继承多个父级

###对象相关方法
####判断是否属于该类型
instanceof
true -> 属于
false -> 不属于
eg: arr instanceof Array;	// true

####查找对象的父级
constructor 查找对象的父级
eg:arr.constructor == Array;	// true

**Json不是一个类型，其父类型就是Object**
alert(json.constructor == Json);    // false
alert(json.constructor == Object);  // true

#坑
``` javascript
<script>
	var arr = [1, 2];
	var json = {};
	var oDate = new Date();

    alert(arr.constructor == Array);    // true
    alert(json.constructor == Json);    // false
    alert(json.constructor == Object);  // true


	alert(typeof oDate);	// object
	alert(oDate instanceof Date);	// true
	alert(typeof Date);	// function
	alert(Date instanceof Function);	// true
	alert(oDate instanceof Function);	// false

	alert(typeof Image);	// function
	alert(Image instanceof Function);	// true

	alert(Function instanceof Object);	// true
	alert(Object instanceof Function);	// true
	alert(Object instanceof Object);	// true
	alert(Function instanceof Function);	// true

	alert(arr instanceof Array);	// true
	alert(Array instanceof Object);	// true
	alert(arr instanceof Object);	// true

	alert(arr instanceof Array);	// true
	alert(Array instanceof Function);	// true
	alert(arr instanceof Function);		// false

    Object.prototype.run = 7;
    var run = 5;
    var arr = [];
    alert(run); // 5
    alert(typeof run);  // number
    alert(run instanceof Number);   // false
    alert(Number instanceof Object);    // true
    alert(Boolean instanceof Object);   // false
    alert(run instanceof Object);   // false
    alert(arr.run); // 7
</script>
```

###关于this

this: 当前方法属于谁，this就是谁
**this默认属于window**

**this的优先级**：
1. new -> object
2. 定时器 -> window
3. 事件 -> 事件对象
4. 方法 -> 方法对象

(多包一层时优先级失效)

``` javascript
<script>
	function show() {
		alert(this);
	}

	var arr = [1, 2];
	arr.show = show();

	document.onclick = arr.show;	// document
	new arr.show();	// object
	new show();	// object
	new document.onclick();	// object

	setTimeout(show, 1000);	// window
	setTimeout(arr.show, 1000);	// window

	setTimeout(new arr.show, 1000);	// object

	var oDate = new Date();
	oDate.show = show;
	document.show = show;
	document.onclick = show;
	setTimeout(function() {		// setTimeout多包一层优先级失效
		oDate.show();	// 时间
		new oDate.show();	// object
		document.show();	// document
		document.onclick();	// document
	}, 100);
</script>
```

###面向对象程序
1. 写一个构造函数
2. 把方法挂在原型上(不能有方法嵌套)
3. 把全局变量变成属性
4. 调整this

``` javascript
<script>
	function ToRed() {
		this.oDiv = document.body.children[0];
		var _this = this;
		// document.onclick = this.fnClick;
		// 上句相当于
		// document.onclick = function() {
		// 	alert(this);	// document
		// 	this.oDiv.style.background = '#f00';	// 当前的this指向document
		// }

		document.onclick = function() {
			_this.fnClick();
		}
	}

	ToRed.prototype.fnClick = function() {
		this.oDiv.style.background = '#f00';
	}

	new ToRed();
</script>
```

###面向对象应用

##12.22

###sublime快捷键
ctrl+shift+d  复制粘贴当前行
ctrl+shift+[  折叠代码
ctrl+shift+]  展开代码
ctrl+shift+v  粘贴并格式化
ctrl+g        跳转到第几行
ctrl+m        跳转到对应括号
ctrl+w        关闭当前文件
ctrl+r 		  前往method
alt+数字      切换至当前窗口的第N个文件
alt+.     	  闭合标签
alt+F3        选中所有相同的词
ctrl+鼠标左键点击 标记多个光标

###面向对象：继承
强制改变this指向

call  改变this指向
call(a);  改变this指向，指向a
call(a, p1, p2);	改变this指向并传参p1, p2

apply 改变this指向
apply(a, [p1, p2]);	改变this指向并传参数数组
apply(a, arguments);改变this指向并传入当前方法的参数数组

####继承
1. 属性的继承
- 父级的构造函数.call(this, 参数1, 参数2, ...);
- 父级的构造函数.apply(this, arguments);

2. 方法的继承
- 子级.prototype = 父级.prototype;	// 引用  子级新方法在前面写会被清空

	问题：子级改了，父级也改了

- for(var name in 父级.prototype) {
	子级.prototype[name] = 父级.prototype[name];	// 循环复制一遍
 }

    问题：子级 instanceof 父级; // false

- 子级.prototype = new 父级的构造函数();
  子级.prototype.constructor = 子级的构造函数;
  (推荐使用)

应用：选项卡(继承)

###单例模式/单体模式(需要重新指定父级)
``` javascript
<script>
	var proson={};
	//加属性
	proson.name='zns';
	//加方法
	proson.showName=function(){
		return this.name;
	};
</script>

```

###原型另一种写法
``` javascript
<script>
	function Person(name, age) {
			this.name = name;
			this.age = age;
		}

	Person.prototype = {
		getName: function() {
			return this.name;
		},
		getAge: function() {
			return this.age;
		},
		constructor: Person		// 需指定父级
	};

	var p1 = new Person('a', 1);
	alert(p1 instanceof Person);	 // true
	alert(p1.constructor == Person); // 若不指定父级，constructor为false
</script>
```
###变量名冲突
1. 封闭空间
	// 自执行函数、闭包
	(function(){})();
	(function(){}());
	~function(){}();	// 加符号为防止报错，不仅是~
2. 面向对象
3. 命名空间
4. 模块化

##12.23

###伪数组没有数组方法
####DOM获取的元素是伪数组
####arguments是伪数组

###注意json属性名不能用纯数字

##12.26

###事件阻止默认和冒泡

oEvent.cancelBubble = true;	// 阻止冒泡
oEvent.preventDefault();	// 高级浏览器阻止默认
return false;				// IE

####链式运动
每个功能方法的最后返回当前对象
return this;

####插件
一个插件
$.fn = jQuery.prototype;
$.fn.red = function() {}

一组插件
$.fn = jQuery.prototype;
$.fn.extend = jQuery.prototype.extend = function(json) {
	for(var name in json) {
		jQuery.prototype[name] = json[name];
	}
}

####ajax
$.ajax = XQuery.ajax = function(json) {
	ajax(json);
}

function ajax(json){}

$.xxx形式 放在原型的属性上
xxx.find() 放在原型的原型链上

###原型思想仿写 chloe.js
``` javascript
<script>
	'use strict';

	function $(arg) {
		return new Chloe(arg);
	}

	function Chloe(arg) {
		this.elements = []; // 存选择的元素
		this.domString = ''; // 存创建的元素
		switch (typeof arg) {
			// 方法
			case 'function':
				domReady(arg);
				break;
				// 选择器
			case 'string':
				if (arg.indexOf('<') != -1) {
					this.domString = arg; // 创建元素
				} else {
					this.elements = getEle(arg); // 选择元素
				}
				break;
				// 原生转化
			default:
				if (arg instanceof Array) {
					this.elements = this.elements.concat(arg);
				} else {
					this.elements.push(arg);
				}
				break;
		}
	}

	Chloe.prototype.css = function(name, value) {
		if (arguments.length == 2) { // 设置css
			for (var i = 0; i < this.elements.length; i++) {
				this.elements[i].style[name] = value;
			}
		} else {
			if (typeof name == 'string') { // 获取css，默认获取一组元素中的第一个的css
				return getStyle(this.elements[0], name);
			} else { // 设置一组css
				var json = name;
				for (var i = 0; i < this.elements.length; i++) {
					for (var name in json) {
						this.elements[i].style[name] = json[name];
					}
				}
			}
		}
		return this;
	};

	Chloe.prototype.attr = function(name, value) {
		if (arguments.length == 2) { // 设置属性
			for (var i = 0; i < this.elements.length; i++) {
				this.elements[i].setAttribute(name, value);
			}
		} else {
			if (typeof name == 'string') { // 获取属性，默认获取一组元素中的第一个的属性
				return this.elements[0].getAttribute(name);
			} else { // 设置一组属性
				var json = name;
				for (var i = 0; i < this.elements.length; i++) {
					for (var name in json) {
						this.elements[i].setAttribute(name, value);
					}
				}
			}
		}
		return this;
	};

	// DOM操作
	Chloe.prototype.html = function(str) {
		if (str || str == '') { // 空字符串''的length为0
			for (var i = 0; i < this.elements.length; i++) {
				this.elements[i].innerHTML = str;
			}
		} else {
			return this.elements[0].innerHTML;
		}
		return this;
	};

	Chloe.prototype.val = function(str) {
		if (str || str == '') { // 空字符串''的length为0
			for (var i = 0; i < this.elements.length; i++) {
				this.elements[i].value = str;
			}
		} else {
			return this.elements[0].value;
		}
		return this;
	};


	// insertAjacentHTML(where, [el], [html]);
	// beforeBegin:插入到标签开始前
	// afterBegin: 插入到标签开始标记之后
	// beforeEnd:  插入到标签结束标记前
	// afterEnd:   插入到标签结束标记后

	Chloe.prototype.appendTo = function(str) {
		var aParent = getEle(str);
		for (var i = 0; i < aParent.length; i++) {
			aParent[i].insertAjacentHTML('beforeEnd', this.domString);
		}
		return this;
	};

	Chloe.prototype.prependTo = function(str) {
		var aParent = getEle(str);
		for (var i = 0; i < aParent.length; i++) {
			aParent[i].insertAjacentHTML('afterBegin', this.domString);
		}
		return this;
	};

	Chloe.prototype.insertBefore = function(str) {
		var aParent = getEle(str);
		for (var i = 0; i < aParent.length; i++) {
			aParent[i].insertAjacentHTML('beforeBegin', this.domString);
		}
		return this;
	};

	Chloe.prototype.insertBefore = function(str) {
		var aParent = getEle(str);
		for (var i = 0; i < aParent.length; i++) {
			aParent[i].insertAjacentHTML('afterEnd', this.domString);
		}
		return this;
	};

	Chloe.prototype.remove = function() {
		for (var i = 0; i < this.elements.length; i++) {
			this.elements[i].parentNode.removeChild(this.elements[i]);
		}
		return this;
	};

	Chloe.prototype.addClass = function(cName) {
		var reg = new RegExp('\\b' + cName + '\\b');
		for (var i = 0; i < this.elements.length; i++) {
			if (cName) {
				if (this.elements[i].className) {
					if (!reg.test(this.elements[i].className)) {
						this.elements[i].className += ' ' + cName;
					}
				} else {
					this.elements[i].className = cName;
				}
			} else {
				console.log('>>>There is no class to add!');
			}
		}
		return this;
	};

	Chloe.prototype.removeClass = function(cName) {
		var reg = new RegExp('\\b' + cName + '\\b');
		for (var i = 0; i < this.elements.length; i++) {
			if (cName) {
				if (reg.test(this.elements[i].className)) {
					this.elements[i].className = this.elements[i].className.replace(reg, '').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
				}
			} else {
				console.log('>>>There is no class to remove!');
			}
		}
		return this;
	};

	Chloe.prototype.eq = function(n) {
		return $(this.elements[n]);
	};

	Chloe.prototype.get = function(n) {
		return this.elements[n];
	};

	Chloe.prototype.index = function() {
		var obj = this.elements[0];
		var aSibling = obj.parentNode.children;
		for (var i = 0; i < aSibling.length; i++) {
			if (obj == aSibling[i]) {
				return i;
			}
		}
		return this;
	};

	Chloe.prototype.find = function(str) {
		var aParent = this.elements;
		var aChild = getEle(str, aParent);
		return $(aChild);
	}

	Chloe.prototype.animate = function(json, options) {
		for (var i = 0; i < this.elements.length; i++) {
			move(this.elements[i], json, options);
		}
		return this;
	}

	$.ajax = Chloe.ajax = function(json) {
		ajax(json);
	}

	$.jsonp = Chloe.jsonp = function(json) {
		jsonp(json);
	}


	Chloe.prototype.toggle = function() {
		var args = arguments;
		var count = 0;
		var _this = this;
		for (var i = 0; i < this.elements.length; i++) {
			(function(count) { // 闭包，让每个toggle事件独立完成
				addEvent(_this.elements[i], 'click', function() { // TODO 事件更改
					var fn = args[count % args.length];
					fn && fn.apply(this, arguments);
					count++;
				})
			})(0);
		}
		return this;
	};

	Chloe.prototype.show = function() {
		for (var i = 0; i < this.elements.length; i++) {
			this.elements[i].style.display = 'block';
		}
		return this;
	};

	Chloe.prototype.hide = function() {
		for (var i = 0; i < this.elements.length; i++) {
			this.elements[i].style.display = 'none';
		}
		return this;
	};

	Chloe.prototype.on = function(sEv, fn) { // TODO 添加第二个参数事件委托
		for (var i = 0; i < this.elements.length; i++) {
			addEvent(this.elements[i], sEv, fn);
		}
	};

	Chloe.prototype.hover = function(fnOver, fnOut) {
		this.mouseenter(fnOver);
		this.mouseOut(fnOut);
		return this;
	};

	// click、mouseover等不需要on的事件
	'click mouseover mousedown mousemove mouseout keydown keyup load resize focus blur'.replace(/\w+/g, function(sEv) {
		Chloe.prototype[sEv] = function(fn) {
			for (var i = 0; i < this.elements.length; i++) {
				addEvent(this.elements[i], sEv, fn);
			}
			return this;
		};
	});

	// onmouseover、onmouseout
	// 问题1：移入子级也算重新移入
	// 解决1：onmouseover -> onmouseenter
	// 问题2：移出子级也算移出
	// 解决2：onmouseout -> onmouseleave

	Chloe.prototype.mouseenter = function(fn) {
		for (var i = 0; i < this.elements.length; i++) {
			addEvent(this.elements[i], 'mouseover', function(ev) {
				var fm = ev.fromElement || ev.relatedTarget;
				if (this.contains(fm)) { // 是子元素就return出去
					return;
				}
				fn && fn.apply(this, arguments);
			});
		}
		return this;
	};

	Chloe.prototype.mouseleave = function(fn) {
		for (var i = 0; i < this.elements.length; i++) {
			addEvent(this.elements[i], 'mouseout', function(ev) {
				var to = ev.toElement || ev.relatedTarget;
				if (this.contains(to)) { // 是子元素就return出去
					return;
				}
				fn && fn.apply(this, arguments);
			});
		}
		return this;
	};

	$.fn = Chloe.prototype;
	$.fn.extend = Chloe.prototype.extend = function(json) {
		for (var name in json) {
			Chloe.prototype[name] = json[name];
		}
	}

	// 添加事件
	function addEvent(obj, sEv, fn) {
		//对象, 事件(不加on), 函数名/函数
		if (obj.addEventListener) { //高级浏览器 -> function  低级 ->undefined
			obj.addEventListener(sEv, function(ev) {
				var oEvent = ev || event;
				if (fn.apply(obj, arguments) == false) { // 强制改变fn中的this
					oEvent.cancelBubble = true; // 阻止冒泡
					oEvent.preventDefault(); // 阻止默认行为
				}
			}, false);
		} else {
			obj.attachEvent('on' + sEv, function(ev) {
				var oEvent = ev || event;
				if (fn.apply(obj, arguments) == false) { // 强制改变fn中的this
					oEvent.cancelBubble = true; // 阻止冒泡
					return false;
				}
			});
		}
	}

	// 运动
	function move(obj, json, options) {
		//obj, {attr1: val1, attr2: val2}, {[duration], [easing], [complete]}
		options = options || {};
		options.duration = options.duration || 700;
		options.easing = options.easing || 'linear';

		clearInterval(obj.timer);

		var start = {};
		var dis = {};

		for (var name in json) {
			start[name] = parseFloat(getStyle(obj, name));
			dis[name] = json[name] - start[name];
		}

		var count = Math.floor(options.duration / 30);
		var n = 0;
		obj.timer = setInterval(function() {
			n++;
			for (var name in json) {
				switch (options.easing) { // TODO：运动形式扩展
					case 'linear':
						var a = n / count;
						var cur = start[name] + dis[name] * a;
						break;
					case 'ease-in':
						var a = n / count;
						var cur = start[name] + dis[name] * Math.pow(a, 3);
						break;
					case 'ease-out':
						var a = 1 - n / count;
						var cur = start[name] + dis[name] * (1 - Math.pow(a, 3));
						break;
				}

				if (name == 'opacity') {
					obj.style.opacity = cur;
					obj.style.filter = 'alpha(opacity:' + cur * 100 + ')';
				} else {
					obj.style[name] = cur + 'px';
				}
			}

			if (n == count) {
				clearInterval(obj.timer);
				options.complete && options.complete();
			}
		}, 30);
	}

	// ajax
	function ajax(json) {
		//url, data, type, success, error
		json = json || {};
		if (!json.url) {
			console.log('>>>url is null!');
			return;
		}
		json.data = json.data || {};
		json.type = json.type || 'get';
		json.time = json.time || 1000;

		if (window.XMLHttpRequest) {
			var oAjax = new XMLHttpRequest();
		} else {
			var oAjax = new ActiveXObject("Microsoft.XMLHTTP");
		}

		switch (json.type.toLowerCase()) {
			case 'get':
				oAjax.open('GET', json.url + '?' + jsonToURL(json.data), true);
				oAjax.send();
				break;
			case 'post':
				oAjax.open('POST', json.url, true);
				oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
				oAjax.send(jsonToURL(json.data));
				break;
		}

		json.loading && json.loading();
		oAjax.onreadystatechange = function() {
			if (oAjax.readyState == 4) {
				if (oAjax.status >= 200 && oAjax.status < 300 || oAjax.status == 304) {
					json.success && json.success(oAjax.responseText);
				} else {
					json.error && json.error(oAjax.status);
				}
				json.complete && json.complete();
				clearTimeout(timer);
			}
		};

		var timer = null;
		timer = setTimeout(function() {
			console.log('>>>请求超时!');
			oAjax.onreadystatechange = null;
		}, json.time);
	}

	// json -> url
	function jsonToURL(json) {
		json.t = new Date().getTime();
		var arr = [];
		for (var name in json) {
			arr.push(name + '=' + json[name]);
		}
		return arr.join('&');
	}

	// jsonp
	function jsonp(json) {
		// url, data, cbName, success
		//路径，参数，回调函数名字，回调函数
		json = json || {};
		if (!json.url) {
			console.log('>>>url is null!');
			return;
		}
		json.data = json.data || {};
		json.cbName = json.cbName || 'cb';

		var fnName = 'jsonp_' + Math.random();
		fnName = fnName.replace('.', '');

		//全局函数防止与外部函数jsonp()重名
		window[fnName] = function(json2) {
			json.success && json.success(json2);
			oHead.removeChild(oS);
		};

		var arr = [];
		json.data[json.cbName] = fnName;

		for (var name in json.data) {
			arr.push(name + '=' + json.data[name]);
		}

		var oS = document.createElement('script');
		var oHead = document.getElementsByTagName('head')[0];

		oS.src = json.url + '?' + arr.join('&');
		oHead.appendChild(oS);
	}

	// 获取某元素的某样式
	function getStyle(obj, name) {
		return (obj.currentStyle || getComputedStyle(obj, false))[name];
	}

	// domReady
	function domReady(fn) {
		if (document.addEventListener) {
			document.addEventListener('DOMContentLoaded', fn, false);
		} else {
			document.attachEvent('onreadystatechange', function() {
				if (document.readyState == 'complete') {
					fn && fn();
				}
			});
		}
	}

	// 从某父元素下获取某子元素
	function getEle(str, aParent) {
		var arr = str.replace(/^\s+|\s+$/g, '').split(/\s+/);
		var aParent = aParent || [document];
		var aChild = [];
		for (var i = 0; i < arr.length; i++) {
			aChild = getStr(aParent, arr[i]);
			aParent = aChild;
		}
		return aChild;
	}

	// 选择器
	function getStr(aParent, str) {
		var aChild = [];
		for (var i = 0; i < aParent.length; i++) {
			switch (str.charAt(0)) {
				// id
				case '#':
					var obj = document.getElementById(str.substring(1));
					aChild.push(obj);
					break;
					// class
				case '.':
					var aEle = getByClass(aParent[i], str.substring(1));
					for (var j = 0; j < aEle.length; j++) {
						aChild.push(aEle[j]);
					}
					break;
					// 含标签
				default:
					if (/\w+\.\w+/.test(str)) { // eg:li.red
						var arr = str.split('.');
						var aEle = aParent[i].getElementsByTagName(arr[0]);
						var reg = new RegExp('\\b' + arr[1] + '\\b');
						for (var j = 0; j < aEle.length; j++) {
							if (reg.test(aEle[j].className)) {
								aChild.push(aEle[j]);
							}
						}
					} else if (/\w+:\w+(\(\d+\))?/.test(str)) { // 伪类 eg:li:first
						var arr = str.split(/:|\(|\)/g);
						var aEle = aParent[i].getElementsByTagName(arr[0]);
						switch (arr[1]) {
							case 'first':
								aChild.push(aEle[0]);
								break;
							case 'last':
								aChild.push(aEle[aEle.length - 1]);
								break;
							case 'odd': // 得到数组的第奇数个 aEle[1] aEle[3] 对应视图的第2个 第4个
								// 选取每个带有奇数 index 值的元素
								for (var j = 1; j < aEle.length; j += 2) {
									aChild.push(aEle[j]);
								}
								break;
							case 'even':
								for (var j = 0; j < aEle.length; j += 2) {
									aChild.push(aEle[j]);
								}
								break;
							case 'eq':
								var index = arr[2];
								aChild.push(aEle[index]);
								break;
							case 'lt':
								var index = arr[2];
								for (var j = 0; j < index; j++) {
									aChild.push(aEle[j]);
								}
								break;
							case 'gt':
								var index = arr[2];
								for (var j = index; j < index; j++) {
									aChild.push(aEle[j]);
								}
								break;
							default:
								break;
						}
					} else if (/\w+\[\w+=\w+\]/.test(str)) { // input[type=text]
						var arr = str.split(/\[|=|\]/g);
						var aEle = aParent[i].getElementsByTagName(arr[0]);
						for (var j = 0; j < aEle.length; j++) {
							if (aEle[j].getAttribute(arr[1]) == arr[2]) {
								aChild.push(aEle[j]);
							}
						}
					} else { // tag
						var aEle = aParent[i].getElementsByTagName(str);
						for (var j = 0; j < aEle.length; j++) {
							aChild.push(aEle[j]);
						}
						break;
					}
			}
		}

		return aChild;
	}

	// getByClass兼容IE8-
	function getByClass(oP, sClass) {
		if (oP.getElementsByClassName) {
			return oP.getElementsByClassName(sClass);
		} else {
			var arr = [];
			var aEle = oP.getElementsByTagName('*');
			var reg = new RegExp('\\b' + sClass + '\\b');
			for (var i = 0; i < aEle.length; i++) {
				if (reg.test(aEle[i].className)) {
					arr.push(aEle[i]);
				}
			}
			return arr;
		}
	}
</script>
```

*代码管理

###svn代码版本管理工具
1.更新 update
2.修改
3.增加(已存在文件跳过这步) add
4.提交(注释) commit

##12.27

###js验证码
[http://www.jb51.net/article/76945.htm](js实现简单的验证码)
###git分布式代码管理工具

**git与svn(Subversion)的区别(来源于博客)**
1. git是分布式的，svn不是。
git跟svn一样有自己的集中式版本库或服务器。但git更倾向于被使用于分布式模式，克隆版本库后即使没有网络也能够commit文件，查看历史版本记录，创建项目分支等，等网络再次连接上Push到服务器端。
2. git把内容按元数据方式存储，而svn是按文件。
所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。
git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。
3. git没有一个全局的版本号，svn有。
4. git的内容完整性优于svn。
因为git的内容存储使用的是SHA-1哈希算法。
5. git可以有无限个版本库，svn只能有一个指定中央版本库。
当svn中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。
每一个git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）有问题，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！


###DOS命令
d:		 切换盘符
dir      查看当前目录(文件夹)下所有文件夹及文件
cls      清屏
cd xx    进入目录(文件夹)

###常用linux命令
ls       查看当前目录(文件夹)下所有文件夹及文件
cd xx    进入xx文件夹
cd ..    返回上级目录(文件夹)
cd /     返回根目录
touch xx 创建文件并命名为xx
rm xx    删除文件xx
clear    清屏
cat xx   查看文件xx的内容
mkdir xx 创建目录(文件夹)并命名为xx
rmdir xx 删除目录(文件夹)xx，当文件夹内容不为空时不能删除
rmdir -rf 删除目录(文件夹)xx并删除其内容

编辑文件：
进入文件：vi 文件名
启用编辑：按insert键
开始编辑
保存：esc -> :wq+ -> 回车

快捷命令：
	创建文件并且输入内容
	echo 内容 > xxx.txt

[http://www.cnblogs.com/roucheng/p/linuxdos.html](DOS 和 Linux 常用命令的对比)

###git命令
工作区 -> 缓存区 -> 本地仓库 -> 服务器仓库

工作区
git init           当前目录改为git目录，变为工作区

缓存区
git add xx.txt     添加一个文件至缓存区
git add .          添加所有文件至缓存区
git rm --cache xx.txt  从缓存区删除一个文件

本地仓库
git commit -m '注释'   添加文件至本地仓库

服务器仓库

git remote add origin <github上的链接>
git push -u origin master

其他
git status         查看git此时状态
git log   			日志

git reset 跟一个commit(key)回到某个状态下
两种用法：
git reset [-q] [commit] [--] <paths>

git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [<commit>]
reset命令有3种方式：

git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息

git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可

git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容

eg: git reset --hard HEAD^ 最新一次提交的父提交


1.本地代码放到github上
	第一次：(服务器上没有)
		跟github建立一个关系
			git remote add origin <github上的链接>
		推送到github上
			git push -u origin master
2.已有项目
	git clone <github上的链接>

多人合作
[ git merge 和 git rebase 小结](http://blog.csdn.net/wh_19910525/article/details/7554489)

关于SSH配置
[http://jingyan.baidu.com/article/5bbb5a1b17107e13eba179d1.html](github如何创建密钥)
**注意：id_rsa.pub才是公用秘钥，把这个放进github**
配置
git config -l     查看此时git的配置文件
git config --global user.name '名字'
git config --global user.email '邮箱地址'

###wordpress博客

###php
``` php
<?php
	// php code here
	echo 'xxx';	// 输出
	$a = 'aaa';	// 定义变量
	echo $a;	// 输出变量

	for($i = 0; $i < 10; $i++){
		echo $i.'<br>';
	}
?>
```
php中+是运算符
.是连接符

注意：
1. echo可以输出html代码
2. 每行结尾必须加上分号
3. 路径不能出现中文

数据交互：
form ajax
接收
GET  $_GET[name];
POST $_POST[name];

##12.28

###php
``` php
<?php
	// php code here
	echo 'xxx';	// 输出
	$a = 'aaa';	// 定义变量
	echo $a;	// 输出变量

	for($i = 0; $i < 10; $i++){
		echo $i.'<br>';
	}
?>
```
php中+是运算符
.是连接符

注意：
1. echo可以输出html代码
2. 每行结尾必须加上分号
3. 路径不能出现中文

数据交互：
form ajax
接收
GET  $_GET[name];
POST $_POST[name];
eg:
`$user=$_GET['user'];
$pwd=$_GET['pwd'];
$str='name:'.$user.',pwd：'.$pwd;
echo $str;
`

1. 连接数据库
$conn = mysqli_connect('localhost', 'root', 'pwd');
2. 使用数据库
mysqli_select_db($conn, 'dbName');
3. 编写sql语句
$sql = 'selec * from user';
4. 执行sql语句
$result = mysqli_query($conn, $sql);
5. 拿数据
$row = mysqli_fetch_row($result);
// 从数据库取出来的都是数组
echo $row[0];	// 拿第一行数据

sql语句
查询：select * from 'dbName'
条件查询：select 字段1, 字段2 from 'dbName'
插入：select into usre

$sql="INSERT INTO weibo (ID, content, time, acc, ref) VALUES(0, '{$content}', {$time}, 0, 0)";

###应用

###json转化

new Function('return ' + str)();

###node.js
优点：性能高 高86倍
缺点：服务器提供的少，虚拟机、各种云平台，学习资料少

执行：
1. dos 进入文件当前位置
2. node 文件名

node中不能用：DOM、BOM
		能用：ECMA、文件操作、数据库操作等

服务器
eg:apache nginx IIS ...
Web服务器包括Nginx，Apache，IIS等。而应用服务器包括WebLogic，JBoss、WebSphere等

node没有提供服务器，需编写自己的nodeJs的web服务器
####编写http服务器

http端口范围：
（1）公认端口（Well Known Ports）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。
（2）注册端口（Registered Ports）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。
（3）动态和/或私有端口（Dynamic and/or Private Ports）：从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。


自带模块：http

``` javascript
<script>
	// 1. 引入http模块
	var http = require('http');
	// 2. 创建http服务	 fn -> 回调函数
	var httpObj = http.createServer(function(request, response) {
		// request 请求 客户端 -> 服务器
		// response 响应 服务器 -> 客户端
		console.log('请求地址：' + request.url);
		// Chrome结果
		// 请求地址：/				// 根目录 本机地址
		// 请求地址：/favicon.ico	// 请求有没有地址栏图片

		// FF结果
		// 请求地址：/
		// 请求地址：/favicon.ico
		// 请求地址：/favicon.ico

		response.write('aaa');	// 返回在页面
		response.end();  // 结束
	});
	// 3. 监听一个端口
	httpObj.listen(8088);	// 自定义端口号 范围：1~65535 最好在1024以上
</script>
```

自带模块：fs(file system)

``` javascript
<script>
	// 1. 引入file system模块
	var fs = require('fs');
	// 2. 读文件
	fs.readFile('a.html', 'utf-8', function(err, data) {  //文件路径，[编码格式]，回调函数
		// 编码格式若不写为二进制流
		if(err) {
			console.log(err);	// 错误信息
		} else {
			console.log(data);	// 文件内容
		}
	})
</script>
```

####npm node包管理工具

npm install mysql


``` javascript
<script>
	// 1. 引入mysql模块
	var mysql = require('mysql');

	// 2. 连接数据库
	var db = mysql.createConnection({
		host: 'localhost',
		user: 'root',
		password: '',
		database: 'chloedb'
	});

	// 3. SQL语句取出数据
	var sql = 'select * from db1';
	db.query(sql, function(err, data) {		// SQL语句，回调函数
		if(err) {
			console.log(err);
		} else {
			console.log(data);	// 数据库返回数据类型：数组
		}
	});
</script>
```

###node服务器整合
``` javascript
<script>
	var http = require('http');
	var fs = require('fs');
	var mysql = require('mysql');

	var db = mysql.createConnection({
		host: 'localhost',
		user: 'root',
		password: '',
		database: 'chloedb'
	});

	http.createServer(function(req, res) {
		console.log('请求地址：' + req.url);
		var sql = 'select * from db1';
		var rUrl = req.url.split('?')[0];

		if(rUrl == '/getData') {
			db.query(sql, function(err, data) {		// SQL语句，回调函数
				if(err) {
					console.log(err);
				} else {
					console.log(data);	// 数据库返回数据类型：数组
					res.write(JSON.stringify(data));
					res.end();
				}
			});
		}

		var url = req.url == '/' ? '/index.html' : req.url;		// 根目录访问默认显示index.html **其他路径记得加/**
		fs.readFile('www' + url, function(err, data) {			// 浏览器自动转化二进制流，不用定义编码格式
			if(err) {
				res.write('404');
				res.end();
			} else {
				res.write(data);
				res.end();
			}
		});
	}).listen(8088);
</script>
```

####JSON方法
1. JSON.stringify(object);	// 对象 -> 字符串
eg: {a:1,b:2} -> "{"a":1,"b":2}"

2. JSON.parse(str);		// 字符串 -> json对象
{"name":"huangxiaojian","age":"23"}' ->
{
	age: "23"
	name: "huangxiaojian"
	__proto__: Object
}

##12.29

###Node server.js

###算法

有序数组查找定值

1. 线性查找
循环遍历比较
eg:findInArr

``` javascript
<script>
	function findInArr(item, arr) {
		for (var i = 0; i < arr.length; i++) {
			if (arr[i] == item) {
				return true;
			}
		}
		return false;
	}
</script>

```

2. **二分查找**
从中间开始，往左右两边查找

``` javascript
<script>
	var arr = [1, 2, 4];

	function findMid(item, start, end) {
		if(start > end) {	// 起始位置不能大于结束位置
			return false;
		} else if(start == end) {
			if(arr[start] == item) {
				return true;
			} else {
				return false;	// 没有找到最终走这步
			}
		}

		var mid = Math.floor((start + end) / 2);	// 二分法先确定中间位置
		if(arr[mid] == item) {
			return true;
		} else {
			if(item < arr[mid]) {
				return findMid(item, start, mid);
			} else {
				return findMid(item, mid + 1, end);
			}
		}

	}

	console.log(findMid(10, 0, arr.length - 1));
</script>

```

####二分法应用：
无序数组查找最小值

``` javascript
<script>
	var arr = [1, 2, -4, -11, 13];

	function findMin(arr, s , e) {
		if(s > e) {
			return false;
		} else if(s == e) {
			return arr[s];
		}

		var c = Math.floor((s + e) / 2);
		var l = findMin(arr, s , c);	// 先找左侧最小值
		var r = findMin(arr, c + 1, e);	// 再找右侧最小值

		if(l < r) {		// 两侧最小值比较
			return l;
		} else {
			return r;
		}
	}

	console.log(findMin(arr, 0, arr.length - 1));
</script>


二分法数组去重

``` javascript
<script>
	var arr = [1, 2, 3, 2, 4, 3, 1, 5, 7, 2, 5];

	// 数组内查找元素是否存在
	function findInArr(item, arr) {
		for(var i = 0; i < arr.length; i++) {
			if(item == arr[i]) {
				return true;
			}
		}
		return false;
	}

	function del(arr, s, e) {
		if(s > e) {
			return [];
		} else if(s == e) {
			return [arr[s]];
		}

		var c = Math.floor((s + e) / 2);
		var l = del(arr, s, c);
		var r = del(arr, c + 1, e);

		for(var i = 0; i < r.length; i++) {
			if(!findInArr(r[i], l)) {
				l.push(r[i]);
			}
		}

		return l;
	}

	console.log(del(arr, 0 , arr.length - 1));
</script>
```

二分法数组排序

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2, 11];

	function _sort(arr, s, e) {
		if(s > e) {
			return [];
		} else if(s == e) {
			return [arr[s]];
		}

		var c = Math.floor((s + e) / 2);
		var l = _sort(arr, s, c);
		var r = _sort(arr, c + 1, e);

		var arr2 = [];
		while(l.length > 0 || r.length > 0) {
			if(l[0] < r[0]) {
				arr2.push(l.shift());
			} else {
				arr2.push(r.shift());
			}
		}

		return arr2;
	}
</script>
```

###排序算法

#### 1. 交换排序

- 冒泡排序

每次比较相邻的两个数，如果后一个比前一个小，换位置。
时间复杂度：O(n^2)

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function bubbleSort(arr) {
		for (var i = 0; i < arr.length - 1; i++) {
			for(var j = 0; j < arr.length - 1; j++) {
				if(arr[j + 1] < arr[j]) {
					var temp;
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		return arr;
	}

	console.log(bubbleSort(arr));
</script>
```

- 快速排序

采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边。
时间复杂度：O(nlog2(n))

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function quickSort(arr) {
		if(arr.length == 0) {
			return [];	// 返回空数组
		}

		var cIndex = Math.floor(arr.length / 2);
		var c = arr.splice(cIndex, 1);
		var l = [];
		var r = [];

		for (var i = 0; i < arr.length; i++) {
			if(arr[i] < c) {
				l.push(arr[i]);
			} else {
				r.push(arr[i]);
			}
		}

		return quickSort(l).concat(c, quickSort(r));
	}

	console.log(quickSort(arr));
</script>
```

#### 2. 选择排序

- 直接选择

每次从自己的位置上，往下找，找到最小数，和当前位置交换。
时间复杂度：O(n^2)

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function selectSort(arr) {
		for (var i = 0; i < arr.length; i++) {
			var iMinIndex = findMinIndex(arr, i);
			var temp;
			temp = arr[iMinIndex];
			arr[iMinIndex] = arr[i];
			arr[i] = temp;
		}

		return arr;
	}

	function findMinIndex(arr, start) {
		var iMin = arr[start];
		var iMinIndex = start;

		for (var i = start + 1; i < arr.length; i++) {
			if(arr[i] < iMin) {
				iMin = arr[i];
				iMinIndex = i;
			}
		}

		return iMinIndex;
	}

	console.log(selectSort(arr));
</script>
```

- 堆排序

时间复杂度：O(nlog2(n))

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function headAdjust(elements, pos, len) {
		//将当前节点值进行保存
		var swap = elements[pos];

		//定位到当前节点的左边的子节点
		var child = pos * 2 + 1;

		//递归，直至没有子节点为止
		while (child < len) {
			//如果当前节点有右边的子节点，并且右子节点较大的场合，采用右子节点和当前节点进行比较
			if (child + 1 < len && elements[child] < elements[child + 1]) {
				child ++;
			}

			//比较当前节点和最大的子节点，小于则进行值交换，交换后将当前节点定位于子节点上
			if (elements[pos] < elements[child]) {
				elements[pos] = elements[child];
				pos = child;
				child = pos * 2 + 1;
			} else {
				break;
			}

			elements[pos] = swap;
		}
	}

	//构建堆
	function buildHeap(elements) {
		//从最后一个拥有子节点的节点开始，将该节点连同其子节点进行比较，
		//将最大的数交换与该节点,交换后，再依次向前节点进行相同交换处理，
		//直至构建出大顶堆（升序为大顶，降序为小顶）
		for (var i = elements.length / 2; i >= 0; i--) {
			headAdjust(elements, i, elements.length);
		}
	}

	function sort(elements) {
		//构建堆
		buildHeap(elements);

		//从数列的尾部开始进行调整
		for (var i = elements.length - 1; i > 0; i--) {
			//堆顶永远是最大元素，故，将堆顶和尾部元素交换，将
			//最大元素保存于尾部，并且不参与后面的调整
			var swap = elements[i];
			elements[i] = elements[0];
			elements[0] = swap;

			//进行调整，将最大）元素调整至堆顶
			headAdjust(elements, 0, i);
		}
	}

	console.log(sort(arr));
</script>
```

#### 3. 归并排序
采用二分法，左边一个排序好的数组，右边一个排序好的数组，每次比较左右第一个数，小的放到一个新的数组里。
时间复杂度：O(nlog2(n))

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function mergeSort(arr, s, e) {
		if(s > e) {
			return [];
		} else if(s == e) {
			return [arr[s]];
		}

		var c = Math.floor((s + e) / 2);
		var l = mergeSort(arr, s, c);
		var r = mergeSort(arr, c + 1, e);

		var arr2 = [];
		while(l.length > 0 || r.length > 0) {
			if(l[0] < r[0]) {
				arr2.push(l.shift());
			} else {
				arr2.push(r.shift());
			}
		}

		return arr2;
	}

	console.log(mergeSort(arr, 0, arr.length - 1));
</script>
```



###数据结构
- 时间复杂度
- 空间复杂度
![各种排序算法时间复杂度和空间复杂度表](http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg)

1. 有序数组
2. 无序数组

``` javascript
<script>
	var unorder_arr = [];

	function unorder_find(n) {
		for (var i = 0; i < unorder_arr.length; i++) {
			if(unorder_arr[i] == n) {
				return true;
			}
		}

		return false;
	}

	function unorder_add(n) {
		if(!unorder_find(n)) {
			unorder_arr.push(n);
		}
	}

	unorder_add(33);
	unorder_add(16);
	unorder_add(41);
	unorder_add(22);

	console.log(unorder_arr);
</script>
```
3. 二叉树
增加、查找

以第一个树为根节点，新的数比谁小跟谁近就放在谁下面
根
	节点: {
		value: n,
		l: null,
		r: null
	}

``` javascript
<script>
	var root = null;

	function add(node, n) {
		if (root == null) {
			root = {
				value: n,
				l: null,
				r: null
			};
		} else {
			if (n == node.value) {
				console.log('不能重复');
				return;
			} else {
				if (n < node.value) {
					console.log('查看左子树');
					if (node.l == null) {
						node.l = {
							value: n,
							l: null,
							r: null
						}
					} else {
						console.log('左子树不为空');
						return add(node.l, n);
					}
				} else {
					console.log('查看右子树');
					if (node.r == null) {
						node.r = {
							value: n,
							l: null,
							r: null
						}
					} else {
						console.log('右子树不为空');
						return add(node.r, n);
					}
				}
			}
		}
	}

	add(root, 42);
	add(root, 33);
	add(root, 66);
	add(root, 88);
	add(root, 1);
	add(root, 50);
	console.log(root);
</script>
```

4. 队列
特点：先进先出，后进后出

5. 堆栈
特点：后进先出，先进后出

6. 散列
本质：存的时候先开辟一块空间

``` javascript
<script>
	var hash_arr = [];
	hash_arr.length = 5;
	var count = 0;
	function hash_add(n) {
		var pos = n % hash_arr.length;
		if(hash_arr[pos]) {
			while(hash_arr[pos]) {
				if(hash_arr[pos] == n) return;
				pos++;
				if(pos == hash_arr.length - 1) {
					pos = 0;
				}
			}
			hash_arr[pos] = n;
		} else {
			hash_arr[pos] = n;
		}

		count++;
		if(count == hash_arr.length) {
			var oldArr = hash_arr;
			hash_arr = [];
			count = 0;
			hash_arr.length = oldArr.length * 2;
			for (var i = 0; i < oldArr.length; i++) {
				hash_add(oldArr[i]);
			}
		}
	}

	hash_add(35);
	alert(hash_arr);
	hash_add(42);
	alert(hash_arr);
	hash_add(9);
	alert(hash_arr);
	hash_add(22);
	alert(hash_arr);
	hash_add(11);
	alert(hash_arr);
	hash_add(46);
	alert(hash_arr);
	hash_add(32);
	alert(hash_arr);
	hash_add(7);
	alert(hash_arr);
	hash_add(2);
	alert(hash_arr);
	hash_add(12);
	alert(hash_arr);
	hash_add(31);
	alert(hash_arr);
</script>
```

##12.30

###mvc模式
m model 		模型	数据
v view			视图	展示数据
c controller	控制器	从m拿数据，去v展示

HTML 提供数据模型,CSS 负责视图显示,JS 来总管逻辑控制

高内聚、低耦合
	**c层 -> 降低耦合度**

###设计模式
**mvc和设计模式没有关系**

23种设计模式

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

###Angular.js
**需要服务器环境**
mvvm模式
[http://www.angularjsapi.cn/](Angularjs中文版API)
####angular特色：双向绑定 依赖注入
依赖注入：函数参数名字已注入，可以无序

angular封装了部分jQuery用法

1. angular.bind(this指向, 函数名, '参数1'...);		// bind(改变this指向)
2. angular.copy(克隆谁, 克隆给谁);
3. 选择器
angular.element(元素);	// 不能直接通过id等选择元素，只能原生获取后放入element
angular.element(元素).css(属性, 值);	// angular设置样式方法
angular.element(元素).on(事件, 函数);	// angular添加事件方法

``` javascript
<script>
	angular.element(document).ready(function() {
		var oDiv = document.getElementById('div1');
		angular.element(oDiv).css('width', '100px');		// angular设置样式方法
		angular.element(oDiv).on('click', function(event) {	// angular添加事件方法
			alert(1);
		});
	})
</script>
```

4. angular.equals(ele1, ele2);	// angular比较方法

``` javascript
<script>
	var a = 1;
	var b = 1;
	angular.equals(a, b);		// true angular比较方法
	angular.equals(NaN, NaN);	// **true**
</script>
```
5. angular.extend(ele1, ele2);	// angular扩展方法
[http://blog.csdn.net/itsonglin/article/details/47428955](angular.extend方法)
6. angular.forEach(obj, function(v, k){});	// angular循环
``` javascript
<script>
	var arr = [a, b, c, d];
	var json = {a:1, b:2, c:3};
	angular.forEach(arr, function(v, k) {	// value, key
		console.log(v);	// a, b, c, d
		console.log(k);	// 0, 1, 2, 3
	});

	angular.forEach(json, function(v, k) {
		console.log(k);	// 1, 2, 3
		console.log(v);	// a, b, c
	});
</script>

7. angular.isArray();		// 判断是否是数组
8. angular.isDate();		// 判断是否是日期
9. angular.lowercase();	    // 转小写


angular命名：ng-

指令(directive)
1. ng-app   开启angular应用  **一个html里只能出现一次**

2. ng-model	绑定元素值
			eg: `<input type="text" ng-model="a" />
				<p>{{a}}</p>`

3. ng-bind	数据绑定
			eg: `<input type="text" ng-model="a" />
				<p>{{a}}</p>
				<p ng-bind='a'></p>`
4. ng-init	初始化数据
			eg: `<input type="text" ng-init="a=12">
				<p>{{a}}</p>
				<p ng-bind='a'></p>`
5. ng-show
			eg: `<input type="checkbox" ng-model="a">
				<input type="text" ng-show="a">`
6. ng-hide

7. ng-click

8. ng-mouseover

9. ng-repeat 循环
			eg: `<div ng-init="arr=[1, 2, 3]">
					<button ng-click="arr.push(4)">add</button>
					<!-- 添加到数组不能重复 -->
					<ul>
						<li ng-repeat="value in arr">{{value}}</li>
					</ul>
				</div>`

####控制器
ng-controller

angular.module(模块名称, [依赖模块], 配置函数);

eg:
``` javascript
<div ng-controller="show">{{a}}</div>
<script>
	// angular.module(模块名称, [依赖模块], 配置函数);
	var app = angular.module('app', []);	// 最少两个参数
	app.controller('show', function($scope) {
		$scope.a = 12;
	});
</script>
``

多个控制器之间：
1. 可以继承
2. 数据相互传递
- 子级给父级传递：$scope.$emit(数据名称, 数据);
- 父级给子级传递：$scope.$broadcast(数据名称, 数据);
- 接收数据；
$scope.$on(数据名称, function(event, data) {
	console.log(data);
})

$.apply()   数据监测

####过滤器filter
应用在模板里面
语法：
{{data | 过滤器名称}}
{{data | 过滤器名称:参数}}
日期：{{oDate|date:'yyyy-MM-dd hh:mm:ss EEEE'}}
货币：{{ 3600 | currency: "$"}} -> $3600

[http://www.jb51.net/article/66105.htm](AngularJS的内置过滤器详解)
[http://blog.csdn.net/donggx/article/details/53316518](angularjs中的常见过滤器)


``` javascript
<div ng-controller="date">
	{{oDate|date:'yyyy-MM-dd hh:mm:ss EEEE'}}  <!-- 固定格式 -->
</div>
<script>
	// angular.module(模块名称, [依赖模块], 配置函数);
	var app = angular.module('app', []);
	app.controller('date', function($scope, $interval) {
		clock();
		function clock() {
			$scope.oDate = Date.now();
		}
		$interval(clock, 1000);
	})
</script>
``

##1.3

###angular
####过滤器
自定义过滤器
```
<!DOCTYPE html>
<html lang="en" ng-app="app">
    <head>
        <meta charset="utf-8">
    	<script src="angular.min.js"></script>	<!-- 防止屏幕一闪 -->
    </head>
    <body>
		<div ng-controller="test">
			{{arr}}
			limitTo：{{arr|limitTo:3}}
			<hr>
			{{str}}
			lowercase：{{str|lowercase}}
			<hr>
			{{num}}
			number：{{num|number}}
			<hr>
			自定义过滤器：<br>
			1. 首字母大写
			{{str2|firstUp}} <br>
			2. 获取星期
			{{date|getDay}}
			{{date|getDay:'big'}}
			{{date|getDay:'big':'small'}}  <!-- 可传多个参数 -->
		</div>
    	<script>
	    	// angular.module(模块名称, [依赖模块], 配置函数);
    		var app = angular.module('app', []);
    		app.controller('test', function($scope) {
    			$scope.arr = ['A', 'B', 'C', 'D'];
    			$scope.str = 'ArDfs';
    			$scope.num = 12312321;
    			$scope.str2 = '13rq zzf wa';
    			$scope.date = Date.now();
    		});

    		// 自定义过滤器：首字母大写
    		app.filter('firstUp', function() {
    			return function(input) {
    				return input.replace(/\w+/g, function(s) {
    					return s.charAt(0).toUpperCase() + s.substring(1);
    				});
    			}
    		});

    		app.filter('getDay', function() {
    			return function(date, arg) {
    				var oDate = new Date();
    				oDate.setTime(date);
    				if(arg == 'big') {
	    				var arrDay = ['日', '一', '二', '三', '四', '五', '六'];
	    				return '星期' + arrDay[oDate.getDay()];
    				}
    				else {
	    				return '星期' + oDate.getDay();
    				}
    			}
    		})
    	</script>
    </body>
</html>
```

####指令
自定义指令
**驼峰命名，在DOM中使用时需改为-首字母小写**

``` javascript
<script>
	var app = angular.module('app', []);
	app.directive('ngBlue', function() {
		return function(scope, element, attr) {
			console.log(scope);
			console.log(element); // 当前元素
			console.log(attr); // 当前元素属性
			element.css('background', 'blue');
		}
	});

</script>
```

``` javascript
<script>
	var app = angular.module('app', []);
	app.directive('dir1', [function() {
		return {
			restrict: 'ECMA',
			template: '<h3>this is h3</h3>',
			// templateUrl: [模板地址]
			// replace: true,
			// transclude: true;	是否包裹代码
			link: function(scope, element, attr) {
				element.css('background', 'red');
			}
		};
	}]);

</script>
```

restrict限制指令声明格式
- E	element   只限元素名使用
- A	attribute 只限属性使用
- C	class     只限类名使用
- M	moment    只限注释使用

replace
默认为 false，就是将模版的内容追加到元素中，
如果设置为 true，那么模版的内容将会替换元素的内容

####控制器的问题
``` javascript
<script>
	var app = angular.module('app', []);

	// app.controller('test', function($scope) {
	// 	$scope.num = 1212;
	// });

	app.controller('test', ['$scope', function (a) {	// 把参数$scope传给a，防止加密压缩时更改参数$scope
		a.num = 1212;
	}]);
</script>
```

####angular.module的配置函数
控制器：
1. app.controller()
2. $controllerProvider
过滤器：
1. app.filter()
2. $filterProvider
指令：
1. app.directive()
2. $compileProvider

**配置函数注入的是provider**
**控制器注入的是service**

``` javascript
<script>
	// angular.module(模块名称, [依赖模块], 配置函数);
	var app = angular.module('app', [], ['$controllerProvider', '$filterProvider', '$compileProvider', function(
		$controllerProvider,
		$filterProvider,
		$compileProvider
		) {
        // 控制器，过滤器，指令

		// 注册一个控制器
		$controllerProvider.register('appCtrl', ['$scope', function($scope) {
			$scope.b = 1212;
		}]);

		// 注册一个过滤器
		$filterProvider.register('bl', function() {
			return function(val, n) {
				return val.toFixed(n);
			};
		});

        // 自定义指令
        $compileProvider.directive('changeColor', [function () {
            return {
                restrict: 'A',
                link: function (scope, elem, attr) {
                    angular.forEach(elem.children(), function(v, i) {
                        if(i % 2) {
                            angular.element(v).css('background', 'pink');
                        } else {
                            angular.element(v).css('background', 'blue');
                        }
                    });
                }
            };
        }])
	}]);
</script>
```

####自定义服务
``` javascript
<div ng-controller="appCtrl">
	{{a}}
	{{aa}}
</div>
<script>
	// angular.module(模块名称, [依赖模块], 配置函数);
	var app = angular.module('app', [], ['$controllerProvider', '$filterProvider', '$compileProvider', '$provide', function(
        $controllerProvider,
        $filterProvider,
        $compileProvider,
        $provide
    ) {
        // 自定义服务 工厂模式
        $provide.factory('fs', [function () {
        	return {
					a: 1,
					b: 2,
					c: 3
        	};
        }]);

        $controllerProvider.register('appCtrl', ['$scope', 'fs', function($scope, fs) {
			$scope.a = 1212;
			$scope.aa = fs;
		}]);
	}]);
</script>
```

####运行配置
TODO：需研究

app.config();
app.run();		特点：在控制器之前运行

``` javascript
	<div ng-controller="appCtrl">
		{{a}}
	</div>

	<script>
    	// angular.module(模块名称, [依赖模块], 配置函数);
		var app = angular.module('app', []);
		app.factory('$fs', [function () {
			return {a: 2};
		}]);

		// 最后显示
		app.controller('appCtrl', function($scope, $fs) {
			$scope.a = $fs;
		});

		// 再弹
		app.run(function() {
			alert('run');
		});

		// 先弹
		app.config(function() {
			alert('config');
		});
	</script>
```

####angular交互
- ajax

方式1：使用ajax的自定义服务
```
	<body ng-controller="appCtrl">
		<button ng-click="get()"></button>
	</body>
	<script>
    	// angular.module(模块名称, [依赖模块], 配置函数);
    	var app = angular.module('app', []);

    	// ajax的自定义服务
    	app.factory('ajax', [function() {
    		return {
    			ajax: ajax
    		};
    	}]);

    	app.controller('appCtrl', ['$scope', 'ajax', function($scope, ajax) {
    		$scope.get = function() {
    			ajax.ajax({
    				url: 'test.md',
    				success: function(str) {
    					console.log(str);
    				}
    			});
    		}
    	}]);

    	function ajax(json) {
    		//url, data, type, success, error, time, loading, complete
    		//路径, 数据, 方式, 成功回调函数, 失败回调函数, 超时时间, 等待函数，ajax完成后执行的函数
    		json = json || {};
    		if (!json.url) {
    			console.log('url is null');
    			return;
    		}
    		json.data = json.data || {};
    		json.type = json.type || 'get';
    		json.time = json.time || 3000;

    		var timer = null;
    		clearTimeout(timer);

    		if (window.XMLHttpRequest) {
    			var oAjax = new XMLHttpRequest();
    		} else {
    			var oAjax = new ActiveXObject("Microsoft.XMLHTTP");
    		}

    		switch (json.type.toLowerCase()) {
    			case 'get':
    				oAjax.open('GET', json.url + '?' + jsonToURL(json.data), true);
    				oAjax.send();
    				break;
    			case 'post':
    				oAjax.open('POST', json.url, true);
    				oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    				oAjax.send(jsonToURL(json.data));
    				break;
    		}

    		json.loading && json.loading();
    		oAjax.onreadystatechange = function() {
    			if (oAjax.readyState == 4) {
    				json.complete && json.complete();
    				if (oAjax.status >= 200 && oAjax.status < 300 ||
    					oAjax.status == 304) {
    					json.success && json.success(oAjax.responseText);
    				} else {
    					json.error && json.error(oAjax.status);
    				}
    				clearTimeout(timer);
    			}
    		};

    		timer = null;
    		timer = setTimeout(function() {
    			console.log('请求超时');
    			oAjax.onreadystatechange = null;
    		}, json.time);
    	}

    	function jsonToURL(json) {
    		var arr = [];
    		for (var name in json) {
    			arr.push(name + '=' + json[name]);
    		}
    		return arr.join('&');
    	}
	</script>
```

方式2：使用angular自带模块$http
```
	<body ng-controller="appCtrl">
		<button ng-click="get()"></button>
		<button ng-click="par()"></button>
	</body>
	<script>
		var app = angular.module('app', []);

		app.controller('appCtrl', function($scope, $http) {
			$scope.get = function() {
				$http.get('test.md').success(function(data) {
					console.log(data);
				}).error(function(err) {
					console.log(err);
				});
			};

			// 传参形式
			$scope.par = function() {
				$http.get('test.php', {
					params: {
						a: 1,
						b: 2
					}
				}).success(function(data) {
					console.log(data);
				}).error(function(err) {
					console.log(err);
				});
			};
		});
	</script>
```

- jsonp

**注意：callback=JSON_CALLBACK  唯一写法**

```
	<body ng-controller="appCtrl">
		<button ng-click="()"></button>
		<button ng-click="par()"></button>
	</body>
	<script>
		var app = angular.module('app', []);

		app.controller('test', function($scope, $http) {
			$scope.get = function() {
				$http.jsonp('http://api.asilu.com/ip/?ip=www.baidu.com&callback=JSON_CALLBACK').success(function(data) {
					$scope.b = data.date;
				});
			};
		});
	</script>
```

##1.4

###angular
####SPA(single page application, 单页面应用)

ng-include 用于包含外部的HTML文件
**注意：ng-include里面是字符串 需另加单引号**

``` javascript
<!DOCTYPE html>
<html lang="en" ng-app="app">
    <head>
        <meta charset="utf-8">
        <script src="angular.min.js"></script>
    </head>
    <body>
    <div ng-include="'nav.html'"></div>	<!-- 注意ng-include里面是字符串 需另加单引号 -->
    <script>
    	var app = angular.module('app', []);

    </script>
    </body>
</html>
```

####路由
ui-router

ui-router.html
``` html
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>ui-router test</title>
	<link rel="stylesheet" href="css/bootstrap.min.css">
	<script src="js/angular.min.js"></script>
    <script src="js/angular-ui-router.min.js"></script>
    <script src="uirouter.js"></script>
</head>
<body ng-app="routerApp">
    <div ui-view></div>
</body>
</html>
```

index.html
``` html
<div class="container">
	<div ui-view="topbar"></div>
	<div ui-view="main"></div>
</div>
```

topbar.html
``` html
<nav class="navbar navbar-inverse" role="navigation">
	<ul class="nav navbar-nav">
		<li><a ui-sref="index">homepage</a></li>
		<li><a ui-sref="index.usermng">user management</a></li>
		<li><a ui-sref="index">homepage</a></li>
	</ul>
</nav>
```

main.html
``` html
<div class="jumbotron text-center">
	<h2>homepage</h2>
	<p>
		homepage style always be <span class="text-danger">flexible</span>
	</p>
</div>
```

usermng.html
``` html
<div class="row">
	<div class="col-md-3">
		<div class="row">
			<div class="col-md-12">
				<div class="list-group">
					<a ui-sref="#" class="list-group-item active">divide user</a>
					<a class="list-group-item">high</a>
					<a class="list-group-item">normal</a>
					<a class="list-group-item">low</a>
				</div>
			</div>
		</div>
		<div class="row">
			<div class="col-md-12">
				<button class="btn btn-primary" ng-click="addUserType()">add user</button>
			</div>
		</div>
	</div>
	<div class="col-md-9">
		<div ui-view></div>
	</div>
</div>
```

``` javascript
    <script>
    	var routerApp = angular.module('routerApp', ['ui.router']);
    	routerApp.config(function($stateProvider, $urlRouterProvider) {
    		$urlRouterProvider.otherwise('/'); //open html
    		$stateProvider
    			.state('index', {
    				url: '/',
    				views: {
    					'': {
    						templateUrl: 'view/index.html'
    					},
    					'topbar@index': {
    						templateUrl: 'view/topbar.html'
    					},
    					'main@index': {
    						templateUrl: 'view/main.html'
    					}
    				}
    			})
    			.state('index.usermng', {
    				url: '/user',
    				views: {
    					'main@index': { //replace html
    						templateUrl: 'view/usermng.html',
    						controller: function($scope, $state) {
    							$scope.addUserType = function() {
    								// $scope.xxx = 'xxx';
    							}
    						}
    					}
    				}
    			})
    	})
    </script>
```

###vue
[http://v1-cn.vuejs.org/guide/](Vue手册)
兼容：IE9+、Chrome、FF

- 各类指令

```
<!-- 双向绑定 -->
<div id="div1">{{data1}}</div>
<div class="div1">{{data2}}  {{data3}}</div>
<div class="div1">{{data2}}</div>
<div id="div2">
	<input type="text" v-model="msg"/>
	<p>{{msg}}</p>
</div>
<!-- for循环 -->
<div id="div3">
	<a href="javascript:;" v-for="val in arr">{{val}}  {{$index}}</a>
	<ul>
		<li v-for="{key,value} in jsonD">{{value}}</li>
	</ul>
</div>
<script>
	new Vue({
		el: '#div1',
		data: {
			data1: 'wsfssagadsww'
		}
	});

	new Vue({
		el: '.div1',	// 选择多个元素时只对第一个有效
		data: {
			data2: 'rywrsgvcbxff',
			data3: 'agbfagdahvceyuj'
		}
	});

	new Vue({
		el: '#div2',
		data: {
			msg: '双向绑定'
		}
	});

	new Vue({
		el: '#div3',
		data: {
			arr: [132, 142124 , 'zfaf', 523],
			jsonD: {a: 'das', b:'fafa', c:'agds'}
		}
	});
</script>
```

```
<!-- v-bind v-show v-if v-else 过滤器 -->
<div id="div1">
	<div v-bind:class="{red:a,blue:b}"></div>
	<div class="red" v-bind:style="{width:w}"></div>
	<p v-show="false">1212</p>
	<input type="checkbox" v-model="c" />
	<p v-if="c">1212</p>	<!-- c为假，走else，if整个DOM删除 -->
	<p v-else="c">333333</p>
	{{m | currency '￥' 2}}
</div>
<script>
	new Vue({
		el: '#div1',
		data: {
			msg: 'hi Vue',
			a: true,
			b: false,
			c: '',
			m: 1000
		},

	});
</script>
```

- 事件
两种方式添加事件
1. v-on:click = "add()"
2. @click = "add()"

> 不传参可以不加括号

```
<div id="div1">
	<input type="text" placeholder="请输入东西" v-model="msg" @keyup.13="add" />
	<input type="button" value="添加" @click="add()" />
	<ul>
		<li v-for="val in mdata">
			{{val}}
			<a href="javascript:;" @click="del($index)">删除</a>
		</li>
	</ul>
</div>
<script>
	new Vue({
		el: '#div1',
		data: {
			msg: '',
			mdata: []
		},
		methods: {
			add: function() {
				if(this.msg == '') {
					alert('不能为空');
					return;
				}
				this.mdata.unshift(this.msg);
				this.msg = '';
			},
			del: function(index) {
				this.mdata.splice(index, 1);
			}
		}
	});
</script>
```
- 自定义指令

```
<div v-red id="div1">
	背景颜色变了
</div>
<script>
	Vue.directive('red', function() {
		this.el.style.backgroundColor = 'red';
	});
	new Vue({
		el: '#div1'
	});
</script>
```

自定义指定传参
```
<div v-red="'<h1>字也变了</h1>'" id="div1">	<!-- 注意指令赋值是字符串 -->
	背景颜色变了
</div>
<script>
	Vue.directive('red', function(value) {
		this.el.style.backgroundColor = 'red';
		this.el.innerHTML = value;
	});
	new Vue({
		el: '#div1'
	});
</script>
```

自定义指令应用于标签
**不建议使用**
```
<div id="div1">
	背景颜色没变
	<v-red>背景颜色变了</v-red> <!-- 现在不是块元素了 -->
</div>
<script>
	Vue.elementDirective('v-red',{
		bind:function(){
			this.el.style.backgroundColor='red';
		}
	});
	new Vue({
		el:'#div1',
	});
</script>
```
- 自定义过滤器
```
<div id="div1">
	{{msg|reverse}}
	{{msg|reverse2 'a1' 'b1'}}
</div>
<script>
	Vue.filter('reverse', function(input) {
		return input.split(' ').reverse().join(' ');
	});

	Vue.filter('reverse2', function(input, a, b) {
		return input.split(' ').reverse().join(' ') + a + b;
	});

	new Vue({
		el: '#div1',
		data: {
			msg: 'hello vue world'
		},
	});
</script>
```

##1.5

###vue
####vue事件

阻止冒泡：
- ev.propageation()
- @click.stop = "show()"

阻止默认：
- ev.preventDefault()
- @contextmenu.prevent = "show()"

阻止冒泡、，默认
@contextmenu.stop.prevent = "show()"

@keyup.键码 = "show($event)"
或者
@keyup.enter = "show($event)"
@keyup.left = "show($event)"

####vue动画
定义动画：
```
<style>
	.动画名称-transition {

	}
	.动画名称-enter {

	}
	.动画名称-leave {

	}
</style>

<div transition="动画名称"></div>

```
####vue监听

var v = new Vue(...);
v.$watch(监听对象, function() {});
v.$watch(监听对象, function() {}, {deep:true});	// 深度监听

####vue组件
1.
**注意：组件命名时需改为驼峰**
```
<div id="box">
	<aa msg="this is msg" img-src="xx.jpg"></aa>
</div>
<script>
	Vue.component('aa', {
		props: ['msg', 'imgSrc'],	// 接收参数，**行间命名改为驼峰**
		template: '<div>{{msg}} <img :src="imgSrc"></div>'
	});

	new Vue({
		el:'#box',
	});
</script>

```

2.vue SPA  (vue-router库)

```
<div id="box">
	<a v-link="{path: '/reg'}">register</a>
	<a v-link="{path: '/log'}">login</a>
	<router-view></router-view>
</div>
<script>
	var Reg = Vue.extend({
		template: '<div>regsiter</div>'
	});

	var Log = Vue.extend({
		template: '<div>login</div>'
	});

	// 把组件加进路由
	var app = Vue.extend({});
	var Router = new VueRouter();

	Router.map({
		'/reg': {
			component: Reg
		},
		'log': {
			component: Log
		}
	});

	Router.start(app, '#box');		// 开启路由
</script>
```

####vue交互
(vue-resource库)

1.get
2.post **注意：post需要设置请求头emulateJSON**
3.jsonp

```
<script>
methods: {
	get: function() {
		this.$http.get('xxx.txt', {a: 1, b: 2}).then(function(res) {	// 成功回调函数
			console.log(res);
			console.log(res.data);
		}, function(res) {		// 失败回调函数
			console.log(res.data);
		})
	}
}

methods: {
	post: function() {
		// post方式需设置请求头emulateJSON
		this.$http.post('xxx.txt', {a: 1, b: 2}, {emulateJSON: true}).then(function(res) {	// 成功回调函数
			console.log(res);
			console.log(res.data);
		}, function(res) {		// 失败回调函数
			console.log(res.data);
		})
	}
}

methods: {
	get: function() {
		this.$http.jsonp('https://xxx?', {wd: 2}, {jsonp: 'cb'}).then(function(res) {	// 成功回调函数
			console.log(res);
			console.log(res.data);
		}, function(res) {		// 失败回调函数
			console.log(res.data);
		})
	}
}

</script>
```
##1.6
###高级运动
弧度转角度：
公式：180/π*弧度
	  n*180/PI
```
<script>
	// 计算从哪个方向移入
	// 0：右  1：下  2：左  3：上
	function action(obj, ev) {
		var h = obj.offsetHeight;
		var w = obj.offsetWidth;
		var y = obj.offsetTop + h / 2 - ev.clientY;
		var x = obj.offsetLeft + w / 2 - ev.clientX;
		//return Math.atan2(y,x);//弧度值
		//弧度值转角度
		//return Math.atan2(y,x)*180/Math.PI;
		//变成一个圆的度数
		//return  Math.atan2(y,x)*180/Math.PI+180;
		//分四份
		//return  (Math.atan2(y,x)*180/Math.PI+180)/90
		//获取 0 1 2 3
		return Math.round((Math.atan2(y, x) * 180 / Math.PI + 180) / 90) % 4;
	}
</script>

#### 弹性运动
摩擦力:速度*=小于1的数

弹性运动公式：
	iSpeed+=(目标-left)/20;
	iSpeed*=0.9;
弹性运动停止条件：
	Math.round(left)==目标点&&Math.round(iSpeed)==0

```
<script>
	function elastic(obj, td) {
		var iSpeed = 0;
		var left = 0;
		var timer = null;
		clearInterval(timer);
		timer = setInterval(function() {
			iSpeed += (td - left) / 20;
			iSpeed *= 0.9;

			left += iSpeed;
			if (Math.round(iSpeed) == 0 && Math.round(left) == td) {
				clearInterval(timer);
			}
			obj.style.left = left + iSpeed + 'px';
		}, 30);
	}
</script>
```

#### 碰撞运动

```
<script>
	function collision(obj) {
		var iSpeedX = 3; //横向速度
		var iSpeedY = 6; //纵向速度
		var timer = null;
		timer = setInterval(function() {
			iSpeedY += 9;
			iSpeedX += 1;
			var l = obj.offsetLeft + iSpeedX;
			var t = obj.offsetTop + iSpeedY;
			if (t > document.documentElement.clientHeight - obj.offsetHeight) {
				t = document.documentElement.clientHeight - obj.offsetHeight;
				iSpeedY *= -1;
				iSpeedX *= 0.8;
			}
			if (t <= 0) {
				t = 0;
				iSpeedY *= -1;
			}
			if (l > document.documentElement.clientWidth - obj.offsetWidth) {
				l = document.documentElement.clientWidth - obj.offsetWidth;
				iSpeedX *= -1;
				iSpeedY *= 0.8;
			}
			if (l <= 0) {
				l = 0;
				iSpeedX *= -1;
			}
			obj.style.left = l + 'px';
			obj.style.top = t + 'px';
			if (Math.abs(iSpeedX) < 1) iSpeedX = 0;
			if (Math.abs(iSpeedY) < 1) iSpeedY = 0;
			if (iSpeedX == 0 && iSpeedY == 0) {
				clearInterval(timer);
			}
		}, 30);
	}
</script>
```

###gulp、grunt
前端自动化工具
基于node.js
构建项目
压缩  js  css html  图片

配置任务
*  所有文件
** 所有目录

gulp：快  格式和node差不多    操作的是二进制流
grunt：慢 格式是json套json    操作的是文件

grunt: package.json  GruntFile.js

GruntFile.js
```
<script>
	module.exports = function(grunt) {
		// 导入模块
		grunt.loadNpmTasks('grunt-contrib-uglify');
		grunt.loadNpmTasks('grunt-contrib-cssmin');
		grunt.loadNpmTasks('grunt-contrib-htmlmin');
		grunt.loadNpmTasks('grunt-contrib-imagemin');
		grunt.loadNpmTasks('grunt-contrib-watch');

		// 配置任务
		grunt.initConfig({
			// js压缩 默认加密压缩
			uglify: { // 主任务名称
				options: { // [配置选项]
					mangle: false // 是否加密压缩
				},
				a: { // 子任务名称
					expand: true, // 是否分开压缩
					src: 'js/*.js',	// 源文件
					dest: 'build'	// 目标文件 自动创建源文件文件夹
				}
			},
			cssmin: {
				a: {
					expand: true,
					src: 'css/*.css',
					dest: 'build'
				}
			},
			htmlmin: {
				options: {
					removeComments: true,	// 是否移除注释
					collapseWhitespace: false	// 是否去掉空白
				},
				a: {
					src: '*.html',
					dest: 'build'
				}
			},
			// imagemin: {
			// 	a: {
			// 		expand: true, //分开执行
			// 		cwd: 'images',
			// 		src: ['**/*.{png,jpg}'],
			// 		dest: 'build/images'
			// 	}
			// },
			watch: {
				a: {
					files: ['*.html', 'css/*.css', 'js/*.js'],
					tasks: ['cssmin', 'htmlmin', 'uglify']
				}
			}
		});

		// 注册一个默认任务
		grunt.registerTask('default', ['uglify', 'cssmin', 'htmlmin', 'watch']);
	}
</script>
```

gulp: package.json  gulpfile.js

gulpfile.js
```
<script>
	// 导入模块
	var gulp = require('gulp');
	var cssmin = require('gulp-cssmin');
	var uglify = require('gulp-uglify');
	var htmlmin = require('gulp-htmlmin');
	var concat = require('gulp-concat');
	var rename = require('gulp-rename');	// 改名

	// 配置任务
	gulp.task('uglify:css', function() {
		gulp.src('css/*.css')
			.pipe(cssmin())		// 压缩
			.pipe(concat('all.min.css'))	// 合并
			.pipe(gulp.dest('build/css'))	// 输出
	});
	gulp.task('uglify:js', function() {
		gulp.src('js/*.js')
			.pipe(uglify())					// 压缩
			.pipe(gulp.dest('build/js'))	// 输出
	});
	gulp.task('uglify:html', function() {
		gulp.src('*.html')
			.pipe(htmlmin({					// 压缩
				collapseWhitespace: true,
				removeComments: true
			}))
			.pipe(gulp.dest('build'))		// 输出
	});

	gulp.watch('*.*', ['uglify:css', 'uglify:js', 'uglify:html']);

	gulp.task('default', ['uglify:css', 'uglify:js', 'uglify:html']);
</script>
```

gulpfile.js
```
<script>
	var gulp = require('gulp');
	var uglify = require('gulp-uglify');
	var clean = require('gulp-clean-css');
	var sass = require('gulp-sass');

	gulp.task('uglify',function(){
		return(
			gulp.src('./src/*.js')
				.pipe(uglify())
				.pipe(gulp.dest('dist'))
		)
	})

	gulp.task('minify-css',function(){
		return (
			gulp.src('./src/*.css')
				.pipe(clean())
				.pipe(gulp.dest('dist'))
		)
	})

	gulp.task('compile-sass',function(){
		return (
			gulp.src('./src/*.scss')
				.pipe(sass().on('error', sass.logError))
				.pipe(gulp.dest('dist'))
		)
	})

	gulp.task('default',function(){
		gulp.watch('./src/*.js',['uglify']);
		gulp.watch('./src/*.css',['minify-css']);
		gulp.watch('./src/*.scss',['compile-sass']);
	})
</script>
```

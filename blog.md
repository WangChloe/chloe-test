<!-- MarkdownTOC -->

- blog1
	- 1. js六大数据类型
		- 基本数据类型
		- 复杂数据类型
	- 2. 数据类型补充
	- 3. 数字相关判断方法
	- 4. 变量
	- 5. 运算符
	- 6. 常见变量命名前缀
	- 7. 字符串转化为数字
		- parseInt\(\)
		- parseFloat\(\)
		- Number\(\)
	- 8. 数字转化为字符串
	- 9. if语句变形
	- 10. **js**及**事件**的笼统概念
- blog2
	- 1. js操作元素属性
	- 2. js设置复杂样式
	- 3. 物体从中心放大
	- 4. a链接防止刷新
	- 5. 循环添加事件，事件中的循环变量不能用
	- 6. 浏览器加载的过程
	- 7. DOM获取元素方法
			- 兼容写法
	- 8. js中的真假
	- 9. 获取元素当前样式\(兼容\)
	- 10. 获取一个n~m之间的随机数\(n<m，且不包括m\)
- blog3
	- 1. 返回值问题\(return\)
	- 2. undefined出现的情况
	- 3. eval\(字符串\)
	- 4. 数字小于10的补零函数
	- 5. 定时器
		- \(1\) Interval\(每过一段时间执行一次，循环执行\)
		- \(2\) Timeout\(过一段时间执行一次，只执行一次\)
	- 6. 日期对象
	- 7. 日期对象应用
		- 本月有多少天
		- 本月第一天是周几
		- 本月最后一天是周几
		- 倒计时
	- 8. 事件函数相同可以合并
	- 9. this
		- \(1\) 定时器中的this不指向元素，指向window
		- \(2\) 调用封装函数使用this，this不指向元素，指向window
		- \(3\) 低级浏览器attachEvent)事件绑定里面的this 报错
	- 10. 闭包
- blog4
	- 1. 参数的数组arguments
	- 2. 设置样式的三种方法
	- 3. 字符串的相关方法
	- 4. 字符串比较
	- 5. 字符串应用
		- 判断浏览器的类型
		- 判断上传文件格式
	- 6. 定义数组
	- 7. 数组的相关方法
	- 8. json\(object类型\)
		- json和数组的区别
			- length
			- 循环遍历方法
		- 访问元素下标类型
			- 顺序
	- 9. Math方法
	- 10. try-catch捕获异常
- blog5\(数组应用\)
	- 1. 数组翻转方法2
	- 2. 首字母大写
	- 3.快速清空数组
	- 4. 数组排序方法
	- 5. 数组内查找元素是否存在
	- 6. 数组去重的多种方法
		- \(1\)findInArr
		- \(2\)json\(自动从小到大排序\)
		- \(3\)sort\(\)
		- \(4\) indexOf
		- \(5\)二分法
		- \(6\)Map\(ES6\)
		- \(7\)Set\(ES6\)
	- 补一个字符串的应用
		- \(1\) 字符串中出现次数最多的字符
- blog6
	- 1. select下拉框的相关属性
	- 2. 预解析
	- 3. 已知计算机编码查看对应单词
	- 4. 字节长度和编码的关系
		- 封装一个求字节长度的函数
	- 5. 严格模式
	- 6. 连等及逗号运算符
		- 连等
		- 逗号运算符
	- 7. 文本提示框
	- 8. form表单
- blog7\(js组成\)
	- 1. js实现的组成
		- ECMA
		- DOM
		- BOM
	- 2. DOM节点关系
	- 3. DOM节点操作
	- 4. DOM属性操作
	- 5. BOM
- blog8\(各种宽高，距离\)
	- 1. 滚动距离
	- 2. 滚动高度
	- 3. 可视区高度
	- 4. 物体高度
	- 5. offsetHeight && getStyle\(\)
	- 6. 物体的相对距离
	- 7. 关于父级
	- 8. 封装一个物体距离左边/上边的绝对位置的函数
- blog9\(事件篇\)
	- 1. 事件对象
	- 2. 事件冒泡
	- 3. 事件绑定
	- 4. 关于捕获\(这点理解不是很到位\)
	- 5. 事件解绑
	- 6. 查看鼠标点击位置
	- 7. 键盘事件
		- 键码 `oEvent.keyCode`
	- 8. 鼠标事件
		- 判断滚动方向
	- 9. domReady
	- 10. 事件委托
	- 11. 事件源
		- 给子级循环添加事件 闭包的替代写法 -> 委托
- blog10\(原生运动框架\)
	- move.js
- blog11\(move框架应用\) \(上\)
	- 1. 仿jiaThis分享到
	- 2. 幻灯片
	- 3. 手风琴
	- 4. 多图片展开
- blog12\(move框架应用\) \(中\)
	- 5. 运动时钟
	- 6. 返回顶部
	- 7. 无缝滚动
	- 8. 无缝幻灯片
	- 9. 带进度条的无缝幻灯片
- blog13\(move框架应用\) \(下\)
	- 10. 打字依次显示效果
	- 11. 收起当前页放出下一页效果
	- 12. 分块运动
	- 13. 仿Mac 感应变大效果
- blog14\(前端规范\)
	- 1. Reset.css && Normailze.css
		- Reset
		- Normailze
	- 2. css命名规范
	- 3. 注释的写法
	- 4. id命名
		- \(1\)页面结构
		- \(2\)导航
		- \(3\)功能
	- 5. class的命名
	- 6. css层次
	- 7. css书写次序
	- 8. 媒体查询\(media\)屏幕宽度
	- 9. js常见变量命名
- blog15\(原生篇6\) cookie、Require、数据交互前导
	- 1. cookie
		- 封装cookie.js
	- 2. 模块化
		- sea.js && require.js
	- 3. Require.js
			- \(1\)定义模块
			- \(2\)使用模块
			- \(3\)引用模块
		- Require的使用结构一般如下
	- 4. 数据交互
		- form提交数据
		- ajax\(Asynchronous JavaScript and XML，异步JavaScript和XML\)
	- 5. eval的替代用法
	- 6. 数据交互时输入中文问题
- blog16\(ajax jsonp\)
	- 1. Ajax前导
		- \(1\) XMLHttpRequest
		- \(2\) readyState就绪状态
		- \(3\) HTTP状态码
		- \(4\) ajax提交方式
	- 2. Ajax
	- 3. Ajax服务器相关
	- 4. Ajax2.0事件
	- 5. 关于锚点hash
	- 6. Ajax跨域
		- js跨域请求方式
	- 7. jsonp前导
	- 8. jsonp
	- 9. 跨浏览器的CORS
- blog17\(jQuery上\)
	- 1. jQuery && js
	- 2. jQuery效果
	- 3. jQuery选择器
		- \(1\) 伪类选择器
		- \(2\) 属性选择器
	- 4. jQuery操作css属性
	- 5. jQuery操作内容
	- 6. jQuery操作类名
	- 7. jQuery操作属性
	- 8. jQuery DOM
		- \(1\) 创建元素
		- \(2\) 添加元素
		- \(3\) 删除元素
	- 9. jQuery事件
		- 事件相关
		- 事件委托
- blog18\(jQuery下\)
	- 1. jQuery获取物体信息
		- js
		- jQuery\(只封装了以下方法\)
	- 2. jQuery筛选
		- \(1\) 过滤
		- \(2\) 查找
	- 3. jQuery  js
		- \(1\) 原生js转jQuery对象
		- \(2\) jQuery转原生js对象
	- 4. jQuery链式运动
	- 5. jQuery循环
	- 6. jQuery工具
	- 7. jQuery Ajax
	- 8. jQuery jsonp
	- 9. jQuery插件
		- 写插件
		- 一个插件
		- 一组插件
- blog19\(正则\)
	- 1. 正则表达式
		- RegExp对象
	- 2. 正则定义的多种方法
	- 3. 正则校验
	- 4. 正则使用的字符串相关方法
	- 5. 特殊字符
	- 6. 元字符\(一个字符\)
	- 7. 限定符
	- 8. 转义字符
	- 9.单词边界
	- 10. 简单示例
- blog20\(正则应用\)
	- 1. 校验座机号码
	- 2. 校验邮箱
	- 3. 校验年龄\(18-100\)
	- 4. 仿trim\(\)去除首尾空格
	- 5. 校验名字
	- 6. 首字母大写
	- 7. 过滤标签
	- 8. 正则getByClass等方法
- blog21\(性能优化\)
	- 1. 性能优化
	- 2. 重排 && 重绘
		- \(1\) 重排\(reflow\)
		- \(2\) 重绘
	- 3. 图层
	- 4. 执行性能优化
	- 5. 网络性能优化
		- 查看网络性能 F12 -> network
			- 工具
		- 网络性能提升方法
	- 6. 垃圾回收 GC\(Gabage Collection\)
	- 7. 递归
- blog22\(面向对象\)
	- 1. 面向对象
		- \(1\) 对象组成
		- \(2\) 面向对象特征
		- \(3\) 对象相关方法
			- 执念
	- 2. 引用类型
		- Array.sum实现原理
		- Array.forEach实现原理
		- Array.every实现原理
		- Array.some原理
		- Array.map原理
		- Array.reduce原理
		- Function.bind原理
	- 3. 创建对象前导
		- \(1\) 关于new
		- \(2\) 关于this
			- 强制改变this指向
- blog23\(面向对象 中\)
	- 4. 创建对象
		- \(1\) 工厂模式
		- \(2\) 单例模式
		- \(3\) 构造函数模式
		- \(4\) 原型模式
			- 重写prototype将导致实例的constructor转向
		- \(5\) 构造+原型
	- 5. 原型与原型链
		- 关于原型
		- 关于原型链
	- 6. 原型应用
		- \(1\) 数组arr.indexOf\(\)兼容问题
		- \(2\) 字符串str.trim\(\)兼容问题
- blog24\(面向对象 下\)
	- 7. 如何编写面向对象程序
	- 8. 面向对象：继承
		- 实例：自动播放选项卡\(继承\)
	- 9. 解决变量名冲突的多种方法
	- 10. 伪数组问题
	- 11. js的冒泡\(Bubbling Event\)和捕获\(Capture Event\)的区别
		- 阻止冒泡
		- 阻止捕获
	- 12. 如何写一个自己的框架
		- 仿写jQuery要点回顾
		- Chloe.js仿写部分jQuery功能
- blog25 \(算法与数据结构\)
	- 1. 查找算法
		- 以有序数组查找定值为例
			- \(1\) 线性查找
			- \(2\) 二分法查找
				- 二分法应用
	- 2. 排序算法
		- \(1\) 交换排序
			- 冒泡排序
			- 快速排序
		- \(2\) 选择排序
			- 直接选择
			- 堆排序
		- \(3\) 归并排序
	- 3. 数据结构
		- \(1\) 有序数组
		- \(2\) 无序数组
		- \(3\) 二叉树
		- \(4\) 队列
		- \(5\) 堆栈
		- \(6\) 散列
- blog 26 \(代码管理与常见命令\)
	- 1. svn代码版本管理工具
	- 2. git分布式版本控制系统
		- 工作区
		- 缓存区
		- 本地仓库
		- 服务器仓库
		- 其他
		- reset的两种用法
		- reset命令的3种方式
	- 3. git的使用姿势
		- \(1\) 本地代码放到github上
		- \(2\) 服务器仓库已有项目
		- 多人合作
		- 关于SSH配置
	- 4. git与svn的区别
	- 5. 常用命令
		- DOS
		- Linux
			- 编辑文件
		- Node.js
	- 6. 常用快捷键
		- Windows
		- Firebug
		- 调试
		- Sublime
		- Emmet
- blog27 \(HTML5\)
	- HTML5语法概要
	- 1. H5新增元素
		- \(1\) 结构元素
			- section
			- article
			- aside
			- nav
			- figure
			- time
			- pubdate
			- header
			- footer
			- hgroup
			- address
			- 整体应用
		- \(2\) 其他元素
			- video
			- audio
			- canvas
			- meter
			- progress
			- details summary
			- ...
		- \(3\) input元素类型
		- \(4\) *废除的元素
	- 2. H5新增属性
		- \(1\) 表单相关属性
			- form
			- formaction
			- formmethod
			- formenctype
			- formtarget
			- autofocus
			- require
			- labels
			- placeholder
			- datalist
			- autocomplete
			- pattern
			- selectionDirection
			- indeterminate
			- image按钮的width/height
		- \(2\) 链接相关属性
		- \(3\) 其他属性
		- \(4\) *废除属性
		- \(5\) 全局属性
	- 3. H5选择器补充
		- querySelectorAll 对比 getElements 的优势
		- jQuery的选择器即是querySelectorAll
	- 4. H5自定义属性 dataset
	- 5. H5元素类名操作 classList
		- 隐式原型上的方法\(不一一列举\)
	- 6. H5本地存储 localStorage
		- Web Storage实际上由两部分组成：sessionStorage与localStorage
		- sessionStorage与localStorage操作相同
	- 7. H5地理位置 geolocation
		- \(1\) 测试用例
			- PositionError
		- \(2\) 百度地图API
	- 8. H5音频 audio
		- \(1\) 属性
		- \(2\) 方法
		- \(3\) 应用：钢琴弹奏
		- \(4\) 应用：音乐播放器
	- 9. H5视频 video
		- \(1\) 属性
		- \(2\) 方法
	- 10. H5文件 FileReader
		- \(1\) 文件拖拽
		- \(2\) File接口
		- \(3\) 示例
	- 11. H5 web工作线程 webworker
		- \(1\) 方法
		- \(2\) 示例
	- 12. H5 webSocket 网络套接字
	- 13. H5画布 canvas
		- \(1\) 应用 canvas笑脸
		- \(2\) 应用 canvas画图
		- \(3\) 应用 canvas变换
		- \(4\) 应用 canvas内长方形拖拽
		- \(5\) 应用 canvas内圆形拖拽
		- \(6\) 应用 下载canvas绘图
		- \(7\) 应用 canvas运动回调
		- \(8\) canvas框架 jCanvaScript.js
	- 14. H5内联SVG
		- \(1\) 位图 && 矢量图
		- \(2\) SVG使用
		- \(3\) SVG梗概
		- \(4\) SVG应用
			- 2017
		- \(5\) 矢量图形库 Raphael.js
- blog28 \(杂技\)
	- 1. toString\(\) && valueOf\(\)
	- 2. JSON stringify & parse
	- 3. +new Date\(\)
	- 4. Array.prototype.slice.call\(arguments, 0\) 剖析
	- 5. JS Bridge建立Native与H5间通信
		- Hybrid通信原理
		- JS Bridge
- blog29 \(css3\)
	- 1. CSS3老版浏览器兼容处理
	- 2. CSS3新增选择器
		- 属性选择器
		- 结构选择器
	- 3. CSS3新增属性
		- 色值透明度 rgba
		- 文字阴影 text-shadow
		- 文字省略 text-overflow
		- 圆角 border-radius
		- 盒子阴影 box-shadow
		- 变换 transform \(搭配transition使用效果更佳\)
		- 过渡 transition
		- 动画 animation
		- 视角 perspectiv
		- 文字转向 direction
		- 遮罩 -webkit-mask
		- 倒影 box-reflect
		- 文字阴影 text-shadow
		- 调整尺寸 resize
		- background-image内的一些属性
			- linear-gradient 线性渐变
			- radial-gradient 径向渐变
			- repeating-linear-gradient 重复渐变
		- background相关属性
			- background-origin 相对于内容框来定位背景图像
			- background-clip 裁剪背景图片
			- background-attachment
			- background-size 背景图像尺寸
			- background-position 背景图像定位
		- 滤镜 filter
	- 4. CSS3媒体查询 media
		- 媒体类型
		- 媒体功能
		- meida大全
- blog30
- blog \(bootstrap\)
- blog \(es6\)
- blog \(mvc\)
- blog angular
- blog vue
- blog react
- blog \(构建工具 gulp & grunt\)
- blog \(Node.js\)
- blog \(移动端\)
- blog \(移动端web\)
- blog \(移动端app\)

<!-- /MarkdownTOC -->


---
#blog1

---

## 1. js六大数据类型

> null并非typeof出来的类型，不过由于null不可再分，所以将其归于基本数据类型之中。

> typeof类型：undefined、boolean、string、number、object、function

**以下是根据ECMAScript标准的数据类型分类**

### 基本数据类型
- Number    数字
- String    字符串
- Boolean   布尔
- Undefined 未定义
- **Null 空对象**

- Symbol  独一无二的值(ES6新增)

### 复杂数据类型
- Object    对象(可拆分为多种数据类型)

## 2. 数据类型补充

- null空对象 -> 数据类型(object)
- NaN 非数字 -> 数据类型(number)

>  NaN和任何数据类型都不相等，包括自己

## 3. 数字相关判断方法

- ### 是否是数字
isNaN() 非数字->true  数字->false
- ### 是否是整数
if(num == parseInt(num))

## 4. 变量

1. ### 全局变量
2. ### 局部变量
3. ### 闭包
	  子函数可以使用父函数的全局变量

> 变量的遮蔽
  全局变量和局部变量同名
  就近原则->在函数里优先使用自己的变量

## 5. 运算符

1. ### 算术运算符
2. ### 比较运算符
		== -> !=	=== -> !==
3. ### 赋值运算符
4. ### 逻辑运算符

## 6. 常见变量命名前缀
| 前缀 | 		全称      |     含义 	 		 | 示例       |
| :--: | 	   :----: 	  |   :----: 	 		 | :---:      |
| o    | 	   object  	  |   一个对象，一个元素 | oDiv       |
| a    | 	   array 	  |   一组元素 			 | aLi        |
| s    | 	   string 	  |   字符串 			 | sUserName  |
| i    | 	   integer    |   整数 				 | iCount     |
| f    | 	   float 	  |   浮点数 			 | fPrice	  |
| b    | 	   boolean    |   布尔 				 | bOk		  |
| fn   | 	   function   |   函数 				 | fnSucc	  |
| re   | 	   RegExp     |   正则 				 | reMailCheck|

## 7. 字符串转化为数字
### parseInt()
- 从左往右开始找，找到第一个非数字(包含小数点)就停止，如果第一个数不是数字，则返回NaN
- eg: '12.5' -> 12	'12abc' -> 12	'abc' -> NaN

### parseFloat()
- 从左往右开始找，找到第一个非数字(不包含小数点)就停止，如果第一个数不是数字，则返回NaN
- eg: '12.5' -> 12.5	'12abc' -> 12	'abc' -> NaN

### Number()
- 既能处理整数，也能处理小数，但只能处理数字
- eg: '12.5' -> 12.5 	'12' -> 12 		'12abc' -> NaN 	'abc' -> NaN

``` javascript
<script>
	parseFloat("1") //1
	parseFloat("1s") //1
	parseFloat(null) //NaN
	parseFloat(undefined) //NaN
	parseFloat("") //NaN

	Number("1") //1
	Number("1s") //NaN
	Number(null) //0 -> Number将非数字转换为了0
	Number(undefined) //NaN
	Number("") //0 -> Number将非数字转换为了0
</script>
```

``` javascript
<script>
	// jquery解决Number问题

	// isNumeric: function(obj) {
	// 	return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
	// }

	$.isNumeric("1") //true
	$.isNumeric("1s") //false
	$.isNumeric(null) //false
	$.isNumeric(undefined) //false
	$.isNumeric("") //false
</script>
```

## 8. 数字转化为字符串
number + ''

> eg：12 + '' -> '12'

## 9. if语句变形
1. 条件 && 语句; (条件为真时执行)
1. 条件 || 语句; (条件为假时执行)
1. 三目运算  条件? 语句1: 语句2;

## 10. **js**及**事件**的笼统概念
- js：修改样式
- 事件：用户的操作

>任何标签都可以添加事件，任何属性都可以修改

---
#blog2

---

##1. js操作元素属性
- **.** 属性操作符(不可以接收变量)
- **[]** 中括号可以操作属性也可以接收变量

``` javascript
<script>
	function setValue() {
		//省略获取元素oBtn, oBtn2的伪代码
		oBtn.value = 'bbb';
		oBtn2['value'] = 'bbb';

	}
</script>
```

>凡是**.** 出现的地方都可以用中括号替代

##2. js设置复杂样式

> 非首单词的首字母大写并去掉-符

``` css
<style>
	.complex {
		margin-left: 10px;
	}
</style>
```
``` javascript
<script>
	function setStyle() {
		var oC = document.getElementsByClassName('complex')[0];
		oC.style.marginLeft = '10px';
	}
</script>
```

## 3. 物体从中心放大

> * margin-top: -变化的高度/2
> * margin-left: -变化的宽度/2

##4. a链接防止刷新

``` html
<a href="#">点击会刷新页面</a>
```
``` javascipt
<a href="javascript:;">点击不会刷新页面！(推荐使用)</a>
<!-- javascript:;相当于一个伪协议 -->
```

##5. 循环添加事件，事件中的循环变量不能用

``` javascript
<script>
	function clickEg() {
		//获取一组按钮	ps:js一组元素不能一起改变样式或设置事件
		var aBtn = document.getElementsByTagName('button');
		for(var i = 0; i < 3; i++) {
			aBtn[i].onclick = function() {
				//循环中的i变量此时已自增至3
				//aBtn[i].style.background = '#f00';

				//当前事件发生的对象 aBtn[i]为this
				this.style.background = 'f00';
			}
		}
	}
</script>

```
##6. 浏览器加载的过程

1.加载整个页面的标签和属性
2.过滤不符合W3C标准的标签和属性(高级浏览器)
3.执行js -> window.onload

##7. DOM获取元素方法
1.document.getElementById('id');
2.document/obj.getElementsByTagName('TagName');
3.document/obj.getElementsByClassName('ClassName');
兼容：Chrome、FF、IE9+

obj.getElementsByClassName
- 高级浏览器 -> function
- IE8- -> undefined
####兼容写法
``` javascript
<script>
	function getByClass(obj, sClass) {	// obj为从哪个父级下面查找类为sClass的元素
			if(obj.getElementsByClassName) {	// IE8- -> undefined  高级浏览器 -> function
				return obj.getElementsByClassName(sClass);	// 高级浏览器
			} else {	// IE8
				var aEle = document.getElementsByTagName('*');
				var arr = [];
				for(var i=0; i<aEle.length; i++){
					var temp = aEle[i].className.split(' ');
					if(findInArr(sClass, temp)) {
						arr.push(aEle[i]);
					}
				}
				return arr;
			}
		}
</script>
```

> * getElementById只能从document下获取
	var oDiv = document.getElementById('id');
> * getElementsByTagName/getElementsByClassName可以从document下获取，也可以从父级下获取
	var oDiv2 = document.getElementsByClassName('ClassName')[0];
	var oDiv3 = oBox.getElementsByTagName('TagName')[0];

##8. js中的真假
- 真：非0数字，非空字符串，true，非空对象
- 假：0，空字符串('')，false，空对象(null)，undefined，NaN

##9. 获取元素当前样式(兼容)
``` javascript
<script>
	function getStyle(obj, name){	//元素，样式名称
		if(obj.currentStyle) {	// Chrome、FF -> undefined	IE -> object
			// IE系
			return obj.currentStyle[name];	// 兼容IE系
		} else {
			// Chrome、FF
			return getComputedStyle(obj, false)[name];	// 兼容高级浏览器(Chrome、FF、IE9+)
		}

	}
</script>
```
简化
``` javascript
<script>
	function getStyle(obj, name){	//元素，样式名称
		return (obj.currentStyle || getComputedStyle(obj, false))[name];
	}

	// 调用
	console.log(parseInt(getStyle(oDiv, 'heihgt')));
</script>
```
##10. 获取一个n~m之间的随机数(n<m，且不包括m)
``` javascript
<script>
	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}
</script>
```

>应用：随机变色

``` javascript
<script>
	// rgb色值范围[0, 255]
	oDiv.style.background = 'rgb(' + rnd(0, 256) + ',' + rnd(0, 256) + ',' + rnd(0, 256) + ')';
</script>
```

---
#blog3

以下内容若有问题烦请即时告知我予以修改，以免误导更多人。

---

##1. 返回值问题(return)
1. return语句后面的代码不执行
1. **函数若没有写return，则默认返回undefined**
1. **函数返回语句为return; 也返回undefined**
1. **return必须写在函数function内**

##2. undefined出现的情况
- 函数没有返回值或只有return;
- 定义了一个变量，但没有赋值

eg: 
``` javascript
<script>
  var a; // undefined
  function show(a) {}
  show();	// undefined`
</script>
```

- 访问不存在的属性

> eg: oDiv.aaa;	// undefined

##3. eval(字符串)
> 虽然这个不建议使用，但还是聊聊这个东西是怎么用的吧

eval能把字符串里面的代码转换成js能理解的程序，把引号中的拿出来运行

``` javascript
<script>
	var a = '[1, 2, 3]';	//字符串
	alert(eval(a));		// 1, 2, 3  '[1, 2, 3]' -> [1, 2, 3]
</script>
```

##4. 数字小于10的补零函数
``` javascript
<script>
	function toTen(num) {
		if(num < 10) {
			return '0' + num;
		} else {
			return '' + num;	// 函数的返回类型最好保持一致
		}
	}
</script>
```
简化
``` javascript
<script>
	function toTen(num) {
		return num < 10 ? '0' + num : '' + num;
	}
</script>
```

##5. 定时器
### (1) Interval(每过一段时间执行一次，循环执行)
- 开启定时器
setInterval(函数/函数名, 时间);

> 时间单位是毫秒

- 关闭定时器
clearInterval(定时器的名字);

**interval的问题**

1.时间不能设置太小的值

 eg:设置0其实会超出0
``` javascript
<script>
	var a = 6;
	setTimeout(function(){
		a = 66;
	},0);
	alert(a);	//6
</script>
```

2.时间值越小越不稳定

3.打开其他窗口时，该窗口定时器时间会变长

> *定时器的最佳时间：30ms (时间过小，程序性能开销大)

### (2) Timeout(过一段时间执行一次，只执行一次)
- 开启定时器
setTimeout(函数/函数名, 时间);

> 时间单位是毫秒

- 关闭定时器
clearTimeout(定时器的名字);

``` javascript
	<script>
		// 定时器先关后开
		var bSin = false;
		var timer = setInterval(function() {
			if(bSin) {
				return;
			}
			bSin = true;
		}, 30);

		function clear() {
			clearInterval(timer);
			bSin = false;
		}
	</script>
```

** **

##6. 日期对象
``` javascript
<script>
	// 获取时间
	var oDate = new Date();
	oDate.getFullYear();	// 获取年
	oDate.getMonth();		// 获取月，从0开始，获取+1，设置-1 !important
	oDate.getDate();		// 获取日
	oDate.getDay();			// 获取星期，星期天 -> 0，星期一 ~ 星期六 -> 1 ~ 6

	oDate.getHours();		// 获取小时，记得加s，下同 !important
	oDate.getMinutes();		// 获取分钟
	oDate.getSeconds();		// 获取秒
	oDate.getMillseconds();	// 获取毫秒
	oDate.getTime(); 		// 时间戳 当前时间距离1970/1/1凌晨的毫秒数
</script>
```

``` javascript
<script>
	// 设置时间
	var oDate = new Date();
	oDate.setFullYear(2017, 11, 13);	// 设置年、月、日  月份设置时-1
	oDate.setHours(0, 0, 0, 0);			// 设置时、分、秒、毫秒

	// 获得时间戳
	oDate.getTime();	// 设置后的时间距离1970/1/1凌晨的毫秒数
</script>
```

##7. 日期对象应用
> oDate.setDate(31); // 假设本月有30天会跑到下个月的第一天 会自动进位
> oDate.setDate(0); // 会跑到上个月的最后一天

### 本月有多少天
``` javascript
<script>
	var oDate = new Date();
	oDate.setMonth(oDate.getMonth() + 1); // 当前月份+1
	oDate.setDate(0);	// setDate(0);
	alert(oDate.getDate());

</script>
```
### 本月第一天是周几
``` javascript
<script>
	var oDate = new Date();
	oDate.setDate(1);	// setDate(1);
	alert(oDate.getDay());
</script>
```

### 本月最后一天是周几
``` javascript
<script>
	var oDate = new Date();
	oDate.setMonth(oDate.getMonth()+1);	// 当前月份+1
	oDate.setDate(0);	// setDate(0);
	alert(oDate.getDay());
</script>
```

### 倒计时

```
<input type="text" placeholder="年">
<input type="text" placeholder="月">
<input type="text" placeholder="日">
<button>倒计时</button>
<p></p>
```


```
<script>
	fnDJ();

	function fnDJ() {
		var oP = document.querySelector('p');
		var aInp = document.querySelectorAll('input');
		var oBtn = document.querySelector('button');

		var timer = null;

		oBtn.onclick = function() {
			clearInterval(timer);
			var oEndDate = new Date();
			var year = Number(aInp[0].value);
			var month = Number(aInp[1].value);
			var day = Number(aInp[2].value);

			oEndDate.setFullYear(year, month, day);
			oEndDate.setHours(0, 0, 0, 0);

			fnClock();
			timer = setInterval(fnClock, 1000);

			function fnClock() {
				var oBeDate = new Date();

				var iS = parseInt((oEndDate.getTime() - oBeDate.getTime())/1000);
				var iD = parseInt(iS/86400);
				iS %= 86400;
				var iH = parseInt(iS/3600);
				iS %= 3600;
				var iM = parseInt(iS/60);
				iS %= 60;

				oP.innerHTML = fnBL(iD) + '天' + fnBL(iH) + '时' + fnBL(iM) + '分' + fnBL(iS) + '秒';
			}
		}

	}

	function fnBL(num) {
		return num < 10 ? '0' + num : '' + num;
	}
</script>
```


##8. 事件函数相同可以合并
eg: oDiv1.onmouseout = oDiv2.onmouseout = function() {};

##9. this
this: 当前方法属于谁，this就是谁
**this默认属于window**

定时器里的this不能直接使用，原因：this指向了window

###(1) 定时器中的this不指向元素，指向window
解决：在定时器外保存this
``` javascript
<script>
oBtn.onclick = function() {
	var _this = this;
	setTimeout(function(){
		_this.style.background = '#f00';
	},1000);
}
</script>
```
###(2) 调用封装函数使用this，this不指向元素，指向window
###(3) 低级浏览器attachEvent)事件绑定里面的this 报错

##10. 闭包
用处：
1. 解决变量名冲突
2. 解决循环添加事件，事件中的循环变量不能用的问题

``` javascript
<script>
	function clickEg() {
		//获取一组按钮	ps:js一组元素不能一起改变样式或设置事件
		var aBtn = document.getElementsByTagName('button');
		for(var i = 0; i < 3; i++) {
			aBtn[i].onclick = function() {
				//循环中的i变量此时已自增至3
				//aBtn[i].style.background = '#f00';

				//当前事件发生的对象 aBtn[i]为this
				this.style.background = 'f00';
			}
		}
	}
</script>

```
闭包写法：

``` javascript
<script>
	function clickEg() {
		//获取一组按钮	ps:js一组元素不能一起改变样式或设置事件
		var aBtn = document.getElementsByTagName('button');
		for(var i = 0; i < 3; i++) {
			(function(index) {
				aBtn[i].onclick = function() {
					aBtn[index].style.background = 'f00';
				}
			})(i);
		}
	}
</script>

```

---

``` javascript
<script>
	for(var i=0; i<2; i++) {
		setTimeout(function(){
			alert(i);
		}, 2000);
	}	// 结果：两秒后alert两次2，两秒后i已为2，然后执行两次循环
</script>

```
闭包写法：

``` javascript
<script>
	for(var i=0; i<2; i++) {
		(function(a){
			setTimeout(function(){
				alert(a);
			},2000);
		})(i);
	}	// 结果：两秒后alert 0、1
</script>

```

---
#blog4

---

##1. 参数的数组arguments
参数中的数组，函数中可以不需要定义参数
``` javascript
<script>
	sum(12, 5, 6);

	function sum() {
		console.log(arguments[1]);	// 5
	}
</script>

```

##2. 设置样式的三种方法
1. style.xxx
oDiv.style.width = '300px';

2. className
oDiv.className = 'active';

3. cssText
批量设置样式
oDiv.style.cssText = 'width: 300px; height: 300px';

##3. 字符串的相关方法
- str.charAt(i); 获取字符串中的第i+1个字符  返回值：相应位置的字符

  > str[i]的兼容问题
  获取字符串中的第i+1个
  - str[i]  兼容：高级浏览器及IE8+
		  IE7 -> undefined
  - str.charAt(i)  全兼容

- str.indexOf('w'); 查找w在字符串中的位置  返回值：成功 -> w在字符串中的位置  失败 -> -1

  > 
  1. 从左往右找
  2. 区分大小写
  3. 找到第一个相同值即停止
  4. 查找多个字符时，返回第一个字符的位置

-  str.lastIndexOf('w'); 查找w在字符串中的位置  返回值：成功 -> w在字符串中的位置  失败 -> -1

  > 从右往左倒序查找，返回的索引值与indexOf()规则相同

-  str.search('w'); 与indexOf()规则相同 
  > search 是强制**正则匹配**，而 indexOf 只是按字符串匹配的。

-  str.substring(开始位置, 结束位置); 截取字符串，包含开始位置，不包含结束位置

  > str.substring(开始位置); 截取字符串 **从开始位置一直截取到最后**

-  str.substr(开始位置, 截取字符串长度); 定长截取字符串

-  str.slice(开始位置, 结束位置); 截取字符串
> slice和substring的区别 
对于负数参数，slice()方法会用字符串的长度加上参数，subString()方法将其作为0处理
```
<script>
	var strObj = new String("hello world");
	alert(strObj.slice(-3));　　　　　　// 输出结果："rld"
	alert(strObj.subString(-3));　　　 // 输出结果："hello world"
	alert(strObj.slice(3,-4));　　　　 // 输出结果："lo w"
	alert(strObj.subString(3,-4))　　 // 输出结果："hel"  substring(0, 3)
</script>
```


-  str.match('w'); 在字符串中匹配w **常用于正则** 返回值：成功 -> 匹配的w  失败 -> null

-  str.split('w'); 切割字符串 **返回值类型：数组**

  > 
  1. 字符串按w割开，去掉w后组成的数组
  2. **若没找到w则原样返回一个长度为1的数组**
  3. 若为''(空字符串，无空格)则返回将str中每个字符逐个拆开的数组

-  str.toUpperCase(); str转大写
    str.toLowerCase(); str转小写

-  str.replace('xxx', 'yyy'); **常用于正则** 参数：被替换内容,替换内容

  > 
  1. **修改第一个被替换内容**
  2. **替换不修改原字符串, 需重新声明**
  3. **第二个参数可为一个方法**
  4. **replace可以连用**

``` javascript
<script>
	var str = 'xxa';
    str.replace('x','y');
    str2 = str.replace('a', 'b');
    str3 = str.replace('x', 'y').replace('a', 'b');
    alert(str);     // xxa
    alert(str.replace('x', 'y'));   // yxa
    alert(str2);    //xxb
    alert(str3);    //yxb
</script>
```
``` javascript
<script>
	var str = 'xxxy';
    var str2 = str.replace('xxx', function(s){
        alert(s);	// xxx  被替换字符 数据类型：string
        var str2 = '';
        for(var i = 0; i < s.length; i++) {
            str2 += '*';
        }
        return str2;	// 替换后的内容
    });

    alert(str2);	// ***y
</script>
```

-  str.charCodeAt(i);	// 获取字符串中的第i+1个字符对应的ASCII编码

  > a-> 0x61 -> 97
  > b-> 0x62 -> 98
  > z -> 0x7A -> 122

##4. 字符串比较
- 英文 按照字典序(a~z)依次比较，z为最大；从两字符串的第一个字符开始，若相当再比较下一个字符
- 数字 按照数字大小依次；从两字符串的第一个字符开始，若相当再比较下一个字符
- 汉字 按照unicode大小比较

##5. 字符串应用
###判断浏览器的类型
window.navigator.userAgent
eg:
``` javascript
<script>
	if(window.navigator.userAgent.indexOf('Chrome') != -1) {
		console.log('Chrome');
	} else if(window.navigator.userAgent.indexOf('Firefox') != -1) {
		console.log('Firefox');
	} else if(window.navigator.userAgent.indexOf('MSIE7.0') != -1) {
		consolle.log('IE7');
	} else {
		console.log('others');
	}
</script>
```
###判断上传文件格式
eg:
``` javascript
<script>
	var index = str.lastIndexOf('.');
   	var type = str.substring(index+1);	//返回文件类型名
</script>
```

##6. 定义数组
1. var arr = [1, 2, 3];
2. var arr = new Array(1, 2, 3);

> Array()只传一个参数时表示定义一个新数组的长度
> new Array(10); 定义一个长度为10的数组

##7. 数组的相关方法
-  arr.push('w'); 往数组最后面添加一项  返回值：新添加的那项
-  arr.unshift('w'); 往数组最前面添加一项  **返回值：新数组长度**
-  arr.pop(); 删除数组最后一项  返回值：删除的那项
-  arr.shift(); 删除数组最前一项  返回值：删除的那项
-  arr.join('w'); 数组各项用w连接成一个字符串  **返回值类型：字符串**
-  arr.concat(arr2, arr3, ...); 数组arr与arr2、arr3...连接
-  arr.reverse(); 数组翻转
-  arr.sort(); 数组排序(按字典序和数字序列)

  > 高级排序 数值排序
  - 从小到大
```
<script> 
arr.sort(function(n1, n2){
	return n1-n2;  // 可理解为：当n1-n2为正值即n1>n2时，需调换顺序，则为大的向后挪，小的向前挪 -> 升序
});
</script> 
```
  - 从大到小
```
<script> 
arr.sort(function(n1, n2){
	return n2-n1;   // 可理解为：当n2-n1为正值即n2>n1时，需调换顺序，则为大的向前挪，小的向后挪 -> 降序
});
</script> 
```
-  arr.splice(开始位置, 删除个数, 元素1, 元素2);

``` javascript
<script>
	var arr1=[1,2,3,4];
   arr1.splice(1, 0, 'a', 'b');	//添加：在1后添加'a','b'	返回值：返回空数组

   var arr2=[1,2,3,4];
   arr2.splice(1, 2); //删除：删除2、3	返回值：返回删除的各项

   var arr3=[1,2,3,4];
   arr3.splice(1, 1, 8, 88, 888) //修改：先删除再添加 把2改为8,88,888	返回值：返回删除的各项
</script>
```

> splice模拟方法
1) arr.push(c);    -> arr.splice(arr.length, 0, c);
2）arr.unshift(c); -> arr.splice(0, 0, c);
3）arr.pop();      -> arr.splice(arr.length-1, 1);
4）arr.shift();    -> arr.splice(0, 1);

##8. json(object类型)
json格式：{name:value,name2:value2, ...}
json标准格式：{"name":value, "name2":value2, ...}
> - 所有键名需双引号,键值非数字时需加引号
> - 键值对没有json.length
> - json的name是唯一的

- 获取json值: json.name 或者 json['name']
- 添加/修改: json.aaa = 'bbb'; 或者 json['aaa'] = 'bbb';
- 删除: delete json.c; 或者 delete json['c'];

- 判断json内某个属性是否存在

``` javascript
<script>
	var json = {a: 1, b: 2};
	alert('c' in json);	// false 属性c不存在
</script>
```

###json和数组的区别
####length
- 数组：有length
- json：没有length

####循环遍历方法
- 数组：for(var i=0;i<arr.length;i++){alert(arr[i])};	for循环
- json：for(var name in json){alert(json[name])};		for in循环

###访问元素下标类型
- 数组：arr[1]  数字
- json：json['a']  字符串

####顺序
- 数组：有序，根据下标访问
- json：无序，根据键名访问

##9. Math方法
1. `Math.random()`	 			0-1随机数（不包含1）
2. `Math.abs(num)`			绝对值
3. `Math.max(num1, num2, ...)`	最大数
4. `Math.min(num1, num2, ...)`	最小数
5. `Math.floor(num)`			向下取整	12.4 -> 12	12.6 -> 12
6. `Math.ceil(num)`			向上取整	12.5 -> 13	12.1 -> 13
7. `Math.pow(n, m)`			n的m次方	Math.pow(2, 3)=8;
8. `Math.sqrt(num)`			num开平方	Math.sqrt(9)=3;
9. `Math.round(num)`			四舍五入	12.1 -> 12	12.6 -> 13

> `num.toFixed(保留小数个数);`  保留几位小数(自动四舍五入)

##10. try-catch捕获异常
``` javascript
<script>
	try {
		// code
	} catch(ex) {	// exception
		console.log(ex.message);	// 查看错误信息

		// 错误的提示信息
		// 补救的代码
	}
</script>
```

---

#blog5(数组应用)

---

## 1. 数组翻转方法2
eg:这里说明一下，这个方法用的不是reverse，因为一次面试中被问过不用reverse实现翻转，所以这里标注为数组的翻转方法2。
``` javascript
<script>
	var arr=[1,2,3,4];
	var arr2=[];
	while(arr.length) {
		var num=arr.pop();
		arr2.push(num);
	}
	alert(arr2);
</script>
```

## 2. 首字母大写
eg:
``` javascript
<script>
	var str = 'welcome to china';
	var arr = str.split(' ');
	var arr2 = [];
	for(var i = 0; i < arr.length; i++) {
		var first = arr[i].charAt(0).toUpperCase();
		var other = arr[i].substring(1);
		arr2.push(first + other);
	}
	alert(arr2.join(' '));

    //正则写法
	var str2 = str.replace(/\w+/g, function(s) {
		return s.charAt(0).toUpperCase() + s.substring(1);
	})
	alert(str2);
</script>
```

## 3.快速清空数组
1. length=0;
2. arr=[];
3. arr.splice(0,arr.length);
4. 循环pop或shift

## 4. 数组排序方法
更多方法见后续排序算法篇

``` javascript
<script>
	function findMinIndex(arr, start) {
		var iMin = arr[start];
		var iMinIndex = start;
		for(var i = start + 1; i < arr.length; i++) {
			if(iMin > arr[i]) {
				iMin = arr[i];
				iMinIndex = i;
			}
		}
		return iMinIndex;
	}

	for(var i = 0; i < arr.length; i++) {
		var iMinIndex = findMinIndex(arr, i);
		var temp;
		temp = arr[iMinIndex];
		arr[iMinIndex] = arr[i];
		arr[i] = temp;
	}
</script>
```

## 5. 数组内查找元素是否存在
``` javascript
<script>
	function findInArr(item, arr) {
		for(var i = 0; i < arr.length; i++) {
			if(item == arr[i]) {
				return true;
			} else {
				return false;
			}
		}
	}
</script>
```

## 6. 数组去重的多种方法
### (1)findInArr

``` javascript
<script>
	var arr2 = [];

	for(var i = 0; i < arr.length; i++) {
		if(!findInArr(arr[i], arr2)) {
			arr2.push(arr[i]);
		}
	}

	// 数组内查找元素是否存在
	function findInArr(item, arr) {
		for(var i = 0; i < arr.length; i++) {
			if(item == arr[i]) {
				return true;
			} else {
				return false;
			}
		}
	}
</script>
```

### (2)json(自动从小到大排序)

``` javascript
<script>
	var json = {};
	var arr2 = [];

	for(var i = 0; i < arr.length; i++) {
		json[arr[i]] = 'xxx';
	}

	for(var name in json) {
		arr2.push(name);
	}
</script>
```

摘自[也谈JavaScript数组去重](http://web.jobbole.com/89843/)

``` javascript
<script>
	function unique(arr) {
        var ret = [];
        var len = arr.length;
        var tmp = {};
        for(var i=0; i<len; i++){
          if(!tmp[arr[i]]){
            tmp[arr[i]] = 1;
            ret.push(arr[i]);
        }
    }
    return ret;
}
</script>

```

### (3)sort()

``` javascript
<script>
	arr.sort();
	for(var i = 0; i < arr.length; i++) {
		if(arr[i] == arr[i+1]) {
			arr.splice(i, 1);
			i--;
		}
	}
</script>
```

### (4) indexOf
这个方法是在前端公众号偶然看到的，数组的indexOf方法第一次用到

``` javascript
<script>
	for(var i = 0; i < arr.length; i++) {
		if(arr2.indexOf(arr[i]) < 0) {
			arr2.push(arr[i]);
		}
	}
</script>
```

### (5)二分法

``` javascript
<script>
	var arr = [1, 2, 3, 2, 4, 3, 1, 5, 7, 2, 5];

	// 数组内查找元素是否存在
	function findInArr(item, arr) {
		for(var i = 0; i < arr.length; i++) {
			if(item == arr[i]) {
				return true;
			}
		}
        return false;
	}

	function del(arr, s, e) {
		if(s > e) {
			return [];
		} else if(s == e) {
			return [arr[s]];
		}

		var c = Math.floor((s + e) / 2);
		var l = del(arr, s, c);
		var r = del(arr, c + 1, e);

		for(var i = 0; i < r.length; i++) {
			if(!findInArr(r[i], l)) {
				l.push(r[i]);
			}
		}

		return l;
	}

	console.log(del(arr, 0 , arr.length - 1));
</script>
```

### (6)Map(ES6)
摘自[也谈JavaScript数组去重](http://web.jobbole.com/89843/)

Map的存取使用单独的get()、set()接口。

``` javascript
<script>

function unique(arr) {
    var ret = [];
    var len = arr.length;
    var tmp = new Map();
    for(var i=0; i<len; i++){
        if(!tmp.get(arr[i])){
            tmp.set(arr[i], 1);
            ret.push(arr[i]);
        }
    }
    return ret;
}
</script>
```

### (7)Set(ES6)
摘自[也谈JavaScript数组去重](http://web.jobbole.com/89843/)

Set不允许重复元素出现。

``` javascript
<script>
function unique(arr){
    var set = new Set(arr);
    return Array.from(set);
}
</script>
```

---

## 补一个字符串的应用

### (1) 字符串中出现次数最多的字符

- json

```
<script>
	var str = 'abcdaaaaaa';
	var json = {};

	for(var i = 0; i < str.length; i++) {
		if(json[str.charAt(i)]) {
			json[str.charAt(i)]++;
		} else {
			json[str.charAt(i)] = 1;
		}
	}

	var num = -1;
	var char = '';

	for(var name in json) {
		if(num < json[name]) {
			num = json[name];
			char = name;
		}
	}

	console.log(num, char);
</script>
```

- 正则

```
<script>
	var str = 'abcdaaaaaa';
	var arr = str.split("")
		.sort()
		.join("")
		.match(/([a-z])\1*/g)
		.sort(function(a, b) {
			return b.length - a.length;
		})
	console.log("出现最多的是: " + arr[0][0] + "共" + arr[0].length + "次");
	var hash = {};
	arr.forEach(function(val) {
		hash[val[0]] = val.length;
	});
	console.dir(hash);
</script>
```


---

#blog6

---

##1. select下拉框的相关属性
- 选中的索引值
oSel.selectedIndex
- 获取所有选项
oSel.options
- 获取选中的选项的文本内容
oSel.options[oSel.selectedIndex].innerHTML
oSel.options[oSel.selectedIndex].text
- 添加选项
var option = new Option(文本内容, value值);
oSel.options.add(option);
- 删除选项
oSel.options.remove(index);

##2. 预解析
变量和函数的定义会预先解析，解析在当前script标签内的最上面
> 作用域：(1)script (2)函数

``` javascript
<script>
	var a = 111;
	function show() {
		alert(a);
		var a = 12;
		// 相当于
		// var a;
		// alert(a);	//undefined
		// a = 12;
	}
	show();		// undefined
	alert(a);	// 111
</script>
```

##3. 已知计算机编码查看对应单词
String.fromCharCode('0x4e00');	 // 对应中文 "一"
- 第一个中文 	0x4e00 一
- 最后一个中文	0x9fa5 龥(yu)

**unicode编码：以\u开头 \u4e00(一) ~ \u9fa5(龥)**

##4. 字节长度和编码的关系
英文、数字都占1个字节，与编码格式无关
UTF-8；中文占3个字节
GB2312：中文占2个字节

###封装一个求字节长度的函数
``` javascript
<script>
	function getBytesLen(str, type) {	// 字符串，编码格式
		var result = 0;
		type = type.toLowerCase();
		for (var i = 0; i < str.length; i++) {
			if(str.charAt(i) >= '\u4e00' && str.charAt(i) <= '\u9fa5') {
				if(type == 'gb2312') {
					result += 2;
				} else {
					result += 3;
				}
			} else {
				result++;
			}
		}
		return result;
	}
</script>
```

##5. 严格模式
**非严格模式下，没有用var定义变量时为全局变量，全局的东西都属于window**
``` javascript
<script>
	function show(){
		a = 12;		//a没有var时a为全局变量
		alert(a);	//1. 12
	}
	show();		//需先调用show函数
	alert(a);	//2. 12
</script>
```
严格模式

在script标签内最上面写` 'use strict'; `   **IE6不识别但不报错**

`'use strict';`好处：
1. 修复局部this的问题
2. 不允许if/while/for里面定义函数
3. 去掉了with(){}
4. 定义变量必须加var

作用域：(1)当前script标签内 (2)函数  (3)js文件


**坑**
``` javascript
<script>
	var a = 5;
	if(a % 2) {
		function show() {
			alert('单数');
		}
	} else {
		function show() {
			alert('双数');
		}
	}
	show();	// 单数 最新版高级浏览器中预解析不会覆盖，之前版本预解析后此例预解析覆盖 弹出双数
</script>
```

``` javascript
<script>
	'use strict';
	var a = 5;
	if(a % 2) {
		function show() {
			alert('单数');
		}
	} else {
		function show() {
			alert('双数');
		}
	}
	show();	// show is not defined，严格模式不允许if/for里面定义函数
</script>
```

##6. 连等及逗号运算符
###连等
**函数内部使用连等定义变量，第一个是局部变量，其余是全局变量。**

``` javascript
<script>
	function show(){
		var a=b=c=1;	//a是局部变量，b、c是全局变量
	}
</script>
```

###逗号运算符
**逗号运算符 以最后一个为准**

``` javascript
<script>
	var a = (1, 2, 3); // a=3

	for (var i = 0, j = 5, k = 8; i < 10, j < 10, k < 10; i++, j++, k++) {

	}
	alert(i + j + k); // 2+7+10=19
</script>
```

##7. 文本提示框
聚焦事件：oT.onfocus = function() {};
失焦事件：oT.onblur = function() {};
> 强制获取一个焦点：oT.focus();
> 强制失去一个焦点：oT.blur();

##8. form表单
想要提交数据须有
1. action 提交的地址 <form action=''></form>
2. name   数据名称   <input name="user.tel" />
3. value  数据       input.value

提交方式
1. get(默认) 容量32K左右  不安全，有缓存
** 好处：(1)分享 (2)收藏**

2. post      容量1G左右   相对安全，没有缓存

> 缓存(cache)
对于浏览器而言，相同的地址只会访问一次


---

#blog7(js组成)

---

## 1. js实现的组成

### ECMA
ECMAScript(**js核心**) 提供核心语言功能

*兼容：完全兼容
eg:
` if(){}
arr.pop();`
### DOM
Document Object Model  文档对象模型  提供访问和操作网页内容的方法和接口

**DOM是针对XML但经过扩展用于HTML的应用程序接口(API)。**

*兼容：大部分兼容，不兼容可以作兼容处理
eg:
`document.getElementById('id')
 oDiv.style.background = 'red';`
### BOM
Browser Object Model  浏览器对象模型  提供与浏览器交互的方法和接口

*兼容：根据使用浏览器来，根本不兼容，且不能作兼容处理
eg:
`window.navigator.userAgent
 alert();`

## 2. DOM节点关系
1. 父子节点

- 子节点：父节点.children;	(一级，一层)

- 父节点：子节点.parentNode;

2. 兄弟节点

 - 上一个兄弟节点：
      obj.perviousElementSibling;
            *兼容：高级浏览器
      obj.previousSibling
            *兼容：全兼容
            高级浏览器 -> object text
            低级浏览器 -> 能获取相应的节点

	**兼容写法**

	var oPrev = obj.previousElementSibling || obj.previousSibling;
 - 下一个兄弟节点
       obj.nextElementSibling
             *兼容：高级浏览器
      obj.nextSibling
             *兼容：全兼容
              高级浏览器 -> object text
              低级浏览器 -> 能获取相应的节点

	**兼容写法**

	var oNext = obj.nextElementSibling || obj.nextSibling;

3. 首尾节点

    - 首节点
        父节点.firstElementChild

				*兼容：高级浏览器
				低级浏览器 -> undefined

	 父节点.firstChild

		         *兼容：全兼容
                  高级浏览器 -> object text
                  低级浏览器 -> 能获取相应的节点

	**兼容写法**

	(1) 父节点.fisrtElementChild || 父节点.firstChild

	(2) 父节点.children[0]

    - 尾节点
         父节点.lastElementChild
                    *兼容：高级浏览器
                     低级浏览器 -> undefined
         父节点.lastChild
                    *兼容：全兼容
                     高级浏览器 -> object text
                     低级浏览器 -> 能获取相应的节点

	**兼容写法**

	(1) 父节点.lastElementChild || 父节点.lastChild

	(2) 父节点.children[父节点.children.length - 1]

## 3. DOM节点操作
1. 创建一个节点
	var obj = document.createElement('tagName');
2. 添加一个节点(**所有的添加功能都相当于剪切功能**)
	父节点.appendChild(要添加的节点);
	父节点.insertBefore(要添加的节点, 在谁前面添加);
3. 删除一个节点
	父节点.removeChild(要删除的节点);
4. 替换一个节点
	父节点.replaceChild(新节点, 删除的节点);

## 4. DOM属性操作
1. .
2. []
3. 可操作自定义属性
  - 获取属性 obj.getAttribute(属性的名字);
  - 设置属性 obj.setAttribute(属性的名字, 值);
  - 删除属性 obj.removeAttribute(属性的名字);

> 获取设置属性方法尽量不混用

## 5. BOM
1. window.open(地址, 方式);	 打开新窗口
	返回值：新的窗体对象
		Chrome：拦截
		FF：阻止
		IE：直接打开
		*：用户自己打开的都不拦截
	打开方式：
		(1) _blank 新窗口打开(默认)
		(2) _self  当前页面打开
	about:blank  空白页
2. window.close();			关闭当前窗口
		Chrome：直接关闭
		FF：没有反应
		IE：提示
		*：只能关闭自己open出来的窗口
3. window.location  		获取地址栏信息对象
	返回值数据类型：object
  - window.location.href    	获取地址栏信息
	返回值数据类型：string
  - window.location.search  	获取地址栏信息中的数据
	返回值：?(包括?)后面的值
  - window.location.hash    	获取地址栏信息中的锚点
	返回值：#(包括#)后面的值
  - window.location.protocol 	获取地址栏信息中的协议
	返回值：eg: http:
  - window.location.host      获取地址栏信息中的域名
	返回值：eg：localhost:8080  baidu.com
  - window.location.port      获取地址栏信息中的端口
	返回值：eg：8080
   - window.location.pathname  获取地址栏信息中的路径
	返回值：eg：/../../xxx.html
4. window.history           获取地址的历史信息
 - window.history.forward()  前进
  - window.history.back()     后退
  - window.history.go(数字)	
  前进时数字>0  ->  1代表前进1个页面
  后退时数字<0  ->  -1代表后退1个页面
5. window.location.reload();  强制刷新页面


---

#blog8(各种宽高，距离)

---

##1. 滚动距离
**html简写：document.documentElement**
- document.body.scrollTop
	兼容：Chrome
	其他 -> 0
- document.documentElement.scrollTop
	兼容：IE、FF
	其他 -> 0

**兼容写法**
纵向：var scrollT = document.documentElement.scrollTop || document.body.scrollTop;
横向：var scrollL = document.documentElement.scrollLeft || document.body.scrollLeft;

##2. 滚动高度
obj.scrollHeight
- 内容高度 > 盒模型高度    取内容高度
- 盒模型高度 > 内容高度    取盒模型高度

##3. 可视区高度
- 可视区高度：var clientH = document.documentElement.clientHeight;
- 可视区宽度：var clientW = document.documentElement.clientWidth;

兼容：全兼容

##4. 物体高度
**获取的是盒模型大小 = width/height + padding + border;**

- 物体的高度：var oH = obj.offsetHeight;
- 物体的宽度：var oW = obj.offsetWidth;

> 注意：offsetWidth/height只有append进body后才有，创建时获取不到盒模型的大小。

##5. offsetHeight && getStyle()

| 	   	| 		offsetHeight      |     getStyle() 	 		 |
| :--: 	| 	   :----: 	          |   :----: 	 		     |
|返回值 | 	   数字  	  		  |   		字符串 		     |
|获取值 | 获取的是盒模型的大小(width/height+padding+border)  |   获取的是纯width/height			 |
| display:none后   | 	   0    |   仍可以获取 				 |

##6. 物体的相对距离
- 物体距离定位父级左边距离：var oL = obj.offsetLeft;
- 物体距离定位父级上边距离：var oT = obj.offsetTop;

##7. 关于父级
- 结构父级 obj.parentNode    根：document
- 定位父级 obj.offsetParent  根：body

##8. 封装一个物体距离左边/上边的绝对位置的函数
``` javascript
<script>
	function getPos(obj) {
		var l = 0;	// 距离左边的绝对距离
		var t = 0;	// 距离上边的绝对距离
		while(obj) {
			l += obj.offsetLeft;
			t += obj.offsetTop;
			obj = obj.offsetParent;	// 继续查找上一层定位父级
		}

		return {left: l, top: t};
	}
</script>

```


---

#blog9(事件篇)

---

## 1. 事件对象
- event  事件对象(系统自带)  
 *兼容：Chrome IE系
  FF -> 报错
- ev     事件函数传入参数 
  *兼容：高级浏览器(Chrome、FF、IE9+)
   IE8- -> undefined

**兼容写法**：var oEvent = ev || event;

## 2. 事件冒泡
概念：子级的事件会传递给父级。如果父级有相同的事件，会依次从内到外执行，直到相同事件的祖宗节点，否则会继续冒泡。

**阻止事件冒泡：**

子级事件内添加  `oEvent.cancelBubble = true;`

## 3. 事件绑定
**有效解决事件冲突**

- obj.addEventListener(事件名, 函数名/函数, 是否捕获);

*兼容：高级浏览器

事件名 -> 不能加'on'

函数名 -> 不能加括号

是否捕获 -> false

- obj.attachEvent(事件名, 函数名/函数);

*兼容：IE10-

事件名 -> 必须加'on'

函数名 -> 不能加括号

**兼容写法**

封装一个事件绑定的函数
``` javascript
<script>
	function addEvent(obj, sEv, fn) {	//对象, 事件(不加on), 函数名/函数
		if(obj.addEventListener) {	//高级浏览器 -> function  低级 ->undefined
			//高级浏览器
			obj.addEventListener(sEv, fn, false);
		} else {
			//低级浏览器
			obj.attachEvent('on' + sEv, fn);
		}
	}
</script>
```


## 4. 关于捕获(这点理解不是很到位)
事件冒泡：子级 -> 父级
设置捕获：父级 -> 子级

## 5. 事件解绑
- obj.removeEventListener(事件名, 函数名/函数, 是否捕获);

*兼容：高级浏览器

**注意：函数不能是匿名函数，每个匿名函数都相当于新创建了一个函数。**

创建函数 var show = new Function('a','b', 'alert(a + b)');

- obj.detachEvent(事件名, 函数名/函数);

*兼容：IE10-

**兼容写法**

封装一个事件解绑的函数
``` javascript
<script>
	function removeEvent(obj, sEv, fn) {	//对象, 事件(不加on), 函数名/函数
		if(obj.removeEventListner) {	//高级浏览器 -> function  低级 ->undefined
			//高级浏览器
			obj.removeEventListener(sEv, fn, false);
		} else {
			//低级
			obj.detachEvent('on' + sEv, fn);
		}
	}
</script>
```


## 6. 查看鼠标点击位置

var oEvent = ev || event;

X轴：oEvent.clientX;

Y轴：oEvent.clientY;

## 7. 键盘事件

1. obj.onkeydown  按下键盘触发
2. obj.onkeyup    释放键盘触发
3. obj.oninput	 	  键盘输入时实时触发
*兼容：高级浏览器
IE9删除时有问题

- obj.onpropertychange	键盘输入时实时触发
*兼容：IE10-
IE9删除时有问题


**兼容处理**

事件的兼容不需要处理，直接连等

obj.oninput = obj.onpropertychange = function() {}

*处理IE9：定时器


封装一个实时统计字数的函数
``` javascript
<script>
	function calLen(obj1, obj2) {
		if (window.navigator.userAgent.indexOf('MSIE 9.0') != -1) { //IE9
			var timer = null;
			obj1.onfocus = function() {
				timer = setInterval(function() {
					obj2.innerHTML = obj1.value.length;
				}, 50);
			};
			obj1.onblur = function() {
				clearInterval(timer);
			}
		} else { //能不添加定时器时就不添加
			obj1.oninput = obj1.onpropertychange = function() { //高级浏览器、IE10-
				obj2.innerHTML = obj1.value.length;
			}
		}
	}
</script>
```

应用：实时统计输入字数

### 键码 `oEvent.keyCode`

**重要**
- 0~9：48~57
- a~z：65~90
- ctrl：17
- delete：46
- backspace：8
- enter：13
- 左键：37
- 上键：38
- 右键：39
- 下键：40

> 组合键(js中键码不能组合使用)

- ctrl  -> ctrlKey
- shift -> shiftKey
- alt   -> altKey

eg:
`if(oEvent.ctrlKey && oEvent.shiftKey && oEvent.keyCode == 65){...}`

## 8. 鼠标事件
1. obj.oncontextmenu 点击鼠标右键触发(有默认右键菜单行为)

  > 默认行为：
  > 点击右键有菜单 文本框能输入内容 点击a标签能跳转等

  **阻止默认行为：return  false;**

  应用：自定义右键菜单
  应用：自定义输入框

2. obj.onmousedown	按下鼠标时触发
3. obj.onmouseup	抬起鼠标时触发
4. obj.onmousemove	鼠标移动触发

  应用：拖拽
  应用：拖拽(带框)
  应用：磁性吸附

5. obj.onmouseover  鼠标移入时触发

6. obj.onmouseout   鼠标移出时触发

  **问题**

  问题1：移入子级也算重新移入
  解决1：onmouseover -> onmouseenter

  问题2：移出子级也算移出
  解决2：onmouseout -> onmouseleave

7. obj.onmousewheel  滚动鼠标滚轮触发

*兼容：Chrome IE系

DOMMouseScroll       DOM滚轮事件(**DOM事件只能通过事件绑定添加**)

*兼容：FF

**兼容写法**
``` javascript
<script>
	if (window.navigator.userAgent.indexOf('FireFox') != -1) {
		document.addEventListener('DOMMouseScroll', function() { //FF
			//scroll code here
		}, false)
	} else {
		document.onmousewheel = function() { //Chrome IE系
			//scroll code here
		}
	}
</script>
```

###判断滚动方向
- oEvent.wheelDelta

	*兼容：Chrome IE系

	向上：120

	向下：-120

- DOMMouseScroll

	*兼容：FF

	向上：-3

	向下：3

**兼容写法**

封装一个鼠标滚动方向的函数

``` javascript
<script>
	function addWheel(obj, fn) { //向上fn(false)，向下fn(true)
		function wheel(ev) {
			var oEvent = ev || event;

			// var bDown = true;				//默认向下 -->
			// if(oEvent.wheelDelta) {			//FF -> undefined
			// 	//Chrome IE系
			// 	bDown = oEvent.wheelDelta < 0;
			// } else {
			// 	//FF
			// 	bDown = oEvent.detail > 0;
			// }

			var bDown = oEvent.wheelDelta ? oEvent.wheelDelta < 0 : oEvent.detail > 0;

			//判断是否传入函数，执行回调函数
			fn && fn(bDown);

			//FF阻止默认
			oEvent.preventDefault && oEvent.preventDefault();

			//阻止默认
			return false;
		}

		if (window.navigator.userAgent.indexOf('FireFox') != -1) {
			//FF
			document.addEventListener('DOMMouseScroll', wheel, false); //事件中阻止默认没有用
		} else {
			//Chrome IE系
			// document.onmousewheel = wheel;
			addEvent(obj, 'mousewheel', wheel);
		}
	}
</script>

```

  > oEvent.preventDefault();
  兼容：高级浏览器
  IE8- -> undefined

  应用：自定义滚动条

## 9. domReady
- DOMContentLoaded 当DOM加载完成时触发(在页面前) **DOM事件必须通过事件绑定添加**
*兼容：高级浏览器

- onreadystatechange 模拟domReady

**兼容写法**
封装domReady全兼容方法

``` javascript
<script>
	function domReady(fn) {
		if (document.addEventListener) {
			//高级浏览器
			document.addEventListener('DOMContentLoaded', function() {
				fn && fn();
			}, false);
		} else {
			//低级浏览器  模拟domReady
			document.onreadystatechange = function() {
				if (document.readyState == 'complete') {	// 全兼容
					fn && fn();
				}
			}
		}
	}
</script>
```

## 10. 事件委托
概念：子级自己的事件可以委托给父级处理

好处： (1)提高性能  **(2)可以给未来的子元素添加事件**

## 11. 事件源
- oEvent.target
  *兼容：高级浏览器
  低级浏览器 -> undefined

- oEvent.srcElement
  *兼容：Chrome、IE系
  FF -> undefined

**兼容写法**
var oSrc = oEvent.srcElement || oEvent.target;

> 注意：oSrc.tagName获取到的标签名都是大写

###给子级循环添加事件 闭包的替代写法 -> 委托
``` javascript
<script>
	oUl.onclick = function(ev) {
		var oEvent = ev || event;
		var oSrc = oEvent.scrElement || oEvent.target;
		if (oSrc.tagName == 'LI') {	// **注意获取到的标签名都是大写
			this.style.background = '#f00';
		}
	}
</script>
```

---

#blog10(原生运动框架)

---

## move.js

``` javascript
<script>

	function move(obj, json, options) {

		// 运动物体，{改变的属性及终态}，{总时间，运动形式，链式运动的回调}

		options = options || {};
		options.duration = options.duration || 700;  // 默认总时间 [可自定义]
		options.easing = options.easing || 'linear';  // 默认运动形式 [可自定义]

		clearInterval(obj.timer);

		var start = {};  // 起点
		var dis = {};  // 总距离

		for(var name in json) {
			start[name] = parseFloat(getStyle(obj, name));  // 字符串转数字，并保留小数(透明度)
			dis[name] = json[name] - start[name];
		}

		var count = Math.floor(options.duration / 30);  // 总次数 30ms 最佳定时器时间
		var n = 0;
		obj.timer = setInterval(function(){  // 自定义属性加定时器
			n++;
			for(var name in json) {
				switch(options.easing) {  // 自定义运动形式
					case 'linear':
						var a = n / count;
						var cur = start[name] + dis[name] * a;  // 匀速
						break;
					case 'ease-in':
						var a = n / count;
						var cur = start[name] + dis[name] * Math.pow(a, 3);  // 加速 a的3次方 [可自定义]
						break;
					case 'ease-out':
						var a = 1 - n / count;
						var cur = start[name] + dis[name] * (1 - Math.pow(a, 3));  // 减速 [可自定义]
						break;
				}

				if(name == 'opacity') {  // 若改变属性为透明度时另作处理
					obj.style.opacity = cur;
					obj.style.filter = 'Alpha(opacity:' + cur * 100 + ')';
				} else {
					obj.style[name] = cur + 'px';
				}
			}

			if( n == count) {
				clearInterval(obj.timer);
				options.complete && options.complete();  // 链式运动
			}
		}, 30);  // 30ms 最佳定时器时间
	}

	function getStyle(obj, name) {
		return (obj.currentStyle || getComputedStyle(obj, false))[name];
	}


</script>
```

---

#blog11(move框架应用) (上)

---

## 1. 仿jiaThis分享到

[JiaThis - 社会化分享按钮及移动端分享代码提供商！](http://www.jiathis.com/)

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	body {
		overflow: hidden;
	}
	#box {
		position: absolute;
		right: -140px;
		top: 50%;
		margin-top: -75px;
		padding: 20px;
		width: 100px;
		height: 150px;
		background: rgba(0, 0, 0, .1);
		color: #fff;
		font-size: 20px;
	}
	#box span {
		position: absolute;
		left: -20px;
		width: 20px;
		height: 60px;
		line-height: 20px;
		background: #fe0;
		color: #fff;
		font-size: 12px;
		text-align: center;
	}
</style>
```

``` html
	<div id="box">
		<span>分享到</span>
		<p>QQ</p>
		<p>WeChat</p>
		<p>sina</p>
	</div>
```

``` javascript
<script type="text/javascript" src='move.js'></script>
<script type="text/javascript">
	window.onload = function() {
		var oBox = document.getElementById('box');
		var oSpan = oBox.children[0];

		oBox.onmouseover = function() {
			move(oBox, {right: 0}, {duration: 300});
		}

		oBox.onmouseout = function() {
			move(oBox, {right: -140}, {duration: 300});
		}
	}
</script>
```

效果示例
![move框架应用 - 仿jiaThis分享到](http://ojvx9eehr.bkt.clouddn.com/jiaThis%E5%88%86%E4%BA%AB%E5%88%B0.gif)

## 2. 幻灯片

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	#box {
		position: relative;
		margin: 50px auto;
		width: 400px;
		height: 300px;
		overflow: hidden;
	}
	ul {
		position: absolute;
		top: 0;
		left: 0;
		width: 1200px;
		height: 250px;
	}
	ul li {
		width: 400px;
		height: 250px;
		float: left;
		list-style: none;
	}
	ul li img {
		width: 100%;
		height: 100%;
	}
	ol {
		position: absolute;
		left: 50%;
		bottom: 50px;
		margin-left: -45px;
	}
	ol li {
		margin: 10px;
		width: 10px;
		height: 10px;
		border-radius: 50%;
		border: 1px solid #fff;
		font-size: 8px;
		text-align: center;
		line-height: 10px;
		color: #fff;
		cursor: pointer;
	}
	ol li.active {
		background: #ccc;
	}
</style>
```

``` html
	<div id="box">
		<ul>
			<li><img src="img/slide1.jpg"></li>
			<li><img src="img/slide2.jpg"></li>
			<li><img src="img/slide3.jpg"></li>
		</ul>
		<ol>
			<li class="active">1</li>
			<li>2</li>
			<li>3</li>
		</ol>
	</div>
```

``` javascript
<script type="text/javascript" src='move.js'></script>
<script type="text/javascript">
	window.onload = function() {
		var oBox = document.body.children[0];
		var oUl = oBox.children[0];
		var oOl = oBox.children[1];
		var aLi = oUl.children;
		var aLi2 = oOl.children;

		for(var i = 0; i < aLi2.length; i++) {
			aLi2[i].index = i;
			(function(index) {
				aLi2[i].onmouseover = function() {
					for(var i = 0; i < aLi2.length; i++) {
						aLi2[i].className = '';
					}
					this.className = 'active';
					move(oUl, {marginLeft: - this.index * aLi[0].offsetWidth}, {duration: 500});
				}
			})(i);
		}
	}
</script>
```

效果示例
![move框架应用 - 幻灯片](http://ojvx9eehr.bkt.clouddn.com/move%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%20-%20%E5%B9%BB%E7%81%AF%E7%89%87.gif)


## 3. 手风琴

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	#box {
		position: relative;
		margin: 50px auto;
		width: 380px;
		height: 200px;
		overflow: hidden;
	}
	#box ul {
		width: 380px;
		height: 200px;
	}
	#box ul li {
		position: absolute;
		list-style: none;
		width: 380px;
		height: 200px;
	}
	#box ul li img{
		width: 100%;
		height: 100%;
	}
</style>
```

``` html
	<div id="box">
		<ul>
			<li><img src="img/slide1.jpg"></li>
			<li><img src="img/slide2.jpg"></li>
			<li><img src="img/slide3.jpg"></li>
			<li><img src="img/slide4.jpg"></li>
			<li><img src="img/slide5.jpg"></li>
		</ul>
	</div>
```

``` javascript
<script type="text/javascript" src='move.js'></script>
<script type="text/javascript">
	window.onload = function() {
		var oBox = document.body.children[0];
		var oUl = oBox.children[0];
		var aLi = oUl.children;

		var w = 30;
		for(var i = 1; i < aLi.length; i++) {
			aLi[i].style.left = oBox.offsetWidth - (aLi.length - i) * w + 'px';
		}

		for(var i = 0; i < aLi.length; i++) {
			aLi[i].index = i;
			aLi[i].onmouseover = function() {
				for(var i = 0; i < aLi.length; i++) {
					if(i <= this.index) {
						move(aLi[i], {left: i * w});  // 小于当前位置往右推
					} else {
						move(aLi[i], {left: oBox.offsetWidth - (aLi.length - i) * w});  // 大于当前位置往左推
					}
				}
			}
		}
		}
</script>
```

效果示例
![move框架应用 - 手风琴](http://ojvx9eehr.bkt.clouddn.com/%E6%89%8B%E9%A3%8E%E7%90%B4.gif)

## 4. 多图片展开

> 这个示例是有问题的，展开的z-index没有调整好，在此求解！

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	#box {
		position: relative;
		margin: 50px auto;
		width: 660px;
	}
	#box ul {
		width: 660px;
	}
	#box ul li {
		float: left;
		list-style: none;
		margin: 10px;
		width: 200px;
		height: 100px;
	}
	#box ul li img {
		width: 100%;
		height: 100%;
	}
</style>
```

``` html
	<div id="box">
		<ul>
			<li><img src="img/slide1.jpg"></li>
			<li><img src="img/slide2.jpg"></li>
			<li><img src="img/slide3.jpg"></li>
			<li><img src="img/slide4.jpg"></li>
			<li><img src="img/slide5.jpg"></li>
			<li><img src="img/slide6.jpg"></li>
			<li><img src="img/slide7.jpg"></li>
			<li><img src="img/slide8.jpg"></li>
			<li><img src="img/slide9.jpg"></li>
		</ul>
	</div>
```

``` javascript
<script type="text/javascript" src='move.js'></script>
<script type="text/javascript">
	window.onload = function() {
		var oBox = document.body.children[0];
		var oUl = oBox.children[0];
		var aLi = oUl.children;
		var bSin = false;

		var aPos = [];
		for(var i = 0; i < aLi.length; i++) {
			aPos[i] = {
				left: aLi[i].offsetLeft,
				top: aLi[i].offsetTop
			}
		}

		//浮动定位 -> 绝对定位
		for(var i = 0; i < aLi.length; i++) {
			aLi[i].style.position = 'absolute';
			aLi[i].style.left = aPos[i].left + 'px';
			aLi[i].style.top = aPos[i].top + 'px';
			aLi[i].style.margin = 0;
		}

		//移上中心放大动画
		for(var i = 0; i < aLi.length; i++) {
			aLi[i].index = i;
			aLi[i].onmouseover = function() {
				if(bSin) return;
				bSin = true;
				for(var i = 0; i < aLi.length; i++) {
					aLi[i].style.zIndex = 0;
				}
				move(this, {
					width: 600,
					height: 300,
					left: 30,
					top: 30
				});
				this.style.zIndex = 1;
			}

			aLi[i].onmouseout = function() {
				move(this, {
					width: 200,
					height: 100,
					left: aPos[this.index].left,
					top: aPos[this.index].top
				});
				bSin = false;
				// this.style.zIndex = 0;
			}
		}
	}
</script>
```

> 这个示例是有问题的，展开的z-index没有调整好，在此求解！

效果示例
![move框架应用 - 多图片展开](http://ojvx9eehr.bkt.clouddn.com/move%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%20-%20%E5%A4%9A%E5%9B%BE%E7%89%87%E5%B1%95%E5%BC%80.gif)


---

#blog12(move框架应用) (中)

---

## 5. 运动时钟

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	#box {
		margin: 20px auto;
		width: 185px;
		height: 35px;
		line-height: 35px;
		overflow: hidden;
	}
	#box ul li {
		float: left;
		position: relative;
		list-style: none;
		width: 23px;
		height: 35px;
	}
	#box ul li img {
		position: absolute;
	}
</style>
```

``` html
	<div id="box">
		<ul>
			<li><img src="img/num.png"></li>
			<li><img src="img/num.png"></li>
			<li>:</li>
			<li><img src="img/num.png"></li>
			<li><img src="img/num.png"></li>
			<li>:</li>
			<li><img src="img/num.png"></li>
			<li><img src="img/num.png"></li>
		</ul>
	</div>
```
``` javascript
<script type="text/javascript" src='move.js'></script>
<script>
	function toDou(num) {
		return num < 10 ? '0' + num : '' + num;
	}

	window.onload = function() {
		var oBox = document.body.children[0];
		var oUl = oBox.children[0];
		var aImg = oUl.getElementsByTagName('img');

		clock();
		setInterval(clock, 1000);

		function clock() {
			var oDate = new Date();
			var iH = oDate.getHours();
			var iM = oDate.getMinutes();
			var iS = oDate.getSeconds();

			var str = toDou(iH) + toDou(iM) + toDou(iS);

			for(var i = 0; i < aImg.length; i++) {
				// aImg[i].style.top = - str.charAt(i) * 35 + 'px';
				move(aImg[i], {top: - str.charAt(i) * 35}, {duration: 500});
			}
		}
	}
</script>
```


效果示例
![move框架应用 - 动态时钟](http://ojvx9eehr.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F.gif)

## 6. 返回顶部

> 此例因为涉及documentElement，move.js中没有相关判断，所以用move.js原理写了一个

``` css
<style>
	body {
		height: 3000px;
	    background: linear-gradient(red,blue);
	}
	input {
	    position: fixed;
	    right: 20px;
	    bottom: 20px;
	    display: none;
	}
</style>
```

``` html
	<input type="button" value="返回顶部" id="btn1" />
```
``` javascript
<script>
	window.onload = function() {
	    var oBtn = document.getElementById('btn1');

	    var timer = null;
	    // 添加滚动事件
	    var bSin = false;
	    window.onscroll = function() {
	        if (bSin) {
	            clearInterval(timer);
	        }
	        bSin = true;
	        var scrollT = document.documentElement.scrollTop || document.body.scrollTop;
	        if (scrollT > 0) {
	            // 按钮出来
	            oBtn.style.display = 'block';
	        } else {
	            oBtn.style.display = 'none';
	        }
	    };

	    // 按钮事件
	    oBtn.onclick = function() {
	        // 先关后开
	        var scrollT = document.documentElement.scrollTop || document.body.scrollTop;
	        clearInterval(timer);
	        var count = Math.floor(1000/30);
	        var dis = 0 - scrollT;
	        var n = 0;
	        timer = setInterval(function(){
	            bSin = false;
	            n++;
	            var a = 1-n/count;
	            var cur = scrollT + dis*(1-Math.pow(a,3));
	            document.documentElement.scrollTop = document.body.scrollTop = cur;
	            if (n == count) {
	                clearInterval(timer);
	            }
	        },30);
	    };
	};
</script>
```

效果示例
![move框架应用 - 返回顶部](http://ojvx9eehr.bkt.clouddn.com/%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8.gif)

## 7. 无缝滚动

> 此例资源为4张不重复图片，宽度为相应宽度*4

1. ul里的内容复制一份达到无缝的目的，再计算ul宽度

2. **模%求得余数**
  - 往左走(left负数)
	W = oUl.offsetWidth / 2;
	left -= 5;
	left = left % W;
  - 往右走(left正数)
	W = oUl.offsetWidht / 2;
	left += 5;
	left = (left % W - W) % W;

``` css
<style>
	* {
	    margin: 0;
	    padding: 0;
	}
	#box {
	    width: 1280px;
	    height: 220px;
	    border: 1px solid #000;
	    position: relative;
	    margin: 100px auto;
	    overflow: hidden;
	}
	#box ul {
	    position: absolute;
	    left: 0;
	    top: 0;
	}
	#box ul li {
	    float: left;
	    padding: 10px;
	    list-style: none;
	    width: 300px;
	    height: 200px;
	}
	#box ul li img {
	    width: 100%;
	    height: 100%;
	}
	#box span {
	    z-index: 2;
	    position: absolute;
	    top: 0;
	    width: 640px;
	    height: 220px;
	}
	#left {
	    left: 0;
	}
	#right {
	    right: 0;
	}
</style>
```

``` html
	<div id="box">
	    <ul>
	        <li><img src="img/slide1.jpg" alt=""></li>
	        <li><img src="img/slide2.jpg" alt=""></li>
	        <li><img src="img/slide3.jpg" alt=""></li>
	        <li><img src="img/slide4.jpg" alt=""></li>
	    </ul>
	    <span id="left"></span>
	    <span id="right"></span>
	</div>
```
``` javascript
<script>
	window.onload = function() {
	    var oBox = document.getElementById('box');
	    var oUl = oBox.children[0];
	    var oL = oBox.children[1];
	    var oR = oBox.children[2];
	    var aLi = oUl.children;

	    // 内容复制一份达到无缝的目的
	    oUl.innerHTML += oUl.innerHTML;

	    // 重新计算ul宽度
	    oUl.style.width = aLi[0].offsetWidth * aLi.length + 'px';

	    var timer = null;
	    oL.onmouseover = function() {
	        toLeft();
	    };
	    oR.onmouseover = function() {
	        toRight();
	    };

	    var left = 0;
	    var W = oUl.offsetWidth/2;

	    toRight();  // 默认向右滚动

	    function toRight() {
	        clearInterval(timer);
	        timer = setInterval(function(){
	            left += 5;
	            oUl.style.left = (left%W-W)%W + 'px';
	        },30);
	    }

	    function toLeft() {
	        clearInterval(timer);
	        timer = setInterval(function(){
	            left -= 5;
	            oUl.style.left = (left%W-W)%W + 'px';
	        },30);
	    }
	};
</script>
```
效果示例
![move框架应用 - 无缝滚动](http://ojvx9eehr.bkt.clouddn.com/%E6%97%A0%E7%BC%9D%E6%BB%9A%E5%8A%A8.gif)


## 8. 无缝幻灯片

1. ul里的内容复制一份达到无缝的目的，再计算ul宽度

2. **模%求得余数**
  - 往左走(left负数)
	W = oUl.offsetWidth / 2;
	left -= 5;
	left = left % W;
  - 往右走(left正数)
	W = oUl.offsetWidht / 2;
	left += 5;
	left = (left % W - W) % W;

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	#box {
		position: relative;
		margin: 50px auto;
		width: 600px;
		height: 350px;
		overflow: hidden;
	}
	#box ul {
		position: absolute;
	}
	#box ul li {
		float: left;
		list-style: none;
		width: 100%;
		height: 100%;

	}
	#box ul li img {
		width: 100%;
		height: 100%;
	}
	#box ol {
		position: absolute;
		left: 50%;
		bottom: 10px;
		width: 100px;
		margin-left: -50px;
	}
	#box ol li {
		float: left;
		margin: 5px;
		list-style: none;
		width: 10px;
		height: 10px;
		border-radius: 50%;
		background: #666;
		opacity: .7;
		cursor: pointer;
	}
	#box ol li.active {
		background: #fff;
	}
	#box a {
		position: absolute;
		z-index: 1;
		top: 50%;
		margin-top: -25px;
		width: 30px;
		height: 50px;
		line-height: 50px;
		text-align: center;
		background: #666;
		color: #fff;
		opacity: .1;
		border-radius: 2px;
		text-decoration: none;
	}
	#box a.prev {
		left: 0;
	}
	#box a.next {
		right: 0;
	}
</style>
```

``` html
	<div id="box">
		<a href="javascript:;" class="prev">←</a>
		<a href="javascript:;" class="next">→</a>
		<ul>
			<li><img src="img/slide1.jpg"></li>
			<li><img src="img/slide2.jpg"></li>
			<li><img src="img/slide3.jpg"></li>
			<li><img src="img/slide4.jpg"></li>
			<li><img src="img/slide5.jpg"></li>
		</ul>
		<ol>
			<li class="active"></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
		</ol>
	</div>
```
``` javascript
<script type="text/javascript" src='move.js'></script>
<script>
	window.onload = window.onresize = function() {
		var oBox = document.body.children[0];
		var oPrev = oBox.children[0];
		var oNext = oBox.children[1];
		var oUl = oBox.children[2];
		var oOl = oBox.children[3];
		var aLi = oUl.children;
		var aBtn = oOl.children;

		var iNow = 0;

		oBox.onmouseover = function() {
			clearInterval(timer2);
			move(oPrev, {opacity: 0.7}, {duration: 500});
			move(oNext, {opacity: 0.7}, {duration: 500});
		}

		oBox.onmouseout = function() {
			carousel();
			move(oPrev, {opacity: 0.1}, {duration: 300});
			move(oNext, {opacity: 0.1}, {duration: 300});
		}

		for(var i = 0; i < aLi.length; i++) {
			aLi[i].style.width = oBox.offsetWidth + 'px';
		}
		oUl.innerHTML += oUl.innerHTML;
		oUl.style.width = aLi.length * (aLi[0].offsetWidth) + 'px';

		var timer2 = null;
		carousel();

		function carousel() {
			clearInterval(timer2);
			timer2 = setInterval(function() {
				iNow++;
				tab();
			}, 3000);
		}

		for(var i = 0; i < aBtn.length; i++) {
			aBtn[i].index = i;
			aBtn[i].onmouseover = function() {
				// iNow = this.index;

				//第几轮，解决第二轮之后上移运动回第一轮的问题
				iNow = Math.floor(iNow/aBtn.length)*aBtn.length+this.index;
				tab();
			}
		}

		oPrev.onclick = function() {
			iNow--;
			tab();
		}

		oNext.onclick = function() {
			iNow++;
			tab();
		}

		function tab() {
			for(var i = 0; i < aBtn.length; i++) {
				aBtn[i].className = '';
			}

			//解决当iNow<0时aBtn[iNow%aBtn.length]找不到的问题
            aBtn[(iNow%aBtn.length+aBtn.length)%aBtn.length].className = 'active';
			// move(oUl, {left: - aLi[0].offsetWidth * iNow}, {duration: 500});
			toR(oUl, - aLi[0].offsetWidth * iNow);
		}

		var iW = oUl.offsetWidth / 2;
		var timer = null;
		var left = 0;
		function toR(obj, iTarget) {
			clearInterval(timer);
			var start = left;
			var dis = iTarget - start;
			var count = Math.floor(1000 / 30);
			var n = 0;
			timer = setInterval(function() {
				n++;
				var a = n / count;
				var cur = start + dis * a;
				left = cur;
				oUl.style.left = (left % iW - iW) % iW + 'px';

				if(n == count) {
					clearInterval(timer);
				}
			}, 30);
		}
	}
</script>
```
效果示例
![move框架应用 - 无缝幻灯片](http://ojvx9eehr.bkt.clouddn.com/%E6%97%A0%E7%BC%9D%E5%B9%BB%E7%81%AF%E7%89%87.gif)

## 9. 带进度条的无缝幻灯片

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	#box {
		position: relative;
		margin: 50px auto;
		width: 350px;
		height: 200px;
		overflow: hidden;
	}
	#box ul {
		position: absolute;
	}
	#box ul li {
		float: left;
		list-style: none;
		width: 350px;
		height: 200px;
		text-align: center;
		line-height: 200px;
		font-size: 80px;
		color: #ffb;
	}
	#box ol {
		position: absolute;
		left: 50%;
		bottom: 10px;
		margin-left: -150px;
		width: 300px;
	}
	#box ol li {
		position: relative;
		float: left;
		margin: 10px;
		list-style: none;
		width: 40px;
		height: 10px;
		background: #fff;
	}
	#box ol li span {
		position: absolute;
		top: 0;
		width: 0;
		height: 10px;
		background: #666;
	}
</style>
```

``` html
	<div id="box">
		<ul>
			<li style="background: #aaa">1</li>
			<li style="background: #afe">2</li>
			<li style="background: #50f">3</li>
			<li style="background: #aea">4</li>
			<li style="background: #fe0">5</li>
		</ul>
		<ol>
			<li><span></span></li>
			<li><span></span></li>
			<li><span></span></li>
			<li><span></span></li>
			<li><span></span></li>
		</ol>
	</div>
```
``` javascript
<script type="text/javascript" src='move.js'></script>
<script>
	window.onload = function() {
		var oBox = document.body.children[0];
		var oUl = oBox.children[0];
		var aLi = oUl.children;
		var oOl = oBox.children[1];
		var aSpan = oOl.getElementsByTagName('span');

		oUl.innerHTML += oUl.innerHTML;
		oUl.style.width = aLi.length * aLi[0].offsetWidth + 'px';

		var iNow = 0;
		next();

		function next() {
			move(aSpan[iNow % aSpan.length], {width: 40}, {easing: 'ease-out',complete: function(){
				// 回调函数
				iNow++;
				for(var i = 0; i < aSpan.length; i++) {
					aSpan[i].style.width = 0;
				}
				move2(oUl, -iNow * aLi[0].offsetWidth, function() {
					!bSin && next();
				});
			}});
		}

		var iW = oUl.offsetWidth / 2;
		var left = 0;
		var timer = null;

		function move2(obj, iTarget, complete) {
			clearInterval(timer);
			var start = left;
			var dis = iTarget - start;
			var count = Math.floor(1000 / 30);
			var n = 0;
			timer = setInterval(function() {
				n++;
				var a = n / count;
				var cur = start + dis * a;
				left = cur;
				obj.style.left = (left % iW - iW) % iW + 'px';
				if(n == count) {
					clearInterval(timer);
					complete && complete();
				}
			}, 30);
		}

		var bSin = false;
		oBox.onmouseover = function() {
			bSin = true;
			for(var i = 0; i < aSpan.length; i++) {
				clearInterval(aSpan[i].timer);
				aSpan[i].style.width = 0;
			}
		}

		oBox.onmouseout = function() {
			bSin = false;
			next();
		}

	}
</script>
```

效果示例
![move框架应用 - 带进度条的无缝幻灯片](http://ojvx9eehr.bkt.clouddn.com/%E5%B8%A6%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%9A%84%E6%97%A0%E7%BC%9D%E5%B9%BB%E7%81%AF%E7%89%87.gif)

---

#blog13(move框架应用) (下)

---

## 10. 打字依次显示效果

``` css
<style>
	body {
		background: #000;
	}
	span {
		color: #fff;
		font-size: 20px;
		opacity: 0;
	}
</style>
```

``` html

```
``` javascript
<script type="text/javascript" src='move.js'></script>
<script>
	window.onload = function () {
		var str = '往左走(left负数)W = oUl.offsetWidth / 2;left -= 5;left = left % W;往右走(left正数)W = oUl.offsetWidht / 2;left += 5;left = (left % W - W) % W;';
		for(var i = 0; i < str.length; i++) {
			var oS = document.createElement('span');
			oS.innerHTML = str.charAt(i);
			document.body.appendChild(oS);
		}

		var aSpan = document.body.children;
		var i = 0;

		// 分步运动
		var timer = setInterval(function() {
			move(aSpan[i], {opacity: 1}, {duration: 100});
			i++;
			if(i == aSpan.length) {
				clearInterval(timer);
			}
		}, 100);

	}
</script>
```
效果示例
![move框架应用 - 打字依次显示效果](http://ojvx9eehr.bkt.clouddn.com/%E6%89%93%E5%AD%97%E4%BE%9D%E6%AC%A1%E5%BC%B9%E5%87%BA%E6%95%88%E6%9E%9C.gif)


## 11. 收起当前页放出下一页效果

``` css
<style>
	* {
	    margin: 0;
	    padding: 0;
	}
	ul {
	    width: 516px;
	    margin: 50px auto;
	}
	ul li {
	    list-style: none;
	    width: 150px;
	    height: 150px;
	    background: #ccc;
	    float: left;
	    margin: 10px;
	    border: 1px solid #000;
	}
</style>
```

``` html
	<input type="button" value="下一页" id="btn1" />
	<ul id="ul1">
	    <li></li>
	    <li></li>
	    <li></li>
	    <li></li>
	    <li></li>
	    <li></li>
	    <li></li>
	    <li></li>
	    <li></li>
	</ul>
```

``` javascript
<script type="text/javascript" src='move.js'></script>
<script>
	window.onload = function() {
	    var oBtn = document.getElementById('btn1');
	    var oUl = document.getElementById('ul1');
	    var aLi = oUl.children;

	    // 浮动定位 -> 绝对定位
	    var aPos = [];
	    for (var i = 0; i < aLi.length; i++) {
	        aPos[i] = {
	            left: aLi[i].offsetLeft,
	            top: aLi[i].offsetTop
	        };
	    }
	    for (var i = 0; i < aLi.length; i++) {
	        aLi[i].style.position = 'absolute';
	        aLi[i].style.left = aPos[i].left + 'px';
	        aLi[i].style.top = aPos[i].top + 'px';
	        aLi[i].style.margin = 0;
	    }

	    var timer = null;
	    var bSin = false;
	    oBtn.onclick = function() {
	        if (bSin) return;
	        bSin = true;

	        // 分步运动
	        var i = 0;
	        timer = setInterval(function(){
	            (function(index){
	                // 收起
	                move(aLi[i], {
	                    left: 0, top:0, width: 0,
	                    height: 0, opacity: 0
	                },{
	                    complete: function() {	// 回调函数
	                        if (index == aLi.length-1) {
	                            // 放出
	                            for (var i = 0; i < aLi.length; i++) {
	                                aLi[i].style.background = 'rgb('+parseInt(Math.random()*256)+','+parseInt(Math.random()*256)+','+parseInt(Math.random()*256)+')';
	                            }

	                            timer = setInterval(function(){
	                                (function(index2){
	                                    move(aLi[index], {
	                                        left: aPos[index].left, top: aPos[index].top, width: 150, height: 150, opacity: 1
	                                    },{
	                                        complete: function(){
	                                            if (index2 == 0) {
	                                            	// 放出最后一张后点击才有效
	                                                bSin = false;
	                                            }
	                                        }
	                                    });
	                                })(index);

	                                index--;
	                                if (index < 0) {
	                                    clearInterval(timer);
	                                }
	                            },200);
	                        }
	                    }
	                })
	            })(i);

	            i++;
	            if (i == aLi.length) {
	                clearInterval(timer);
	            }
	        },200);
	    };
	};
</script>
```
效果示例
![move框架应用 - 收起当前页放出下一页效果](http://ojvx9eehr.bkt.clouddn.com/move%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%20-%20%E6%94%B6%E8%B5%B7%E5%BD%93%E5%89%8D%E9%A1%B5%E6%94%BE%E5%87%BA%E4%B8%8B%E4%B8%80%E9%A1%B5%E6%95%88%E6%9E%9C.gif)



## 12. 分块运动

1. 自定义行数R、列数C
2. 创建span
   计算oSpan的width、height、left、top、background-position

  > 注意：先appendChild才能获取oSpan的offsetWidth和offsetHeight

3. 分步运动，依次显示span

**优化：setInterval可用for循环+setTimeout替代，可设置行列相关时同一时间出现**

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	#btn{
		margin: 20px auto;
		padding: 5px;
		width: 100px;
		height: 20px;
		background: #f5850e;
		color: #fff;
		font-size: 16px;
		text-align: center;
		line-height: 20px;
		border-radius: 5px;
		cursor: pointer;
	}
	#box {
		position: relative;
		margin: 50px auto;
		width: 500px;
		height: 300px;
		background: url('img/slide0.jpg');
	}
	#box span{
		position: absolute;
		opacity: .1;
		/* opacity: 0; */
	}
</style>
```

``` html
	<div id='btn'>点击随机变换</div>
	<div id="box"></div>
```

``` javascript
<script type="text/javascript" src='move.js'></script>
<script>
	window.onload = function() {
		var oBtn = document.body.children[0];
		var oBox = document.body.children[1];

		var R = 3;
		var C = 5;

		// 整图 -> 分块(绝对定位)
		for(var r = 0; r < R; r++) {
			for(var c = 0; c < C; c++) {
				var oSpan = document.createElement('span');
				oSpan.style.width = oBox.offsetWidth / C + 'px';
				oSpan.style.height = oBox.offsetHeight / R + 'px';
				oBox.appendChild(oSpan);
				oSpan.style.left = oSpan.offsetWidth * c + 'px';
				oSpan.style.top = oSpan.offsetHeight * r + 'px';
				oSpan.style.backgroundPosition = - oSpan.offsetWidth * c + 'px ' + (-oSpan.offsetHeight * r) + 'px';
				oSpan.r = r;
				oSpan.c = c;
			}
		}

		var aSpan = oBox.children;
		var iNow = 0;
		var bSin = false;

		oBtn.onclick = function() {
			if(bSin) {return;}
			bSin = true;
			iNow++;
			oBox.style.background = 'url("img/slide'+ (iNow%9-1+9)%9 +'.jpg")';

			block(parseInt(Math.random()*7+1));		// 随机变换显示方式
		}

		var json = {};
		for(var i = 0; i < 8; i++) {
			json[i] = 0;
		}

		function block(method) {
			json[method]++;
			var med = 1;
			for(var i = 0; i < aSpan.length; i++) {
				(function(index) {
					switch(method) {
						case 1: med = index;
							break;
						case 2: med = aSpan[index].r + aSpan[index].c;  // 斜角显示
							break;
						case 3: med = aSpan[index].r * aSpan[index].c;
							break;
						case 4: med = aSpan[index].r - aSpan[index].c;
							break;
						case 5: med = aSpan[index].r / aSpan[index].c;
							break;
						case 6: med = aSpan.length - index;  // 由下至上
							break;
						case 7: med = Math.random();
							break;
					}
					setTimeout(function(){
						aSpan[index].style.backgroundImage = 'url("img/slide'+ iNow%9 + '.jpg")';
						aSpan[index].style.opacity = 0.1;
						(function(index2) {
							move(aSpan[index], {opacity: 1}, {complete: function() {
									if(index2 == aSpan.length - 1) {
										// 放出最后一个分块后点击才有效
										bSin = false;
									}
							}});
						})(index);
					}, 100*(med));	// 每个分块延迟时间不同，达到依次显示的效果
				})(i);
			}
		}
	}
</script>
```
效果示例
![move框架应用 - 分块运动](http://ojvx9eehr.bkt.clouddn.com/move%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%20-%20%E5%88%86%E5%9D%97%E8%BF%90%E5%8A%A8.gif)


## 13. 仿Mac 感应变大效果

1. 感应距离：一般为500

  比例：scale = 1 - c/500;

2. 勾股定理计算鼠标至图片中心距离

  var a = getPos(aImg[i]).left + aImg[i].offsetWidth / 2 - oEvent.clientX;

  var b = getPos(aImg[i]).top + aImg[i].offsetHeight / 2 - oEvent.clientY;

 var c = Math.sqrt(a * a + b * b);

3. 计算方放大比例，范围为[0.5, 1]
  var scale = 1 - c / 500;
  scale < 0.5 && (scale = 0.5);
  aImg[i].style.width = scale * 80 + 'px';


``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}

	#box {
		position: absolute;
		bottom: 20px;
		width: 100%;
		text-align: center;
	}
</style>
```

``` html
	<div id="box">
		<img src="img/per-1.png" width="40">
		<img src="img/per-2.png" width="40">
		<img src="img/per-3.png" width="40">
	</div>
```

``` javascript
<script>
	function getPos(obj) {
		var l = 0;
		var t = 0;
		while(obj) {
			l += obj.offsetLeft;
			t += obj.offsetTop;
			obj = obj.offsetParent;
		}

		return {left: l, top: t};
	}
	window.onload = function() {
		var oBox = document.body.children[0];
		var aImg = oBox.children;

		document.onmousemove = function(ev) {
			var oEvent = ev || event;
			for(var i = 0; i < aImg.length; i++) {

				// 勾股定理计算鼠标至图片中心距离
				var a = getPos(aImg[i]).left + aImg[i].offsetWidth / 2 - oEvent.clientX;
				var b = getPos(aImg[i]).top + aImg[i].offsetHeight / 2 - oEvent.clientY;
				var c = Math.sqrt(a * a + b * b);

				//计算方放大比例，范围为[0.5, 1]
				var scale = 1 - c / 500;
				scale < 0.5 && (scale = 0.5);
				aImg[i].style.width = scale * 80 + 'px';
			}
		}
	}
</script>
```
效果示例
![move框架应用 - 感应变大效果](http://ojvx9eehr.bkt.clouddn.com/move%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%20-%20%E6%84%9F%E5%BA%94%E5%8F%98%E5%A4%A7.gif)



---

#blog14(前端规范)

---

## 1. Reset.css && Normailze.css

- reset.css 的作用是清除所有的默认样式
- normalize.css 是把所有的元素样式回归本该是的样子，并且消除了不同浏览器之间默认样式的区别。

### Reset
[张鑫旭-HTML5 css reset](http://www.zhangxinxu.com/wordpress/2010/08/html5-css-reset/)

[目前比较全的CSS重设(reset)方法总结](http://www.cnblogs.com/hnyei/archive/2011/10/04/2198779.html)

### Normailze
[Normalize.css：使浏览器更一致地呈现所有元素。](http://necolas.github.io/normalize.css/)

## 2. css命名规范

**CSS内部的分类及其顺序**

1. **布局（grid）（.g-）**：将页面分割为几个大块，通常有头部、主体、主栏、侧栏、尾部等！
2. **模块（module）（.m-）**：通常是一个语义化的可以重复使用的较大的整体！比如导航、登录、注册、各种列表、评论、搜索等！
3. **元件（unit）（.u-）**：通常是一个不可再分的较为小巧的个体，通常被重复用于各种模块中！比如按钮、输入框、loading、图标等！
4. **功能（function）（.f-）**：为方便一些常用样式的使用，我们将这些使用率较高的样式剥离出来，按需使用，通常这些选择器具有固定样式表现，比如清除浮动等！不可滥用！
5. **皮肤（skin）（.s-）**：如果你需要把皮肤型的样式抽离出来，通常为文字色、背景色（图）、边框色等，非换肤型网站通常只提取文字色！非换肤型网站不可滥用此类！
6. **状态（.z-）**：为状态类样式加入前缀，统一标识，方便识别，她只能组合使用或作为后代出现（.u-ipt.z-dis{}，.m-list li.z-sel{}），具体详见命名规则的扩展相关项。

> 特殊：.j-将被专用于JS获取节点，请勿使用.j-定义样式。



示例
``` css
<style>
	/* 统一调用背景图 */
	.m-logo a,.m-nav a,.m-nav em{background:url(images/sprite.png) no-repeat 9999px 9999px;}
	/* 统一清除浮动 */
	.g-bdc:after,.m-dimg ul:after,.u-tab:after{display:block;visibility:hidden;clear:both;height:0;overflow:hidden;content:'.';}
	.g-bdc,.m-dimg ul,.u-tab{zoom:1;}
	/* 布局 */
	.g-sd{float:left;width:300px;}
	/* 模块 */
	.m-logo{width:200px;height:50px;}
	/* 元件 */
	.u-btn{height:20px;border:1px solid #333;}
	/* 功能 */
	.f-tac{text-align:center;}
	/* 皮肤 */
	.s-fc,a.s-fc:hover{color:#fff;}
</style>
```


**布局（.g-）**

| 语义	| 命名	| 简写|
|  :----: | :----: | :---:  |
| 文档	| doc	| doc|
| 头部	| head	| hd|
| 主体	| body	| bd|
| 尾部	| foot	| ft|
| 主栏	| main	| mn|
| 主栏子容器	| mainc	| mnc|
| 侧栏	| side	| sd|
| 侧栏子容器	| sidec| 	sdc|
| 盒容器	| wrap/box	| wrap/box|

**模块（.m-）、元件（.u-）**

| 语义	| 命名	| 简写|
|  :----: | :----: | :---:  |
| 导航	| nav	| nav|
| 子导航	| subnav	| snav|
| 面包屑	| crumb	| crm|
| 菜单	| menu	| menu|
| 选项卡	| tab	| tab|
| 标题区	| head/title	| hd/tt|
| 内容区	| body/content	| bd/ct|
| 列表	| list	| lst|
| 表格	| table	| tb|
| 表单	| form	| fm|
| 热点	| hot	| hot|
| 排行	| top	| top|
| 登录	| login	| log|
| 标志	| logo	| logo|
| 广告	| advertise	| ad|
| 搜索	| search	| sch|
| 幻灯	| slide	| sld|
| 提示	| tips	| tips|
| 帮助	| help	| help|
| 新闻	| news	| news|
| 下载	| download	| dld|
| 注册	| regist	| reg|
| 投票	| vote	| vote|
| 版权	| copyright	| cprt|
| 结果	| result	| rst|
| 标题	| title	| tt|
| 按钮	| button	| btn|
| 输入	| input	| ipt|

**功能（.f-）**

| 语义	| 命名	| 简写|
|  :----: | :----: | :---:  |
| 浮动清除	| clearboth	| cb|
| 向左浮动	| floatleft	| fl|
| 向右浮动	| floatright	| fr|
| 内联块级	| inlineblock	| ib|
| 文本居中	| textaligncenter	| tac|
| 文本居右	| textalignright	| tar|
| 文本居左	| textalignleft	| tal|
| 垂直居中	| verticalalignmiddle	| vam|
| 溢出隐藏	| overflowhidden	| oh|
| 完全消失	| displaynone	| dn|
| 字体大小	| fontsize	| fs|
| 字体粗细	| fontweight	| fw|

**皮肤（.s-）**

| 语义	| 命名	| 简写|
|  :----: | :----: | :---:  |
| 字体颜色	| fontcolor	| fc|
| 	背景	| background	| bg|
| 背景颜色	| backgroundcolor	| bgc|
| 背景图片	| backgroundimage	| bgi|
| 背景定位	| backgroundposition	| bgp|
| 边框颜色	| bordercolor	| bdc|

**状态（.z-）**

| 语义	| 命名	| 简写|
|  :----: | :----: | :---:  |
| 选中	| selected	| sel|
| 当前	| current	| crt|
| 显示	| show	| show|
| 隐藏	| hide	| hide|
| 打开	| open	| open|
| 关闭	| close	| close|
| 出错	| error	| err|
| 不可用	| disabled	| dis|


## 3. 注释的写法 

<!-- header -->
<header>xxx</header>

<!-- end header -->

## 4. id命名 

### (1)页面结构 

容器: container 
页头：header 
内容：content/container 
页面主体：main 
页尾：footer 
导航：nav 
侧栏：sidebar 
栏目：column 
包裹层：wrapper 
左右中：left right center 

### (2)导航 

导航：nav 
主导航：mainnav 
子导航：subnav 
顶导航：topnav 
边导航：sidebar 
左导航：leftsidebar 
右导航：rightsidebar 
菜单：menu 
子菜单：submenu 
标题: title 
摘要: summary 

### (3)功能 
标志：logo 
广告：banner 
登陆：login 
登录条：loginbar 
注册：regsiter 
搜索：search 
功能区：shop 
标题：title 
加入：joinus 
状态：status 
按钮：btn 
滚动：scroll 
标签页：tab 
文章列表：list 
提示信息：msg 
当前的: current 
小技巧：tips 
图标: icon 
注释：note 
指南：guide 
服务：service 
热点：hot 
新闻：news 
下载：download 
投票：vote 
合作伙伴：partner 
友情链接：link 
版权：copyright 

## 5. class的命名 

(1) 颜色:使用颜色的名称或者16进制代码,如 
.red { color: red; } 
.f60 { color: #f60; } 
.ff8600 { color: #ff8600; } 

(2) 字体大小,直接使用"font+字体大小"作为名称,如 
.font12px { font-size: 12px; } 
.font9pt {font-size: 9pt; } 

(3) 对齐样式,使用对齐目标的英文名称,如 

.left { float:left; } 

(4) 标题栏样式,使用"类别+功能"的方式命名,如 
.barnews { } 
.barproduct { } 

> 注意事项 
1.一律小写; 
2.尽量用英文; 
3.尽量不缩写，除非一看就明白的单词.

## 6. css层次
主要的 main.css/index.css
模块 module.css 
基本共用 base.css/global.css
布局，版面 layout.css 
主题 themes.css 
专栏 columns.css 
文字 font.css 
表单 forms.css 
补丁 mend.css 

## 7. css书写次序
显示属性 -> 自身属性 -> 文本属性和其他修饰


 | 显示属性	| 自身属性	| 文本属性和其他修饰|
 |  :----: 	|   :----: 	| :---:             |
 |	display	|margin	    |font               |
 |visibility|padding	|text-align			|
 |position  |width		|text-decoration	|
 | 	float	|height		|vertical-align		|
 |	clear	|border		|white-space		|
 |list-style|overflow	|color				|
 |	top 	|min-width	|background			|

 - 显示属性： `display`, `visibility`, `position`, `top`, `float`, `clear`, `list-style`
 - 自身属性： `margin`, `padding`, `width`, `height`, `border`, `overflow`, `min-width`
 - 文本属性： `font`, `text-align`, `text-decoration`, `vertical-align`， `white-space`, `color`, `background`

## 8. 媒体查询(media)屏幕宽度

``` css

<style>
	/* 横屏 */
	@media screen and (orientation:landscape){
	    
	}
	/* 竖屏 */
	@media screen and (orientation:portrait){
	    
	}
	/* 窗口宽度<960,设计宽度=768 */
	@media screen and (max-width:959px){
	    
	}
	/* 窗口宽度<768,设计宽度=640 */
	@media screen and (max-width:767px){
	    
	}
	/* 窗口宽度<640,设计宽度=480 */
	@media screen and (max-width:639px){
	    
	}
	/* 窗口宽度<480,设计宽度=320 */
	@media screen and (max-width:479px){
	    
	}
	/* windows UI 贴靠 */
	@media screen and (-ms-view-state:snapped){
	    
	}
	/* 打印 */
	@media print{
	    
	}
</style>

```

## 9. js常见变量命名

常见类型前缀
- `o`  object 一个对象，一个元素 eg:oDiv
- `a`  array  一组元素 eg:aLi
- `s` string 字符串 eg:sUserName
- `i` integer 整数 eg:iCount
- `f`  float 浮点数 eg:fPrice
- `b` boolean 布尔 eg:bOk
- `fn` function 函数 eg:fnSucc(成功的回调函数)
- `re` RegExp 正则 eg:reMailCheck


---

#blog15(原生篇6) cookie、Require、数据交互前导

---

## 1. cookie

**数据类型：string**

1. 需在服务器环境中
2. 不安全
3. 过期时间(expires)：默认关闭浏览器时清空
  > session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie;
  平常所说的cookie主要指的是另一类cookie——持久cookie（persistent cookies）。

  ``` javascript
  <script>
    var oDate = new Date();
    oDate.setDate(oDate.getDate()+3);  // 延迟三天清空
    document.cookie = 'expires=' + oDate;
  </script>
  ```
4. 容量小，4k左右
5. 返回的数据类型是字符串，使用时需转化
6. 内部能访问外部cookie，外部不能访问内部cookie
   path统一设置到根目录  `document.cookie = 'name=value;path=/';`

7. domain 设置域名访问
	eg: baidu
	baidu.com  `domain=baidu.com`  需在上一级域名设置domain
	fanyi.baidu.com  `setCookie`
	baike.baidu.com  `getCookie`

8. 有缓存

### 封装cookie.js
``` javascript
<script>

	// 设置cookie
	function setCookie(name, value, iDay) {
		if(iDay) {
			var oDate = new Date();
			oDate.setDate(oDate.getDate() + iDay);
			document.cookie = name + '=' + value + ';path=/;expires=' + oDate;
			// document.cookie = name + '=' + value + ';path=/;expires=' + oDate + ';domain=localhost';  // 设置只能在localhost下设置cookie
		} else {
			document.cookie = name + '=' + value + ';path=/';  // 关闭浏览器时清空
		}
	}

	// cookie形式 eg: "name1=value1; name2=value"  (表达式之间有空格)

	// 获取cookie
	function getCookie(name) {
		var str = document.cookie;
		var arr = str.split('; ');  // **分号后有空格
		for(var i = 0; i < arr.length; i++) {
			var arr2 = arr[i].split('=');
			if(arr2[0] == name) {
				return arr2[1];
			}
		}

		return '';  // 没有找到即返回空字符串
	}

	// 移除cookie
	function removeCookie(name) {
		setCookie(name, 'xxx', -10);  // **将日期设为小于0的值  '-0'不能达到移除cookie的目的
	}
</script>
```

## 2. 模块化

### sea.js && require.js
| sea.js | 		require.js      |
| :--: | 	   :----: 	  |
| 采用CMD(通用模块定义,依赖就近)    | 	   采用AMD(异步模块定义,依赖前置)  	  |

[AMD 和 CMD 的区别有哪些? - 玉伯的回答 - 知乎](https://www.zhihu.com/question/20351507/answer/14859415)

[前端模块化（CommonJs,AMD和CMD）](http://www.jianshu.com/p/d67bc79976e6)

[详解JavaScript模块化开发](https://segmentfault.com/a/1190000000733959)

## 3. Require.js

[RequireJS 中文网](http://www.requirejs.cn/)

**好处**
1. 解决命名冲突
2. 解决文件彼此依赖
3. 自动引入js
4. 异步加载，可维护性高
   只发送一个请求，最终引用文件命名为init.js
   或者`<script src="require.js" data-main="init"></script>`

#### (1)定义模块

r1.js
``` javascript
<script>

	define(function(require, exports, module) {
		// 引入模块，导出模块，批量导出
		exports.a = 1;

		// console.log(1);

		// return {a:1, b:2};
	});

</script>
```

#### (2)使用模块
``` javascript
<script>

	// require(['r1.js']);  // 可不写函数

	require(['r1.js'], function(mod) {  // **使用时注意路径，若报错试着将路径改为'js/r1.js'
		console.log(mod.a);	// 1
	})

</script>
```

``` javascript
<script>

	require(['r1.js', 'r2.js'], function(mod1, mod2) {	// 使用多个模块
		console.log(mod1.a, mod2.a);
	})

</script>
```

#### (3)引用模块

这里的模块依赖其实应该一开始就写好。

![依赖前置](http://ojvx9eehr.bkt.clouddn.com/img/%E4%BE%9D%E8%B5%96%E5%89%8D%E7%BD%AE.PNG)

``` javascript
<script>

	define(function(require, exports, module) {
		// 引入模块，导出模块，批量导出
		var mod1 = require('r1.js');
		var mod2 = require('r2.js');
		exports.sum = function() {
			return mod1.a + mod2.a;
		}
	});

</script>
```

> 因专用于js，require时可省略类型后缀  'js/r1.js' -> 'js/r1'


### Require的使用结构一般如下
exp1.html放于主目录
js文件放在js文件夹下

exp1.html
```
...
...

<script src="js/require.js" data-main="js/init"></script>

...
...


```

init.js

``` javascript
<script>

	require(['exp1']);

</script>
```

exp1.js

``` javascript
<script>

	define(function(require) {
		var r1 = require('r1');

		...
		...

		oBtn.onclick = function() {
			...
			r1(xxx);
		}
	})

</script>
```

r1.js
``` javascript
<script>

	define(function(require) {
		var move = require('move');

		...
		...

		return function(yyy) {
			...

			...

			move(aaa, {opacity: 1});
		}
	})

</script>
```

## 4. 数据交互

### form提交数据
缺点：(1)会刷新页面  (2)不能取出数据

想要提交数据须有
1. action 提交的地址 `<form action=''></form>`
2. name   数据名称   `<input name="user.tel" />`
3. value  数据       `input.value`

提交方式
1. get(默认) 容量32K左右  不安全，有缓存
** 好处：(1)分享 (2)收藏**

2. post      容量1G左右   相对安全，没有缓存

> 缓存(cache)
对于浏览器而言，相同的地址只会访问一次


### ajax(Asynchronous JavaScript and XML，异步JavaScript和XML)
1. 需在服务器环境中
2. 编码需一致
3. url若为文件名，可不写文件名后缀
4. 返回的数据类型是字符串，使用时需转化
5. 缓存(get方法)
  浏览器清除缓存 `ctrl+F5` 或 `ctrl+alt+delete`
  防止IE缓存
    路径+随机因子
    (1)`'路径?t=' + Math.random();`
    (2)`'路径?t=' + oDate.getTime();`
    eg:`var URL = 'user.php?act=login&user=' + logU.value + '&pass=' + logP.value + '&t=' + new Date().getTime();`

## 5. eval的替代用法
``` javascript
<script>

	function strTrs(str) {
		var fn = new Function('return' + str);
		return fn();
	}

</script>
```

## 6. 数据交互时输入中文问题
中文转换URL编码 `encodeURIComponent(str)`
解编码 `decodeURIComponent(str)`

**IE兼容写法**
``` javascript
<script>

	var URL = 'user.php?act=login&user=' + encodeURIComponent(logU.value) + '&pass=' + encodeURIComponent(logP.value) + '&t=' + new Date().getTime();

</script>
```

将url的查询参数解析成字典对像
``` javascript
<script>
	function getQueryObject(url) {
		url = url == null ? window.location.href : url;
		var search = url.substring(url.lastIndexOf("?") + 1);
		var obj = {};
		var reg = /([^?&=]+)=([^?&=]*)/g;
		search.replace(reg, function(rs, $1, $2) {
			var name = decodeURIComponent($1);
			var val = decodeURIComponent($2);
			val = String(val);
			obj[name] = val;
			return rs;
		});
		return obj;
	}
</script>
```


---

#blog16(ajax jsonp)

---

## 1. Ajax前导
### (1) XMLHttpRequest
*兼容： 除IE6
ie6 -> 报错

### (2) readyState就绪状态
- `0` uninitialized ajax  对象创建成功
- `1` loading  打开连接(已经建立连接)
- `2` loaded  发送数据
- `3` interactive  下载内容
- `4` complete  完成

### (3) HTTP状态码
**重点**
- `200` ok
- `304` not modified
- `403` Forbidden
- `404` Not found
- `405` Not allowed
- `414` Request-URI Too Long
- `500` Internal Server Error
- `502` Bad Gateway

> 附：全部状态码
'100': 'Continue',
'101': 'Switching Protocols',
'102': 'Processing',
'200': 'OK',
'201': 'Created',
'202': 'Accepted',
'203': 'Non-Authoritative Information',
'204': 'No Content',
'205': 'Reset Content',
'206': 'Partial Content',
'207': 'Multi-Status',
'208': 'Already Reported',
'226': 'IM Used',
'300': 'Multiple Choices',
'301': 'Moved Permanently',
'302': 'Found',
'303': 'See Other',
'304': 'Not Modified',
'305': 'Use Proxy',
'307': 'Temporary Redirect',
'308': 'Permanent Redirect',
'400': 'Bad Request',
'401': 'Unauthorized',
'402': 'Payment Required',
'403': 'Forbidden',
'404': 'Not Found',
'405': 'Method Not Allowed',
'406': 'Not Acceptable',
'407': 'Proxy Authentication Required',
'408': 'Request Timeout',
'409': 'Conflict',
'410': 'Gone',
'411': 'Length Required',
'412': 'Precondition Failed',
'413': 'Payload Too Large',
'414': 'URI Too Long',
'415': 'Unsupported Media Type',
'416': 'Range Not Satisfiable',
'417': 'Expectation Failed',
'418': 'I\'m a teapot',
'421': 'Misdirected Request',
'422': 'Unprocessable Entity',
'423': 'Locked',
'424': 'Failed Dependency',
'425': 'Unordered Collection',
'426': 'Upgrade Required',
'428': 'Precondition Required',
'429': 'Too Many Requests',
'431': 'Request Header Fields Too Large',
'451': 'Unavailable For Legal Reasons',
'500': 'Internal Server Error',
'501': 'Not Implemented',
'502': 'Bad Gateway',
'503': 'Service Unavailable',
'504': 'Gateway Timeout',
'505': 'HTTP Version Not Supported',
'506': 'Variant Also Negotiates',
'507': 'Insufficient Storage',
'508': 'Loop Detected',
'509': 'Bandwidth Limit Exceeded',
'510': 'Not Extended',
'511': 'Network Authentication Required'


### (4) ajax提交方式
- GET 数据在open提交
      载体：url

- POST 数据在send提交
	  载体：请求头(setRequestHeader)

## 2. Ajax

原生编写ajax.js

``` javascript
<script>
	function ajax(json) {
		// url, data, type, success, error, time, loading, complete
		//路径，数据，方式，成功回调函数，失败回调函数，超时时间，等待动画，完成后的回调函数
		// data数据格式为json

		json = json || {};
		if(!json.url) {
			alert('url is null!');
			return;
		}

		json.data = json.data || {};
		json.type = json.type || 'get'; // 默认提交方式为GET
		json.time = json.time || 3000;  // 默认超时时间为3000ms

		var timer = null;
		clearTimeout(timer);

		// 1. 获得ajax
		if(window.XMLHttpRequest) {  // 查看当前浏览器XMLHttpRequest是否是全局变量
			var oAjax = new XMLHttpRequest();
		} else {
			var oAjax = new ActiveXObject('Microsoft.XMLHTTP');  // IE6，传入微软参数
		}

		switch(json.type.toLowerCase()) {
			case 'get':
				// 2. 打开地址
				oAjax.open('GET', json.url + '?' + jsonToURL(json.data), true);  // 提交方式(大写)，url，是否异步
				// 3. 发送数据
				oAjax.send();
				break;
			case 'post':
				// 2. 打开地址
				oAjax.open('POST', json.url, true);  // 提交方式(大写)，url，是否异步
				oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');  // 设置请求头
				// 3. 发送数据
				oAjax.send(jsonToURL(json.data));

		}

		json.loading && json.loading();  // 执行等待动画

		// 4. 接收数据
		oAjax.onreadystatechange = function() {  // 监控状态
			if(oAjax.readyState == 4) {
				json.complete && json.complete();
				if(oAjax.status >= 200 && oAjax.status < 300 || oAjax.status == 304) {
					json.success && json.success(oAjax.responseText);  // 执行成功的回调函数，responseText为响应内容
				} else {
					json.error && json.error(oAjax.status);  // 执行失败的回调函数
				}
				clearTimeout(timer);
			}
		};

		// 网络超时时执行
		timer = null;
		timer = setTimeout(function() {
			console.log('请求超时');
			oAjax.onreadystatechange = null;
		}, json.time);

	}

	function jsonToUrl(json) {
		var arr = [];
		for(var name in json) {
			arr.push(name + '=' + json[name]);
		}
		return arr.join('&');
	}
</script>
```

## 3. Ajax服务器相关
- `oAjax.getAllResponseHeaders();`  获取ajax服务全部信息
- `oAjax.getResponseHeader('xxx');`  获取ajax服务器相关信息

## 4. Ajax2.0事件
- `oAjax.onload`  替代`oAjax.onreadystatechange`
- `oAjax.onerror`  发生错误(网络层级的错误才会触发)
- `oAjax.onprogress`  上传进度(ev.loaded/ev.total)
- `oAjax.onabort`  中断

## 5. 关于锚点hash

应用：刷新保留分页页码

> cookie只有4k左右，此处应用hash保留分页页码

``` css
<style>
	a{
	    display: block;
	    width: 50px;
	    height: 50px;
	    border:1px solid #000;
	    text-align: center;
	    line-height: 50px;
	    text-decoration: none;
	    float: left;
	    margin:10px;
	}
	a:hover{
	    background: #f60;
	    color: #fff;
	}
	a.active{
	    background: #f60;
	    color: #fff;
	}
</style>
```

``` html
	<a href="javascirpt:;" class="active">1</a>
	<a href="javascirpt:;">2</a>
	<a href="javascirpt:;">3</a>
	<a href="javascirpt:;">4</a>
	<a href="javascirpt:;">5</a>
```

``` javascript
<script>
	window.onload = function() {
		var aA = document.getElementsByTagName('a');
		var hash = window.location.hash;
		var index = hash.substring(1);
		if(hash) {
			tab(index-1);
		}

		for (var i = 0; i < aA.length; i++) {
			aA[i].index = i;
			aA[i].onclick = function() {
				var index = this.index;
				tab(index);
				window.location.hash = '#' + (this.index + 1);
			};
		}

		function tab(index) {
			for (var i = 0; i < aA.length; i++) {
				aA[i].className = '';
			}
			aA[index].className = 'active';
		}
	};
</script>
```

## 6. Ajax跨域
**同源策略：Ajax只能同域名下取数据**

### js跨域请求方式
- jsonp(json with padding)
- 修改document.domain跨子域
- window.name
- H5 window.postMessage(IE6 7不支持)
- CORS(跨域资源共享) 设置header: Access-Control-Allow-Origin
- nginx反向代理

[JavaScript跨域总结与解决办法](http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html)

跨浏览器的CORS
- 使用自定义的HTTP头部让浏览器与服务器进行沟通

```
<script>
	function createCORSRequest(method, url) {
		var xhr = new XMLHttpRequest();
		if('withCredentials' in xhr) {
			xhr.open(method, url, rue);
		} else if (typeof XDomainRequest != 'undefined') {  // IE
			xhr = new XDomainRequest();
			xhr.open(method, url);
		} else {
			xhr = null;
		}

		return xhr;
	}

	var request = createCORSRequest('get', 'http://xxx.xxx.com/page/');
	if(request) {
		request.onload = function() {
			console.log(request.responseText);
		};
		request.send();
	}
</script>
```

## 7. jsonp前导

> **jsonp原理**
动态创建script标签，利用script:src可以跨域的属性跨域

> **HTML里面所有带src属性的标签都可以跨域，如iframe，img，script等。**

**不需要服务器环境**

[jsonp接口测试网址](www.asilu.com)

## 8. jsonp
原生编写jsonp.js

``` javascript
<script>

	function jsonp(json) {
		// url, data, cbName, success
		// 路径，参数，回调函数名字，回调函数

		json = json || {};
		if(!json.url) {
			return;
		}
		json.data = json.data || {};
		json.cbName = json.cbName || 'cb';  // 默认回调函数名字为cb，回调函数名一般为cb或callback

		var fnNmae = 'jsonp_' + Math.random();
		fnName = fnName.replace('.', '');  // 定义随机函数名，但名内不能包含.

		// 全局函数防止与外部函数jsonp()重名
		window[fnName] = function(json2) {
			json.success && json.success(json2);
			oHead.removeChild(oS);
		};

		json.data[json.cbName] = fnName;
		var arr = [];
		for(var name in json.data) {
			arr.push(name + '=' + json.data[name]);
		}

		var oS = document.createElement('script');  // **动态创建script标签
		var oHead = document.getElementsByTagName('head')[0];
		oS.src = json.url + '?' + arr.join('&');  // 动态script的src属性为jsonp的路径
		oHead.appendChild(oS);  // 插入到<head>标签最末
	}

</script>
```

## 9. 跨浏览器的CORS

```
<script>
	
</script>
```

---

#blog17(jQuery上)

---

## 1. jQuery && js

|     	 | jQuery 		     | 		js      			 |
| :--:   | 	   :----: 	     | 	 :----: 				 |
| onload |$(function() {});  |window.onload=function(){};|
|获取元素|$('div');  		 |document.getElementsByTagName('div');|
| 事件 	 |obj.click(fn); 	 | obj.onclick=fn;			 |
| this   |$(this)            |this			 			 |
| 索引   |$(this).index()    |aDiv[i].index=i;...  	     |
|操作属性|(1)获取attr(name)   |(1). 	     			 |
|        |(2)设置attr(name, value) |(2)[]	     		 |
|        |      		 	 |(3)getAttribute()/setAttribute()|

## 2. jQuery效果
- `.hide()`  隐藏
- `.show()`  显示
- `.slideDown()`  下滑
- `.slideUp()`  上滑
- `.fadeIn()`   淡入
- `.fadeOut()`  淡出

> 参数：time时间，easing运动方式，fn回调函数

- `.animate(params, [speed], [easing], fn)`

eg: `.animate({width: '100px', opacity: 1}, 'slow', {duration: 1000, easing: 'linear', complete: function(){...}})`

> animate()函数记得先清除定时器
`$('ul').stop().animate(...);`

## 3. jQuery选择器
### (1) 伪类选择器
- `$('li:first')`  第一个
- `$('li:last')`   最后一个
- `$('li:eq(n)')`  第**n+1**个
- `$('li:odd')`    第**奇数**个  (tips:记忆odd字母个数为奇数个)
- `$('li:even')`   第**偶数**个  (tips:记忆even字母个数为偶数个)
- `$('li:contains(xxx)')`  包含文本xxx的li标签
- `$('li:has(p)')`  包含p标签的li标签

### (2) 属性选择器
- `$('input[type==password]')`  属性type为password的input标签

## 4. jQuery操作css属性
- 获取 `.css('name')`;

- 设置
  - 单一样式  `.css('name', 'value')`
  - 多个样式  `.css({'name': 'value', 'name2': 'value2'})`
  eg: `.css('background-color': 'red')`或者`.css('backgroundColor': 'red')`

## 5. jQuery操作内容
- 非表单
  - 获取  `.html()`    // innnerHTML
  - 设置  `.html('xxx')`

- 表单
  - 获取  `.val()`     // value
  - 设置  `.val('xxx')`

- 文本
  - 获取  `.text()`
  - 设置  `.text('xxx')`


## 6. jQuery操作类名
- 添加  `.addClass('xxx')`
- 删除  `.removeClass('xxx')`
- 添加/删除  `.toggleClass('xxx')`

## 7. jQuery操作属性
- 获取  `.attr(name)`

- 设置
  - 单一属性  `.attr('name', 'value')`
  - 多个属性  `.attr({'name': 'value', 'name2': 'value2'})`

## 8. jQuery DOM
### (1) 创建元素
`$('<div>text</div>')`

### (2) 添加元素
- `.append()`
  parent.append(child);  父级添加子级至末尾
- `.appendTo`
  child.appendTo(parent);  子级追加至父级末尾


- `.prepend()`
  parent.prepend(child);  父级添加子级至最前
- `.prependTo()`
  child.prependTo(parent);  子级追加至父级最前


- `.before()`
  sib1.before(sib2);  sib2添加至同级sib1前面
- `.after()`
  sib1.after(sib2);   sib2添加至同级sib1后面


- `.insertBefore()`
  sib1.insertBefore(sib2);  sib1添加至同级sib2前面
- `.insertAfter()`
  sib1.insertAfter(sib2);   sib1添加至同级sib2后面


- `.wrap()`
  child.wrap(parent);  子元素被父元素包裹
- `.unwrap()`
  child.unwrap();  子元素移出上级父元素

### (3) 删除元素
- `.remove()`
  obj.remove();  删除obj节点

- `.empty()`
  obj.empty();   删除obj内所有子节点

- `.detach()`
  - $('p').detach();  删除所有p标签及其中内容
  - $('p').detach('.hello');  删除所有类为hello的p标签及其中内容

## 9. jQuery事件
**jQuery中所有事件都是绑定的**

- `.ready()`  DOM完全加载时执行的函数

- `.change()`
- `.click()`
- `.dblclick()`  双击  注意是**dbl**
- `.contextmenu()`  右击
- `.hover()`
  hover(over, out)  可以绑定两个方法

```
<script>
	obj.hover(function() {
		// 移入
	}, function() {
		// 移出
	})
</script>

```
- `.mouseover()`
- `.mouseout()`
- `.mousedown()`
- `.mouseup()`
- `.mousewheel`  鼠标滚轮  **jQuery没有封装这个函数，需用on事件绑定**
- `.keydown()`
- `.keypress()`
- `.keyup()`

> **最好不用jQuery封装的事件，都用on事件绑定**

- `.on()`  绑定
- `.off()`  解绑

- `.bind()`  绑定
- `.unbind()`  解绑

// live() die()     jQuery 1.7+被删除

[jQuery事件绑定on()、bind()与delegate() 方法详解](http://www.jb51.net/article/67166.htm)

### 事件相关
- `return false;`  阻止默认事件、阻止冒泡
- `ev.preventDefault();`  阻止默认事件
- `ev.stopPropagation();`  阻止冒泡

### 事件委托
- 第一种方法
`.on(events, selector, callback)`

```
<script>
	// $('table td').on('hover', function() {
	// 	$(this).toggleClass('active');
	// })

    // =>

	$('table').on('hover', 'td', function() {
		#(this).toggleClass('active');
	})
</script>
```

- 第二种方法
`.delegate()`

```
<script>
	$('table').delegate('td', 'hover', function() {
		$(this).toggleClass('active');
	})
</script>
```

---

#blog18(jQuery下)

---

## 1. jQuery获取物体信息
### js
- obj.offsetWidth
- obj.offsetHeight
- obj.offsetLeft
- obj.offsetTop

- obj.parentNode  结构父级  根：document
- obj.offsetParent  定位父级  根：body

**js处理小数较弱，取出时取整Math.round()**

### jQuery(只封装了以下方法)
- `obj.width();`  纯width
- `obj.height();`  纯height

- `obj.outerWidth();`  盒子模型的width  (width+padding+border)  =>  offsetWidth
- `obj.outerHeight();`  盒子模型的height  (height+padding+border)  => offsetHeight

- `obj.position().left;`  距离定位父级left值  (不包括margin)   => offsetLeft
- `obj.position().top;`   距离定位父级top值   (不包括margin)   => offsetTop

- `obj.offset().left;`  距离定位父级left值  (包括margin)
- `obj.offset().top;`  距离定位父级top值  (包括margin)

- `obj.scrollTop();`  元素相对滚动条顶部的偏移
- `obj.scrollLeft();`  元素相对滚动条左侧的偏移

父级
- `obj.parent()`  结构父级  根：document    => parentNode
- `obj.parents()`  返回被选元素的所有祖先元素，直到`<html>`
- `obj.offsetParent()`  定位父级  根：body  => offsetParent

子级
- `obj.children()`  返回被选元素的所有直接子元素
- `obj.find()`      返回被选元素的后代元素，一路向下直到最后一个后代

## 2. jQuery筛选
### (1) 过滤
- `.eq(index)`
  - index >= 0   正向选取(0代表第一个，1代表第二个)
  - index < 0    反向选取(-1代表倒数第一个)

- `.first()`
- `.last()`
- `.hasClass(className)`

### (2) 查找
- `.find(tagName/className/id)`  eg: `oBox.find('ol li');`

## 3. jQuery <=> js
### (1) 原生js转jQuery对象
**$() 包裹**
this -> $(this)
document -> $(document)

```
<script>
	var oDiv = document.getElementById('div1');
	$(oDiv).html('xxx');
</script>
```

### (2) jQuery转原生js对象
**[] / get()**

1. `$('div')[0].innerHTML = 'xxx';`
2. `$('div').get(0).innerHTML = 'xxx;`

## 4. jQuery链式运动
`obj.css(...).html(...).attr(...).click();`

## 5. jQuery循环
`obj.each(function(){...});`

[JS中的forEach、$.each、map方法推荐](http://www.jb51.net/article/81955.htm)

eg:
```
<script>
	$('div').each(function(index, element) {  // 索引，当前元素
		console.log($(element).html);  // **element是原生对象，需转成jq对象
		$(this);  // 当前对象
	});
</script>
```
## 6. jQuery工具
- `$.trim(str);`  去掉字符串起始和结尾的空格
- `$.browser.version;`  浏览器版本

eg:
```
<script>
	if($.browse.version.substring(0, 1) == '6') {
		// IE6 code here
	}
</script>
```

## 7. jQuery Ajax
`$.ajax({...});`

- **type: 'get/post'**

```
<script>
	$.ajax({
		url: URL,
		data: {},
		type: 'get',
		error: fn,
		complete: fn,
		time: 3000;
		success: function(str) {
			console.log(str);
		}
	})
</script>
```

## 8. jQuery jsonp
`$.ajax({...});`

- **dataType: 'jsonp'**
- **cbName: 'callback/cb'**

```
<script>
	$.ajax({
		url: URL,
		data: {},
		dataType: 'jsonp',
		cbName: 'callback',
		success: function(json) {
			console.log(json);
		}
	});
</script>
```

## 9. jQuery插件
### 写插件
$: jq
fn: 帮助

**jq里面除了插件里的this以外，其他都是原生的js**

[jquery的$.extend和$.fn.extend作用及区别](http://blog.sina.com.cn/s/blog_7c5d61f30101da1k.html)

### 一个插件
`$.fn.插件名 = fn;`

```
<script>
	$.fn.插件名 = function() {
		this.css('name', 'value');  // 插件中的this不用加$
	}

	$('div').插件名();
</script>
```

### 一组插件
`$.fn.extend(...);`

> 插件调用不能用链式

```
<script>
	$.fn.extend({
		插件名1: function() {
			this.css('name', 'value');
		},
		插件名2: function() {
			this.css('name', 'value');
		}
	})

	// 插件调用不能用链式
	$('div').插件名1();
	$('div').插件名2();
</script>
```

---

#blog19(正则)

---

## 1. 正则表达式
**用处：处理字符串**

### RegExp对象

`var reg = new RegExp('字符串', [选项]);`  可选选项

选项：
- `i` ignore  忽略大小写
- `g` global  全局匹配
- `m` multi-line   多行匹配

> 字符串为正则表达式时，不能用选项，直接在正则表达式`//`后增加选项

## 2. 正则定义的多种方法
1. `var a = 'aaa';`
   `var reg = new RegExp(a, 'g');`    正则可以使用变量形式
2. `var reg = /\d+/g;`  正则不可以使用变量形式
3. `str.replace(/\d/g, '');`

## 3. 正则校验
`reg.test(str);`
- true -> 校验通过
- false -> 校验不通过

## 4. 正则使用的字符串相关方法
- `str.search('w')`  查找w
  - 成功  返回w的下标
  - 失败  返回-1
- `str.match('w')`   匹配w  **返回值类型：数组(object)**
  - 成功  返回w
  - 失败  返回null
- `str.replace('xxx', 'yyy')`  被替换内容，替换内容

> 
1. **修改第一个被替换内容**
2. **替换不修改原字符串, 需重新声明**
3. **第二个参数可为一个方法**
4. **replace可以连用**

示例
```
<script>
	var str = 'aaa';
	var str2 = str.replace('a', 'b');

	console.log(str);  // aaa
	console.log(str2);  // baa
</script>
```

```
<script>
	str.replace('xxx', function(s) {
		console.log(s);  // **参数s为被替换字符  数据类型：string
		var star = '';
		for (var i = 0; i < s.length; i++) {
			star += '*';
		}
		return star;  // 返回替换内容
	})
</script>
```
- stringObject.replace(regexp/substr,replacement)
  - replacement `$1、$2、...、$99` -> 与 regexp 中的第 1 到第 99 个子表达式(小括号)相匹配的文本
  - replacement `$&` -> 与regexp相匹配的子串
  - replacement `$`\`-> 位于匹配子串左侧的文本。
  - replacement `$'` -> 位于匹配子串右侧的文本

``` javascript

function getQueryObject(url) {
	url = url == null ? window.location.href : url;
	var search = url.substring(url.lastIndexOf("?") + 1);
	var obj = {};
	var reg = /([^?&=]+)=([^?&=]*)/g;

	// 
	search.replace(reg, function(rs, $1, $2) {
		var name = decodeURIComponent($1);
		var val = decodeURIComponent($2);
		val = String(val);
		obj[name] = val;
		return rs;
	});
	return obj;
}
```

## 5. 特殊字符
- `.`  匹配**任何**单字符(除换行符\n)
- `^`  匹配开始位置
  - 不选m  匹配字符串的开始位置
  - 选m    识别字符串的换行，并匹配字符串每行的开始位置
- `$`  匹配结束位置
- `()` 标记子表达式
- `[]` 标记元字符表达式
- `{}` 标记限定符表达式

## 6. 元字符(一个字符)
- `[abc]`  字符集合 ->  /a|b|c/
- `[^abc]` 负值字符集合 -> 除了abc
- `[0-9]`  字符范围 -> /0|1|2|3|4|5|6|7|8|9/  eg: `[1-29]` -> `[1-2]或者[1-9]`
- `[^0-9]` 负值字符范围 -> 非数字

## 7. 限定符
- `{n}`  匹配n个
- `{n,}` 最少匹配n个
- `{,m}` 最多匹配m个
- `{n,m}`最少匹配n个，最多匹配m个  n,m为非负整数(n<=m)

- `*`  匹配{0,}  eg: `'zo*'` -> `'z'`及`'zo'`、`'zooooo'`
- `+`  匹配{1,}  eg: `'zo+'` -> `'zo'`及`'zoo'`、`'zooooo'`
- `?`  匹配{0,1} eg: `'do(es)?'` -> `'do'`或`'does'`

## 8. 转义字符
- `\\`  \   eg: `\\\\\`  -> `\\`  会报错
- `\n`         换行符
- `\r` 		   回车符
- `\f`         换页符
- `\d` digital 数字(**不认识小数**)  [0-9]
- `\w` word    单词(**包括下划线**)  [A-Za-z0-9_]
- `\s` space   空白字符

- `\D` 		   非数字                [^0-9]
- `\W`	       非单词   			 [^A-Za-z0-9_]
- `\S`         非空白字符

var reg = /\d/;  -> 选项  /\d/g;  ->  匹配一次或多次  /\d+/g

## 9.单词边界
**找确定单词时在正则中加上单词边界 \b**

**在正则中需转义为 `\\b`**

`var reg = new RegExp('\\bAAAA\b');`

## 10. 简单示例
- `/\d+/`   一串数字
- `/\d\d+/` 最少2个数字
- `/.+/`    任意多个
- `/.*/`    可有可无


---

#blog20(正则应用)

---

## 1. 校验座机号码
示例：
021-8888888
0791-88888888

- 区号-  ->  `(0[1-9]\d{1,2}-)?`    3/4位数字  首位数字为0、第二位非0  区号-可有可无
- 号码   ->  `[1-9]\d{6,7}`         7/8位数字  首位数字非0

正则：
`/^(0[1-9]\d{1,2}-)?[1-9]\d{6,7}$/`

## 2. 校验邮箱
示例：
wangchloe@yeah.net
123123123@163.com.cn
用户名 + @ + 域名 +      . + 后缀
`\w+      @   [a-z0-9-]+ (\.[a-z]{2,8}){1,2}

正则：
`/^\w+@[a-z0-9-]+(\.[a-z]{2,8}){1,2}$/`

## 3. 校验年龄(18-100)
18-19    20-99     100
1[89] |  [2-9]\d | 100

正则：
/^1[89]|[2-9]\d|100$/
> ^优先级比|高，会先执行^1[89]和100$，并且^与超过两个|同时出现就会错乱，需要加括号包裹多个条件，提升优先级

`/^([89]|[2-9]\d|100)$/`

## 4. 仿trim()去除首尾空格
- 去首空格  `^\s+`
- 去尾空格  `\s+$`

去掉开头为空格或者空格为结尾

正则：
`/^\s+|\s+$/`

## 5. 校验名字
`str.fromCharCode('0x4e00')`
第一个中文 0x4e00  一
最后一个中文  0x9fa5  龥(yu)

- unicode编码：统一编码 utf-8 utf-16 utf-32
以\u开头  \u4e00(一) ~ \u9fa5(龥)
- GB2312编码

两个到七个汉字
正则：
`/^[\u4e00-\u9fa5]{2,7}$/`

## 6. 首字母大写
```
<script>
	var str = 'this is wangchloe';

	var str2 = str.replace(/\w+/g, function(s) {
		return s.charAt(0).toUpperCase() + s.substring(1);
	});

	console.log(str2);  // This is wangchloe
</script>
```

## 7. 过滤标签
```
<script>
	var str = oBox.innerHTML;
	var str2 = str.replace(/<[^>]+>/g, '');

	console.log(str2);
</script>
```

## 8. 正则getByClass等方法

```
<script>
	function getByClass(oParent, sClass) {  // oParent为从哪个父级下面查找类为sClass的元素
		if(oParent.getElementsByClassName) {  // IE8- -> undefined  高级浏览器 -> function
 			return oParent.getElementsByClassName(sClass);  // 高级浏览器
		} else {	// IE8
			var arr = [];
			var aEle = oParent.getElementsByTagName('*');
			var reg = new RegExp('\\b' + sClass + '\\b');
			for (var i = 0; i < aEle.length; i++) {
				if(reg.test(aEle[i].className)) {
					arr.push(aEle[i]);
				}
			}
			return arr;
		}
	}

	function hasClass(obj, sClass) {
		var reg = new RegExp('\\b' + sClass + '\\b');
		return reg.test(obj.className);
	}

	function addClass(obj, sClass) {
		if(obj.className) {
			if(!hasClass(obj, sClass)) {
				obj.className += ' ' + sClass;
			}
		} else {
			obj.className = sClass;
		}
	}

	function removeClass(obj, sClass) {
		var reg = new RegExp('\\b' + sClass + '\\b');
		if(hasClass(obj, sClass)) {
			// obj.className = obj.className.replace(reg, '').replace(/^\s+/g, '');
			obj.className = obj.className.replace(reg, '').replace(/\s+/g, ' ').replace(/^\s+|\s+$/, '');
		}
	}
</script>
```

---

#blog21(性能优化)

---

二话不说！先三炷香膜拜下**YaHoo军规**。

![YaHoo军规](https://img.aotu.io/wangcainuan/2016-03-16-optimization/%E9%9B%85%E8%99%8E35%E6%9D%A1%E5%86%9B%E8%A7%84.jpg)


以下方便你们ctrl+c、ctrl+v

- 网页内容
  - 减少 http请求次数
  - 减少 DNS查询次数
  - 避免页面跳转
  - 缓存 Ajax
  - 延迟加载
  - 提前加载
  - 减少 DOM元素数量
  - 根据域名划分内容
  - 减少iframe数量
  - 避免 404
- 服务器
  - 使用CDN(内容分发网络)
  - 添加Expires或Cache-Control报文头
  - Gzip压缩传输文件
  - 配置ETags
  - 尽早flush(刷新输出)缓冲
  - 使用GET来完成AJAX请求
  - 避免空的图片src
- Cookie
  - 减少Cookie大小
  - 页面内容使用无cookie域名
- CSS
  - 将样式表置顶
  - 避免使用CSS表达式(Expression)
  - 用<link>代替@import
  - 避免使用Filters(滤镜)
- JavaScript
  - 把脚本置于页面底部
  - 使用外部JavaScript和CSS
  - 精简JavaScript和CSS
  - 去除重复脚本
  - 减少DOM访问
  - 开发智能事件处理程序
- 图片
  - 优化图像
  - 优化CSS Spirite
  - 不要在HTML中缩放图片
  - favicon.ico要小而且可缓存
- 移动客户端
  - 保持单个内容小于25KB
  - 打包组建成复合文档


>再来一张私藏的移动端性能优化

![移动H5性能优化指南.jpeg](http://upload-images.jianshu.io/upload_images/2125655-200c9922b07ce645.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


> 以下是正文

## 1. 性能优化
项目讲求：
1. 稳定性
2. 可维护性
3. 性能优化

性能分类：
- 执行性能
- 网络性能

## 2. 重排 && 重绘

[简单-页面性能优化](http://www.jianshu.com/p/3802ac513bc5)

### (1) 重排(reflow)
即重新生成布局，**重排必然导致重绘**。

会触发重排的属性：

- 盒子模型相关属性
  - width
  - height
  - padding
  - margin
  - display
  - border-width
  - border
  - min-height
- 定位属性及浮动
  - top
  - bottom
  - left
  - right
  - position
  - float
  - clear
- 改变节点内部文字结构
  - text-align
  - overflow-y
  - font-weight
  - overflow
  - font-family
  - line-height
  - vertival-align
  - white-space
  - font-size

### (2) 重绘
即重新绘制，**重绘不一定需要重排**。

会触发重绘的属性：

- color
- border-style
- border-radius
- visibility
- text-decoration
- background
- background-image
- background-position
- background-repeat
- background-size
- outline-color
- outline
- outline-style
- outline-width
- box-shadow

## 3. 图层

浏览器layout和paint是在每一个图层上进行的，当有一个元素经常变化，为了减少这个元素对页面的影响，我们可以为这个元素创建一个单独的图层，来提供页面的性能。

- 什么时候会创建图层
  - 3D或透视变换（perspective transform）CSS属性（例如translateZ(0)/translate3d(0,0,0)）
  - 使用加速视频解码的`<video>`节点
  - 拥有3D（WebGL）上下文或加速的2D上下文的`<canvas>`节点
  - 混合插件（如Flash）
  - 对自己的opacity做CSS动画或使用一个动画webkit变换的元素
  - 拥有加速CSS过滤器的元素
  - 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）
  - 元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）
  - position为fixed也会创建图层，而absolute则不会

利用GPU来加速页面渲染(硬件加速)

- 触发CSS硬件加速
  - translate3d(0,0,0)
  - rotate3d(0,0,0,0)
  - scale3d(0,0,0)
  - translateZ(0)【可能】

## 4. 执行性能优化
建议：
1. 不用的东西删除
2. 尽量不用全局变量(命名冲突，耗资源)
3. 能用系统自带的一定不用自己写的(eg:getByClass)
4. 尽量使用正则操作字符串

5. DOM操作耗性能，尽量减少DOM操作
6. 属性用的越多，性能越低
7. css耗性能属性：expression、filter、border-radius、box-shadow、gradients

> 1. Math.floor比parseInt快
2. 变量性能消耗：属性 > 全局变量 > 局部变量

## 5. 网络性能优化

### 查看网络性能 F12 -> network
- Status 状态码
- Type   资源类型
  - 主类型/次类型
  - text/html
  - text/css
  - image/png/gif
- Initiator  发起人
- Size   资源大小
- Time   请求耗时
- Timeline  时间轴
  - Queueing  排队
  - Stalled   停滞
  - Request sent  请求发送
  - Waiting   等待
  - Content Download  内容下载

#### 工具
FF -> firebug -> yslow(网站评分)
Chrome -> Audits(查看网络性能)

### 网络性能提升方法
1. 减少http请求 -> 合并
  - js -> 合并
  - css -> 合并，避免`@import`方式引入css文件
  - 图片 -> css sprites

2. http请求越小越好 -> 压缩
  - js -> 压缩
  - css -> 压缩
    - css值缩写(margin,border等)
    - 省略值为0的单位
    - 色值用最短的表示
  - 图片 -> 压缩
  工具
    - [在线工具 —— 开源中国社区](在http://tool.oschina.net/)
    - [HTML格式化 、HTML压缩- 站长工具](http://www.sojson.com/jshtml.html)
    - 前端自动化工具

3. 图片延迟加载
4. CDN(Content Delivery Network, 内容分发网络)加速
5. 加载顺序
  - 阻塞加载(同步加载)
    js
    **解决**：引用其他网站的js放在body最后
  - 非阻塞加载(异步加载，并行加载)
    css、html、图片

## 6. 垃圾回收 GC(Gabage Collection)
- js中的垃圾回收：(宿主环境)
浏览器会自动回收垃圾

- 底层语言不会自动回收垃圾

垃圾的评判标准：**生存周期**

生存周期：作用域
1. 全局变量：生存周期长，直到浏览器关闭时清除  **占资源**
2. 局部变量：生存周期短，方法调用完即清除
3. 闭包(子函数可以使用父函数的全局变量)
  子函数若没有释放，整条作用域链上的局部变量都会保留
  作用域链：从内一级一级往外找，知道全局

``` javascript
<script>
	// 作用域链
	function show1() {
		var a = 12;
		function show2() {
			var b = 1;
			function show3() {
				var c = 2;
				document.onclick = function() {
					var d = 3;
					alert(a);
				}
			}
			show3();
		}
		show2();
	}

	show1();
</script>
```

## 7. 递归

函数自己调用自己
核心思想：化大为小，逐一解决

> **斐波那契数列(Fibonacci sequence)**

> 以递归的方法定义：
F0=0，F1=1，Fn=F(n-1)+F(n-2)（n>=2，n∈N*）

**经典问题：兔子问题**

有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总对数为多少？

**分析**：
假设将兔子分为小、中、大三种。
兔子从出生后每三个月就生出一对兔子，那么我们假定第一个月为小兔子，第二个月为中兔子，第三个月之后就为老兔子(老兔子每过三个月还会再生的)。

那么第一个月分别有1、0、0，第二个月分别为0、1、0，第三个月分别为1、0、1，第四个月分别为1、1、1，第五个月分别为2、1、2，第六个月分别为3、2、3，第七个月分别为5、3、5……

兔子总对数分别为：1、1、2、3、5、8、13……

找出规律即得出以下代码


``` javascript
<script>
	function fn(n) {  // n为当前月份
        var arr = [];
		if(n <= 2) {  // 前两个月只有一对兔子
			return 1;
		} else {
			if(arr[n]) {
				return arr[n];
			} else {
				arr[n] = fn(n-1) + fn(n-2);  // 第三个月开始返回前两月之和
				return arr[n];  // 返回截止当前月份的总对数
			}
		}
	}
</script>
```

---

#blog22(面向对象)

---

## 1. 面向对象

### (1) 对象组成
1. **属性(变量)**
2. **方法(函数)**

### (2) 面向对象特征
1. **封装**
2. **继承**
    子级可以继承父级的一切东西
3. **多态**
    子级可以继承多个父级

### (3) 对象相关方法
- instanceof  判断是否属于该类型
  - true 属于
  - false 不属于
  eg: `arr instanceof Array;`  // true

- constructor  查找对象的父级
  eg: `arr.constructor == Array;`  // true

> **JSON不是一个类型，其父类型就是Object**
`json.constructor == JSON;`  // false
`json.constructor == Object;`  // true

#### 执念

```
<script>
	var arr = [1, 2];
	var json = {};
	var oDate = new Date();

	console.log(arr.constructor == Array); // true
	console.log(json.constructor == JSON); // false
	console.log(json.constructor == Object); // true

	console.log(typeof oDate); // object
	console.log(oDate instanceof Date); // true
	console.log(typeof Date); // function
	console.log(Date instanceof Function); // true
	console.log(oDate instanceof Function); // false

	console.log(typeof Image); // function
	console.log(Image instanceof Function); // true

	// 开始划重点
	console.log(Function instanceof Object); // true
	console.log(Object instanceof Function); // true
	console.log(Object instanceof Object); // true
	console.log(Function instanceof Function); // true

	console.log(arr instanceof Array); // true
	console.log(Array instanceof Object); // true
	console.log(arr instanceof Object); // *true

	console.log(arr instanceof Array); // true
	console.log(Array instanceof Function); // true
	console.log(arr instanceof Function); // *false

	Object.prototype.run = 7;
	var run = 5;
	var arr2 = [];
	console.log(run); // 5
	console.log(typeof run); // number
	console.log(run instanceof Number); // false
	console.log(Number instanceof Object); // true
	console.log(Boolean instanceof Object); // true
	console.log(run instanceof Object); // false
	console.log(arr2.run); // 7
</script>
```

## 2. 引用类型
- Object类型
- Array类型
- Date类型
- RegExp类型
- Function类型

- 基本包装类型
  - Boolean类型
  - String类型
- 内置对象
  - Global对象
  - Math对象

### Array.sum实现原理

``` javascript
<script>
	var arr = [1, 2, 3];

	// sum的实现原理
	Array.prototype.sum = function() {
		var sum = 0;
		for(var i = 0; i < this.length; i++) {
			sum += this[i];
		}
		return sum;
	}

	console.log(arr.sum());
</script>
```

### Array.forEach实现原理

```
<script>
	// forEach实现原理
	if (!Array.prototype.forEach) {
		Array.prototype.forEach = function(fn) {
			for (var i = 0; i < this.length; i++) {
				fn(this[i], i, this);
			}
		};
	}

	["a", "b", "c"].forEach(function(value, index, array) {
		assert(value, "Is in position " + index + " out of " + (array.length - 1));
	});
</script>
```

### Array.every实现原理

```
<script>
	if (Array.prototype.every === undefined) {
		Array.prototype.every = function(fun) {
			//遍历当前数组中每个元素
			for (var i = 0; i < this.length; i++) {
				if (this[i] !== undefined) {
					//调用fun,依次传入当前元素值,位置i,当前数组作为参数  ，将返回值，保存在变量r中
					var r = fun(this[i], i, this);
					if (r == false) { //如果r为false
						return false; //返回false
					}
				}
			} //(遍历结束)
			return true; //返回true
		}
	}
</script>
```

### Array.some原理

```
<script>
	if (Array.prototype.some === undefined) {
		Array.prototype.some = function(fun) {
			for (var i = 0; i < this.length; i++) {
				if (this[i] !== unefined) {
					var r = fun(this[i], i, this);
					if (r == true) {
						return true;
					}
				}
			}
			return false;
		}
	}
</script>
```

### Array.map原理

```
<script>
	if (Array.prototype.map === undefined) {
		Array.prototype.map = function(fun) {
			//创建空数组: newArr
			var newArr = [];
			//遍历当前数组中每个元素
			for (var i = 0; i < this.length; i++) {
				//如果当前元素不是undefined
				if (this[i] !== undefined) { //判断稀疏数组
					//调用fun传入当前元素值，位置i，当前数组，将结果保存在r中
					//将newArr的i位置赋值为r
					var r = fun(this[i], i, this);
					newArr[i] = r;
				}
			} //(遍历结束)
			return newArr; //返回newArr
		}
	}
</script>
```

### Array.reduce原理

- 计算数组元素相加后的总和

```
<script>
	if (Array.prototype.reduce === undefined) {
		Array.prototype.reduce = function(fun, base) {
			base === undefined && (base = 0);
			for (var i = 0; i < this.length; i++) {
				if (this[i] !== undefined) {
					base = fun(base, this[i], i, this);
				}
			}
			return base;
		}
	}
</script>
```

### Function.bind原理

```
<script>
	if (Function.prototype.bind === undefined) {
		Function.prototype.bind = function(obj /*，参数列表*/ ) {
			var fun = this; //留住this
			//*****将类数组对象，转化为普通数组
			var args = Array.prototype.slice.call(arguments, 1);
			//args保存的就是提前绑定的参数列表
			/*function slice(1){
			   var sub=[];
			   for(var i=0;i<length;i++){
			    sub.push(arguments[i]);
			   }
			   return sub;
			}*/
			return function() {
				//将后传入的参数值，转为普通数组      
				var innerArgs = Array.prototype.slice.call(arguments); //将之前绑定的参数值和新传入的参数值，拼接为完整参数之列表
				var allArgs = args.concat(innerArgs)
					//调用原始函数fun，替换this为obj，传入所有参数
				fun.apply(obj, allArgs);
			}
		}
	}
</script>
```

## 3. 创建对象前导
### (1) 关于new
1. 创建一个空对象，并赋值给this
2. 返回this

### (2) 关于this
当前方法属于谁，this就是谁

```
<script>
	// In web browsers, the window object is also the global object:
	console.log(this === window); // true
</script>
```

**this的优先级**：
1. new -> object
2. 定时器 -> window
3. 事件 -> 事件对象
4. 方法 -> 方法对象

> **多包一层时优先级失效**

哈哈，关于this的坑详见后面的坑集合！

```
<script>
	function show() {
		console.log(this);
	}

	var arr = [1, 2];
	arr.show = show;

	document.onclick = arr.show; // 点击时 document
	new arr.show(); // 1. object
	new show(); // 2. object
	new document.onclick(); // 3. object

	setTimeout(show, 1000); // 9. window
	setTimeout(arr.show, 1000); // 10. window

	setTimeout(new arr.show, 1000); // 4. object **在上两个行执行前先弹出

	var oDate = new Date();
	oDate.show = show;
	document.show = show;
	document.onclick = show;
	setTimeout(function() { // setTimeout多包一层优先级失效
		oDate.show(); // 5. oDate时间
		new oDate.show(); // 6. object
		document.show(); // 7. document
		document.onclick(); // 8. document
	}, 100);
</script>
```

#### 强制改变this指向
- call
  - `fn.call(a);`  改变this指向，指向a
  - `fn.call(a, p1, p2);`  改变this指向并传参p1, p2
- apply
  - `fn.apply(a, [p1, p2]);`  改变this指向并传入参数数组
  - `fn.apply(a, arguments);`  改变this指向并传入当前方法(非fn)的参数数组

---

#blog23(面向对象 中)

---

## 4. 创建对象

这里先提一下**23种设计模式**：

- 创建型模式(5种)
  - 工厂方法模式
  - 抽象工厂模式
  - 单例模式
  - 建造者模式
  - 原型模式

- 结构型模式(7种)
  - 适配器模式
  - 装饰器模式
  - 代理模式
  - 外观模式
  - 桥接模式
  - 组合模式
  - 享元模式

- 行为型模式(11种)
  - 策略模式
  - 模板方法模式
  - 观察者模式
  - 迭代子模式
  - 责任链模式
  - 命令模式
  - 备忘录模式
  - 状态模式
  - 访问者模式
  - 中介者模式
  - 解释器模式

### (1) 工厂模式

```
<script>
	function createObject(name, age) {
		// 1.原料
		var obj = new Object();  // 创建自定义对象

		// 2.加工
		// 属性
		obj.name = name;
		obj.age = age;
		// 方法
		obj.getName = function() {
			return this.name;
		}
		obj.getAge = function() {
			return this.age;
		}

		// 3.出厂
		return obj;
	}

	var p = createObject('x', 11);
	console.log(p.getName());
</script>
```

### (2) 单例模式
**需要重新指定父级**

> 这个例子有点问题，等我找到合适的补上，或者评论区留言给我。

```
<script>
	var person = {};

	// 加属性
	person.name = 'xxx';

	// 加方法
	person.getName = function() {
		return this.name;
	};
</script>
```


### (3) 构造函数模式

**构造函数函数名首字母大写** -> 区分普通函数

> 以这种方式定义的构造函数是定义在Global对象(浏览器中为window对象)中的。

```
<script>
	function CreateObject(name, age) {
		// 1.原料
		// var obj = new Object();  // 创建自定义对象

		// 2.加工
		// 属性
		// obj.name = name;
		// obj.age = age;
		this.name = name;
		this.age = age;

		// 方法
		// obj.getName = function() {
		// 	return this.name;
		// }
		// obj.getAge = function() {
		// 	return this.age;
		// }
		this.getName = function() {
			return this.name;
		}
		this.getAge = function() {
			return this.age;
		}

		// 3.出厂
		// return obj;
	}

	var p = new CreateObject('x', 11);  // 创建对象，并赋值给this
	console.log(p.getName());
	console.log(p.constructor == CreateObject); // true
	console.log(p instanceof Object); // true
	console.log(p instanceof CreateObject); // true
</script>
```

### (4) 原型模式

```
<script>
	function CreateObject() {

	}

	CreateObject.prototype.name = 'xxx';
	CreateObject.prototype.age = '11';
	CreateObject.prototype.getName = function() {
		return this.name;
	}

	var p = new CreateObject();
	console.log(p.getName());
	// 查找过程
	// 先在 p上查找有没有getName属性
	// 没有，再在p的原型上查找getName属性

	console.log(CreateObject.prototype.isPrototypeOf(p));  // true

	console.log(p.hasOwnProperty('name'));  // false  原型属性
	p.name = 'yyy';
	console.log(p.hasOwnProperty('name'));  // true  实例属性
	delete p.name;  // 删除p.name
	console.log(p.hasOwnProperty('name'));  // false  原型属性

	console.log('name' in  p);  // true
</script>
```

#### 重写prototype将导致实例的constructor转向

```
<script>
	function CreateObject() {

	}

	// CreateObject.prototype.name = 'xxx';
	// CreateObject.prototype.age = '11';
	// CreateObject.prototype.getName = function() {
	// 	return this.name;
	// }
	CreateObject.prototype = {
		// constructor: CreateObject,  // 可特意声明constructor指向 CreateObject
		name: 'xxx',
		age: '11',
		getName: function() {
			return this.name;
		}
	}

	var p = new CreateObject();
	console.log(p.getName());

	console.log(p instanceof CreateObject);  // true
	console.log(p instanceof Object);  // true
	console.log(p.constructor == CreateObject);  // false

	// 重写默认的prototype后，constructor不在指向CreateObject，而是指向Object
	console.log(p.constructor == Object);  // true
</script>
```

### (5) 构造+原型

原型模式的问题

```
<script>
	function CreateObject() {

	}

	CreateObject.prototype = {
		constructor: CreateObject,  // 可特意声明constructor指向 CreateObject
		name: 'xxx',
		age: '11',
		children: ['aaa', 'bbb'],
		getName: function() {
			return this.name;
		}
	}

	var p = new CreateObject();
	var p2 = new CreateObject();

	p.children.push('ccc');

	console.log(p.children); // 'aaa,bbb,ccc'
	console.log(p2.children); // 'aaa,bbb,ccc'
	console.log(p.children == p2.children);  // true
	// 尴尬了，p新增加的孩子同时增加到了p2上
</script>
```

改为 构造+原型

> 1. 构造定义实例属性
2. 原型定义方法及共享属性

```
<script>
	function CreateObject(name, age) {
			this.name = name;  // 实例属性
			this.age = age;  // 实例属性

			this.children = ['aaa', 'bbb'];  // 实例属性
	}

	CreateObject.prototype = {
		constructor: CreateObject,  // 共享属性
		getName: function() {  // 共享方法
			return this.name;
		}
	}

	var p = new CreateObject();
	var p2 = new CreateObject();

	p.children.push('ccc');

	console.log(p.children); // 'aaa,bbb,ccc'
	console.log(p2.children); // 'aaa,bbb'
	console.log(p.children == p2.children);  // false
	console.log(p.getName == p2.getName);  // true
</script>
```

## 5. 原型与原型链
### 关于原型
> 
1. 对象有属性**`_proto__`**(隐式原型)，指向该对象的构造函数的原型对象。**（不要忘记万物皆对象）**
2. 方法(也是对象)除了有属性**`__proto__`**，还有属性**`prototype`**，prototype指向该方法的原型对象。
3. 原型对象还有属性**`constructor`**，指向原构造函数。

### 关于原型链

- 只要创建一个新函数(CreateObject)，都会附带一个prototype属性，并指向函数的原型对象(CreateObject.prototype)。
  `CreateObject.prototype` -> `CreateObject.prototype`

- 所有原型对象(CreateObject.prototype)都附带一个constructor(构造函数)属性，并指向prototype属性所在函数的指针(CreateObject)。
  `CreateObject.prototype.constructor` -> `CreateObject`

- 调用构造函数创建的实例(p)，内部将包含指针_proto_，并指向构造函数的原型对象(CreateObject.prototype)。
  `p._proto_` -> `CreateObject.prototype`
  `CreateObject._proto_` -> `Function.prototype`
  `Function.prototype._proto_` -> `Object.prototype`
  `CreateObject.prototype._proto_` -> `Object.prototype`
  `Object.prototype._proto_` -> `null`

![_proto_ && prototype && constructor](http://images0.cnblogs.com/blog2015/683809/201508/201728184569708.jpg)

## 6. 原型应用
### (1) 数组arr.indexOf()兼容问题
*兼容：高级浏览器
IE8- -> 报错

兼容写法
```
<script>
	var arr = [1, 2, 3, 4];

	Array.prototype.indexOf = Array.prototype.indexOf || function(item) {  // 如果有indexOf()就用系统自带的
		// IE8-
		for (var i = 0; i < this.length; i++) {
			if(this[i] == item) {
				return i;
			}
		}

	}

	console.log(arr.indexOf(3));
</script>
```

### (2) 字符串str.trim()兼容问题
*兼容：高级浏览器
IE8- -> 报错

兼容写法
```
<script>
	var str = ' aaa ';

	String.prototype.indexOf = String.prototype.indexOf || function() {  // 如果有trim()就用系统自带的
		// IE8-
		return this.replace(/^\s+|\s+$/g, '');
	}

	console.log('去空格' + str.trim() + '去空格');
</script>
```

---

#blog24(面向对象 下)

---

## 7. 如何编写面向对象程序
1. 采用构造+原型，写一个构造函数
2. 把方法挂在原型上(不能有方法嵌套)
3. 把全局变量变成属性
4. 调整this

```
<script>
	// 1. 写一个构造函数
	function ToRed() {
		// 3. 全局变量变成属性
		this.oDiv = document.body.children[0];

		// document.onclick = this.fnClick;
		// 上句相当于
		// document.onclick = function() {
		// 	alert(this);	// document
		// 	this.oDiv.style.background = '#f00';	// 当前的this指向document，错误
		// }

		// 4. 调整this
		var _this = this;
		document.onclick = function() {
			_this.fnClick();
		}
	}

	// 2. 方法挂在原型上
	ToRed.prototype.fnClick = function() {
		this.oDiv.style.background = '#f00';
	}

	new ToRed();
</script>
```

## 8. 面向对象：继承
1. 属性的继承

  - `父级的构造函数.call(this, 参数1, 参数2, ...);`
  - `父级的构造函数.apply(this, arguments);`

2. 方法的继承

  - `子级.prototype = 父级.prototype;`  // 引用  子级新方法在此之前写会被清空
  问题：子级改了，父级也改了

  - 循环复制

```
<script>
	for(var name in 父级.prototype) {
		子级.prototype[name] = 父级.prototype[name];  // 循环复制父级的方法
	}
</script>
```
问题：`子级 instanceof 父级;`  // false

  - 组合继承：子级的原型对象指向父级的实例，子级的原型对象的构造函数再指向自己。 **推荐使用**

```
<script>
	子级.prototype = new 父级的构造函数();
	子级.prototype.constructor = 子级的构造函数;
</script>
```

### 实例：自动播放选项卡(继承)

``` css
<style>
	* {
		margin: 0;
		padding: 0;
	}
	#box button.active, #box2 button.active {
		background: #ff0;
	}
	#box div, #box2 div {
		display: none;
		width: 100px;
		height: 100px;
		font-size: 20px;
		border: 1px solid #ccc;
	}
	#box div.active, #box2 div.active {
		display: block;
	}
</style>
```

```
<!-- 不自动播放 -->
<div id="box">
	<button class="active">btn1</button>
	<button>btn2</button>
	<button>btn3</button>
	<div class="active">div1</div>
	<div>div2</div>
	<div>div3</div>
</div>

<!-- 自动播放 -->
<div id="box2">
	<button class="active">btn1</button>
	<button>btn2</button>
	<button>btn3</button>
	<div class="active">div1</div>
	<div>div2</div>
	<div>div3</div>
</div>
```

```
<script>
	// 构造函数写属性
	function Tab(id) {
		if(!id) {
			return;
		}
		this.oBox = document.getElementById(id);
		this.aBtn = this.oBox.getElementsByTagName('button');
		this.aDiv = this.oBox.getElementsByTagName('div');
	}

	// 原型写方法
	Tab.prototype.fnClick = function() {
		var _this = this;
		for (var i = 0; i < this.aBtn.length; i++) {
			(function(index) {
				_this.aBtn[i].onclick = function() {
					_this._click(this, index);
				}
			})(i);
		}
	}

	Tab.prototype._click = function(oBtn, index) {
		for (var i = 0; i < this.aBtn.length; i++) {
			this.aBtn[i].className = '';
			this.aDiv[i].className = '';
		}

		oBtn.className = 'active';
		this.aDiv[index].className = 'active';
	}

	// 自动播放属性
	function AutoTab(id) {
		var _this = this;
		Tab.call(this, id);  // 继承Tab属性
		this.iNow = 0;  // 当前选项卡索引值
		this.timer = null;
		clearInterval(this.timer);
		this.timer = setInterval(function() {
			_this.next();
		}, 1000);
	}

	AutoTab.prototype = new Tab();  // 继承Tab方法
	AutoTab.prototype.constructor = AutoTab;

	// 自动播放方法
	AutoTab.prototype.next = function() {
		this._click(this.aBtn[this.iNow], this.iNow);
		this.iNow++;
		if(this.iNow == this.aBtn.length) {
			this.iNow = 0;
		}
		this.fnClick();
	}

	var old_click = AutoTab.prototype._click;

	AutoTab.prototype._click = function(oBtn, index) {
		this.iNow = index;
		old_click.apply(this, arguments);  // 调整this
	}

	var oTab = new Tab('box');  // 不自动播放
	var oAuto = new AutoTab('box2');
	oAuto.next();  // 自动播放

	console.log(oTab.constructor == Tab);	// true
	console.log(oTab instanceof AutoTab);	// false

	console.log(oAuto.constructor == AutoTab);	// true
	console.log(oAuto instanceof AutoTab);	// true
	console.log(oAuto instanceof Tab);	// true
</script>
```

## 9. 解决变量名冲突的多种方法
1. 闭包、自执行函数

```
<script>
	(function(){})();

	(function(){}());

	// 首部加符号防止报错，不限于~
	~function(){}();
</script>
```

2. 面向对象
3. 命名空间
4. 模块化
5. let(ES6)

## 10. 伪数组问题
- **DOM获取的元素是伪数组**
- **arguments是伪数组**

> 注意json属性名不用纯数字


## 11. js的冒泡(Bubbling Event)和捕获(Capture Event)的区别

> 这个问题在之前的原生篇没有写好，这边补充进来。面试题那篇中也有这题。


[js之事件冒泡和事件捕获详细介绍](http://www.jb51.net/article/42492.htm)
1. 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。

2. 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。

3. DOM事件流：**同时支持两种事件模型**：捕获型事件和冒泡型事件，但是，**捕获型事件先发生**。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。
  DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。

示例
假设一个元素div，它有一个下级元素p。
```
<div>
　　<p>元素</p>
</div>
```
这两个元素都绑定了click事件，如果用户点击了p：

- 事件捕获
当你使用事件捕获时，**父级元素先触发**，子级元素后触发，即div先触发，p后触发。

- 事件冒泡
当你使用事件冒泡时，**子级元素先触发**，父级元素后触发，即p先触发，div后触发。

> addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。
IE只支持事件冒泡，不支持事件捕获。

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2125655-7fd253b1a7979357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 阻止冒泡
• 在W3c中，使用`stopPropagation()`方法
• 在IE下设置`oEvent.cancelBubble = true`；

> 在捕获的过程中stopPropagation()后，后面的冒泡过程也不会发生了。

### 阻止捕获
**阻止事件的默认行为**，例如`click <a>`后的跳转

• 在W3c中，使用`oEvent.preventDefault()`方法；
• 在IE下设置`window.event.returnValue = false;`或`return false`

## 12. 如何写一个自己的框架

> 以下只是我自己的一点想法，有些幼稚，大家可以提供更好的意见

### 仿写jQuery要点回顾

- 链式运动
  每个功能方法最后需返回当前对象
  `return this;`
- 编写插件
  - 一个插件(插件中的this不用加$)

```
<script>
    $.fn = jQuery.prototype;
    $.fn.插件名 = fn;
    // 调用
    $(div).插件名();
</script>
```
  - 一组插件
```
<script>
    $.fn = jQuery.prototype;
  	$.fn.extend = jQuery.prototype.extend = function(json) {
		for(var name in json) {
			jQuery.prototype[name] = json[name];
		}
	}
	// 调用
    $(div).插件名();
</script>
```
- `$.ajax`
    - `$.xxx`形式  放在原型的属性上
    - `xxx.find()`形式  放在原型的原型链上
```
<script>
    $.ajax = jQuery.ajax = function(json) {
    	// 调用原生的ajax方法，jsonp同理
    	ajax(json);
    }
</script>
```

### Chloe.js仿写部分jQuery功能

```
<script>
	'use strict';

	function $(arg) {  // 此处也用 $ 符号代表Chloe
		return new Chloe(arg);
	}

	function Chloe(arg) {
		this.elements = [];  // 存储选择器选择的元素
		this.domString = '';  // 存储需创建的元素

		switch (typeof arg) {
			case 'string': // 选择器
				if (arg.indexOf('<') != -1) {
					// 若为如"<div></div>"形式的则需创建元素
					this.domString = arg;
				} else {
					// 简单地判断若无标签符号<>则为选择元素
					this.elements = getEle(arg);
				}
				break;
			case 'function':  // 方法
				domReady(arg);
				break;
			default:  // 原生对象转化为 Chloe 对象
				if(arg instanceof Array) {
					this.elements = this.elements.concat(arg);
				} else {
					this.elements.push(arg);
				}
				break;
		}
	}
</script>
```

---

#blog25 (算法与数据结构)

---

这篇真的写的相当好，我记得有一次见过bat的面试题是要把算法过程以柱状图形势展现。
[十大经典排序算法总结（JavaScript描述）](https://gold.xitu.io/post/57dcd394a22b9d00610c5ec8)

[面试算法实践与国外大厂习题指南](https://zhuanlan.zhihu.com/p/25719965)

## 1. 查找算法
### 以有序数组查找定值为例

#### (1) 线性查找

循环遍历比较

eg: findInArr

```
<script>
	function findInArr(item, arr) {
		for (var i = 0; i < arr.length; i++) {
			if (arr[i] == item) {
				return true;
			}
		}
		return false;
	}
</script>
```

#### (2) 二分法查找

从中间开始，往左右两边查找

```
<script>
	var arr = [1, 2, 4];

	function findMid(item, start, end) {
		if (start > end) { // 起始位置不能大于结束位置
			return false;
		} else if (start == end) {
			if (arr[start] == item) {
				return true;
			} else {
				return false; // 没有找到最终走这步
			}
		}

		var mid = Math.floor((start + end) / 2); // 二分法先确定中间位置
		if (arr[mid] == item) {
			return true;
		} else {
			if (item < arr[mid]) {
				return findMid(item, start, mid);
			} else {
				return findMid(item, mid + 1, end);
			}
		}

	}

	console.log(findMid(10, 0, arr.length - 1));  // **注意此处传入的结束位置是arr.length-1
</script>
```

##### 二分法应用

掌握二分法的核心思想：**从中间开始，往左右两边查找**

- 无序数组查找最小值

``` javascript
<script>
	var arr = [1, 2, -4, -11, 13];

	function findMin(arr, s, e) {
		if (s > e) {
			return false;
		} else if (s == e) {
			return arr[s];
		}

		var c = Math.floor((s + e) / 2);
		var l = findMin(arr, s, c); // 先找左侧最小值
		var r = findMin(arr, c + 1, e); // 再找右侧最小值

		if (l < r) { // 两侧最小值比较
			return l;
		} else {
			return r;
		}
	}

	console.log(findMin(arr, 0, arr.length - 1));
</script>
```

- 二分法数组去重

``` javascript
<script>
	var arr = [1, 2, 3, 2, 4, 3, 1, 5, 7, 2, 5];

	// 数组内查找元素是否存在
	function findInArr(item, arr) {
		for (var i = 0; i < arr.length; i++) {
			if (item == arr[i]) {
				return true;
			}
		}
		return false;
	}

	function del(arr, s, e) {
		if (s > e) {
			return [];
		} else if (s == e) {
			return [arr[s]];
		}

		var c = Math.floor((s + e) / 2);
		var l = del(arr, s, c);
		var r = del(arr, c + 1, e);

		for (var i = 0; i < r.length; i++) {
			if (!findInArr(r[i], l)) {
				l.push(r[i]);
			}
		}

		return l;
	}

	console.log(del(arr, 0, arr.length - 1));
</script>
```

- 二分法数组排序(归并排序)

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2, 11];

	function _sort(arr, s, e) {
		if (s > e) {
			return [];
		} else if (s == e) {
			return [arr[s]];
		}

		var c = Math.floor((s + e) / 2);
		var l = _sort(arr, s, c);
		var r = _sort(arr, c + 1, e);

		var arr2 = [];
		while (l.length > 0 || r.length > 0) {
			if (l[0] < r[0]) {
				arr2.push(l.shift());
			} else {
				arr2.push(r.shift());
			}
		}

		return arr2;
	}
</script>
```

## 2. 排序算法

![各种排序算法时间复杂度和空间复杂度表](http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg)

### (1) 交换排序
#### 冒泡排序
每一轮循环内比较**相邻**的两个数，如果后一个比前一个小，互换位置。

时间复杂度：O(n^2)

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function bubbleSort(arr) {
		var len = arr.length;
		for (var i = len; i >= 2; --i) {
			for (var j = 0; j < i - 1; j++) {
				if (arr[j + 1] < arr[j]) {
					var temp;
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		return arr;
	}

	function bubbleSort2(arr) {
		var len = arr.length;
		for (var i = 0; i <= len - 1; i++) {
			for (var j = 0; j <= len - i; j++) {
				if (arr[j + 1] < arr[j]) {
					var temp;
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		return arr;
	}

	console.log(bubbleSort(arr));
	console.log(bubbleSort2(arr));
</script>
```
#### 快速排序
采用**二分法**，取出中间数，数组**每次和中间数比较**，小的放到左边，大的放到右边。
**左边和右边再同理比较**。

- 时间复杂度：O(nlog2(n))

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function quickSort(arr) {
		if(arr.length == 0) {
			return [];	// 返回空数组
		}

		var cIndex = Math.floor(arr.length / 2);
		var c = arr.splice(cIndex, 1);
		var l = [];
		var r = [];

		for (var i = 0; i < arr.length; i++) {
			if(arr[i] < c) {
				l.push(arr[i]);
			} else {
				r.push(arr[i]);
			}
		}

		return quickSort(l).concat(c, quickSort(r));
	}

	console.log(quickSort(arr));
</script>
```

### (2) 选择排序
#### 直接选择
每次**从当前位置**，**往后查找最小值**，与当前位置交换。

- 时间复杂度：O(n^2)

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function selectSort(arr) {
		for (var i = 0; i < arr.length; i++) {
			var iMinIndex = findMinIndex(arr, i);
			var temp;
			temp = arr[iMinIndex];
			arr[iMinIndex] = arr[i];
			arr[i] = temp;
		}

		return arr;
	}

	function findMinIndex(arr, start) {
		var iMin = arr[start];
		var iMinIndex = start;

		for (var i = start + 1; i < arr.length; i++) {
			if(arr[i] < iMin) {
				iMin = arr[i];
				iMinIndex = i;
			}
		}

		return iMinIndex;
	}

	console.log(selectSort(arr));
</script>
```

#### 堆排序

堆排序用到**二叉树**的概念。

- 时间复杂度：O(nlog2(n))

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function headAdjust(elements, pos, len) {
		//将当前节点值进行保存
		var swap = elements[pos];

		//定位到当前节点的左边的子节点
		var child = pos * 2 + 1;

		//递归，直至没有子节点为止
		while (child < len) {
			//如果当前节点有右边的子节点，并且右子节点较大的场合，采用右子节点和当前节点进行比较
			if (child + 1 < len && elements[child] < elements[child + 1]) {
				child ++;
			}

			//比较当前节点和最大的子节点，小于则进行值交换，交换后将当前节点定位于子节点上
			if (elements[pos] < elements[child]) {
				elements[pos] = elements[child];
				pos = child;
				child = pos * 2 + 1;
			} else {
				break;
			}

			elements[pos] = swap;
		}
	}

	//构建堆
	function buildHeap(elements) {
		//从最后一个拥有子节点的节点开始，将该节点连同其子节点进行比较，
		//将最大的数交换与该节点,交换后，再依次向前节点进行相同交换处理，
		//直至构建出大顶堆（升序为大顶，降序为小顶）
		for (var i = elements.length / 2; i >= 0; i--) {
			headAdjust(elements, i, elements.length);
		}
	}

	function sort(elements) {
		//构建堆
		buildHeap(elements);

		//从数列的尾部开始进行调整
		for (var i = elements.length - 1; i > 0; i--) {
			//堆顶永远是最大元素，故，将堆顶和尾部元素交换，将
			//最大元素保存于尾部，并且不参与后面的调整
			var swap = elements[i];
			elements[i] = elements[0];
			elements[0] = swap;

			//进行调整，将最大）元素调整至堆顶
			headAdjust(elements, 0, i);
		}
	}

	console.log(sort(arr));
</script>
```

### (3) 归并排序
采用**二分法**，左边一个**排序好的数组**，右边一个**排序好的数组**，每次**比较左右数组的第一个数**，小的放到一个新的数组中。

- 时间复杂度：O(nlog2(n))

``` javascript
<script>
	var arr = [3, 1, 4, 6, 5, 7, 2];

	function mergeSort(arr, s, e) {
		if(s > e) {
			return [];
		} else if(s == e) {
			return [arr[s]];
		}

		var c = Math.floor((s + e) / 2);
		var l = mergeSort(arr, s, c);
		var r = mergeSort(arr, c + 1, e);

		var arr2 = [];
		while(l.length > 0 || r.length > 0) {
			if(l[0] < r[0]) {
				arr2.push(l.shift());
			} else {
				arr2.push(r.shift());
			}
		}

		return arr2;
	}

	console.log(mergeSort(arr, 0, arr.length - 1));
</script>
```

## 3. 数据结构

- 时间复杂度
- 空间复杂度

![各种排序算法时间复杂度和空间复杂度表](http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg)

### (1) 有序数组
### (2) 无序数组
不重复

``` javascript
<script>
	var unorder_arr = [];

	function unorder_find(n) {
		for (var i = 0; i < unorder_arr.length; i++) {
			if(unorder_arr[i] == n) {
				return true;
			}
		}

		return false;
	}

	function unorder_add(n) {
		if(!unorder_find(n)) {
			unorder_arr.push(n);
		}
	}

	unorder_add(33);
	unorder_add(16);
	unorder_add(41);
	unorder_add(22);

	console.log(unorder_arr);
</script>
```


### (3) 二叉树
增加、查找

以第一个树为根节点，新进来的数比谁小跟谁近就放在谁下面

```
根
	节点: {
		value: n,
		l: null,
		r: null
	}

```

``` javascript
<script>
	var root = null;

	function add(node, n) {
		if (root == null) {
			root = {
				value: n,
				l: null,
				r: null
			};
		} else {
			if (n == node.value) {
				console.log('不能重复');
				return;
			} else {
				if (n < node.value) {
					console.log('查看左子树');
					if (node.l == null) {
						node.l = {
							value: n,
							l: null,
							r: null
						}
					} else {
						console.log('左子树不为空');
						return add(node.l, n);
					}
				} else {
					console.log('查看右子树');
					if (node.r == null) {
						node.r = {
							value: n,
							l: null,
							r: null
						}
					} else {
						console.log('右子树不为空');
						return add(node.r, n);
					}
				}
			}
		}
	}

	add(root, 42);
	add(root, 33);
	add(root, 66);
	add(root, 88);
	add(root, 1);
	add(root, 50);
	console.log(root);
</script>
```

### (4) 队列
特点：先进先出，后进后出

### (5) 堆栈
特点：后进先出，先进后出

### (6) 散列

存的时候先开辟一块空间出来

``` javascript
<script>
	var hash_arr = [];
	hash_arr.length = 5;
	var count = 0;

	function hash_add(n) {
		var pos = n % hash_arr.length;
		if (hash_arr[pos]) {
			while (hash_arr[pos]) {
				if (hash_arr[pos] == n) return;
				pos++;
				if (pos == hash_arr.length - 1) {
					pos = 0;
				}
			}
			hash_arr[pos] = n;
		} else {
			hash_arr[pos] = n;
		}

		count++;
		if (count == hash_arr.length) {
			var oldArr = hash_arr;
			hash_arr = [];
			count = 0;
			hash_arr.length = oldArr.length * 2;
			for (var i = 0; i < oldArr.length; i++) {
				hash_add(oldArr[i]);
			}
		}
	}

	hash_add(35);
	alert(hash_arr);
	hash_add(42);
	alert(hash_arr);
	hash_add(9);
	alert(hash_arr);
	hash_add(22);
	alert(hash_arr);
	hash_add(11);
	alert(hash_arr);
	hash_add(46);
	alert(hash_arr);
	hash_add(32);
	alert(hash_arr);
	hash_add(7);
	alert(hash_arr);
	hash_add(2);
	alert(hash_arr);
	hash_add(12);
	alert(hash_arr);
	hash_add(31);
	alert(hash_arr);
</script>
```

---

#blog 26 (代码管理与常见命令)

---


<!-- MarkdownTOC -->

- svn代码版本管理工具
- git分布式版本控制系统
	- 工作区
	- 缓存区
	- 本地仓库
	- 服务器仓库
	- 其他
	- reset的两种用法
	- reset命令的3种方式
- git的使用姿势
	- 本地代码放到github上
	- 服务器仓库已有项目
	- 多人合作
	- 关于SSH配置
- git与svn的区别
- 常用命令
	- DOS
	- Linux
	- 编辑文件
	- Node.js
- 常用快捷键
	- Windows
	- Firebug
	- 调试
	- Sublime
	- Emmet

<!-- /MarkdownTOC -->

## 1. svn代码版本管理工具
Subversion

1. 更新 `update`
2. 修改
3. 增加(已存在文件跳过这步) `add`
4. 提交(注释) `commit`

## 2. git分布式版本控制系统
> 工作区 -> 缓存区 -> 本地仓库 -> 服务器仓库

### 工作区
- `git init `          当前目录改为git目录，变为工作区

### 缓存区
- `git add xx.txt`     添加一个文件至缓存区
- `git add .`          添加所有文件至缓存区
- `git rm --cache xx.txt`  从缓存区删除一个文件

### 本地仓库
- `git commit -m '注释'`   添加文件至本地仓库

### 服务器仓库

- `git remote add origin <github上的链接>`
- `git push -u origin master`

### 其他
- `git status`         查看git此时状态
- `git log `  			日志

- `git reset` 跟一个commit(key)回到某个状态下

### reset的两种用法
- `git reset [-q] [commit] [--] <paths>`

- `git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [<commit>]`

### reset命令的3种方式

- `git reset –mixed`  此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息

- `git reset –soft`  回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可

- `git reset –hard`  彻底回退到某个版本，本地的源码也会变为上一个版本的内容
   eg: `git reset --hard HEAD^` 最新一次提交的父提交

## 3. git的使用姿势

### (1) 本地代码放到github上
**服务器上没有**

1. 跟github建立一个关系 `git remote add origin <github上的链接>`

2. 推送到github上  `git push -u origin master`

### (2) 服务器仓库已有项目
`git clone <github上的链接>`

### 多人合作
[ git merge 和 git rebase 小结](http://blog.csdn.net/wh_19910525/article/details/7554489)

### 关于SSH配置
[http://jingyan.baidu.com/article/5bbb5a1b17107e13eba179d1.html](github如何创建密钥)
**注意：id_rsa.pub才是公用秘钥，把这个放进github**

配置

`git config -l`     查看此时git的配置文件

`git config --global user.name '名字'`

`git config --global user.email '邮箱地址'`

## 4. git与svn的区别
> 来源博客

1. git是分布式的，svn不是。
git跟svn一样有自己的集中式版本库或服务器。但git更倾向于被使用于分布式模式，克隆版本库后即使没有网络也能够commit文件，查看历史版本记录，创建项目分支等，等网络再次连接上Push到服务器端。

2. git把内容按元数据方式存储，而svn是按文件。
所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。
git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。

3. git没有一个全局的版本号，svn有。

4. git的内容完整性优于svn。
因为git的内容存储使用的是SHA-1哈希算法。

5. git可以有无限个版本库，svn只能有一个指定中央版本库。
当svn中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。
每一个git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）有问题，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！

## 5. 常用命令
这些命令碰见了再慢慢补全吧

### DOS
- `d:`	 切换盘符
- `dir`      查看当前目录(文件夹)下所有文件夹及文件
- `cls`      清屏
- `cd xx`    进入目录(文件夹)

### Linux
- `ls`       查看当前目录(文件夹)下所有文件夹及文件
- `cd xx `   进入xx文件夹
- `cd ..`    返回上级目录(文件夹)
- `cd /`     返回根目录
- `touch xx` 创建文件并命名为xx
- `rm xx`    删除文件xx
- `clear`    清屏
- `cat xx`   查看文件xx的内容
- `mkdir xx` 创建目录(文件夹)并命名为xx
- `rmdir xx` 删除目录(文件夹)xx，当文件夹内容不为空时不能删除
- `rmdir -rf` 删除目录(文件夹)xx并删除其内容

#### 编辑文件
- 进入文件 `vi 文件名`
- 启用编辑 `按insert键`
- 开始编辑
- 保存  `esc -> :wq+ -> 回车`

快捷命令

- 创建文件并且输入内容 `echo 内容 > xxx.txt`

[http://www.cnblogs.com/roucheng/p/linuxdos.html](DOS 和 Linux 常用命令的对比)

### Node.js
这是一次看慕课视频的时候记下的

- `npm ls -g`  显示全局所有安装包
- `--depth=1`  最多展示一层
- `>	`	   重定向
- `2>/dev/null`  1 stand out   2 stand error 输出错误重定向到空设备文件
- `| `     上一个输出内容转为下一个输入内容
- `grep xxx-`  检索xxx开头的安装包

## 6. 常用快捷键

### Windows
- 显示桌面    `Win + D`
- 打开资源管理器    `Win + E`
- 相当于鼠标右键（等同于Shift + F10））    ![键盘右侧ctrl和alt中间的键](http://img.blog.csdn.net/20160511172120745)
- 新建文件夹    `Ctrl + Shift + N`
- 焦点移至任务栏托盘区    `Win + B`
- 打开所有活动窗口的切换栏    `Ctrl + Shift + Alt +Tab`
- 与上条想必按键松开切换栏会消失    `Alt + Tab`
- 打开Windows放大镜    `Win + "+"`
- 关闭当前标签页（浏览器中应用较多）    `Ctrl + W`
- 关闭窗口/关机    `Alt + F4`
- 定位到地址栏并选中文本（资源管理器/浏览器）   `Ctrl + L`
- 快速定位到地址栏（资源管理器浏览器）    `Alt + D`
- 刷新页面（浏览器）`Ctrl + R`
- 显示主窗口的“系统”菜单    `Alt + Space`
- 切换到多文档界面的下一个子窗口    `Ctrl + Tab`
- 在同一个程序多个窗口之间切换   `Alt + F6`
- 打开选定对象的属性   `Alt + Enter`
- 重命名对象   `F2`
- 查找所有文件   `F3`
- 在资源管理器中的窗格之间移动   `F6`

### Firebug

- 打开Firebug   `F12`
- 在新窗口中打开Firebug   `Ctrl + F12`
- 快速定位元素   `Ctrl + Shift +C`

### 调试

设置断点后

- 继续   `F8`
- 单步跳过   `F10`
- 单步进入   `F11`
- 单步退出   `Shift + F11`

### Sublime
- 选中一个元素   `Ctrl + D`
- 多选中同一个相同的元素     `按住Ctrl + D不放`
- 多行光标定位

>eg:`选中前五行` -> `Ctrl + Shift +L`  (光标定位在前五行末尾)
   —> `Home`  (光标定位在前五行行首)
   —> `Shift（不动）+ End（7次）` (选中前五行的前7个字符)
   或 —> `Ctrl + Shift +End(3次)` (选中前五行的前三列)

- 全屏   `F11`
- 快速打开文件  `Ctrl + P`
- 打开命令面板   `Ctrl + Shift + P`
- 打开/关闭SideBar   `Ctrl + K/B`
- 放大/缩小字号   `Ctrl + "+"/"-"`
- 打开一个新页面   `Ctrl + N`
- 在多个页面中跳转   `Ctrl + Tab`
- 合并两行（光标定位在第一行末尾处）   `Ctrl + J`
- 缩进/退回一个级别   `Ctrl + "]"/"["`
- 选中当前行   `Ctrl + L`
- 当前行下方新建行（允许光标不在当前行末尾时使用）   `Ctrl + Enter`
- 当前行上方新建行（允许光标不在当前行末尾时使用）  `Ctrl + Shift + N`
- 调整页面缩进   `Ctrl + Shift + P —>reindent lines`
- 打开控制台   `Ctrl + （Tab上面那个键） ->输入Sublime.log_command(True)查看命令名及参数`
- 本文件查找字符串   `Ctrl + F -> Enter 查找下一处
                                或->Shift + Enter查找上一处`
- 关闭当前文档   `Ctrl + W`
- 护肤已关闭的标签 `Ctrl + Shift + T`
-  删除当前行   `Ctrl + X`
- 当前位置插入注释  `Ctrl + Shift + /`
- 从光标处开始删除代码至行尾   `Ctrl + K + K`
- 闭合标签   `Alt + "."`
- 默认1屏 `Alt + Shift + "1"`
- 左右分屏2列 `Alt + Shift + "2"`
- 左右分屏3列 `Alt + Shift + "3"`
- 左右分屏4列 `Alt + Shift + "4"`
- 上下左右等分4屏（“田”字） `Alt + Shift + "5"`
- 垂直等分2屏 `Alt + Shift + "8"`
- 垂直等分3屏 `Alt + Shift + "9"`
- 选中当前最小区域  `Ctrl + Shift +Space -> Ctrl +Shift + Space 向外扩展选中区域`
- 局部矩形选中字符   `鼠标滚轮按住拖动`
- 去除最内层标签嵌套（光标定位在最内层）   `Ctrl + Shift + ";"`

- `ctrl+shift+d`  复制粘贴当前行
- `ctrl+shift+[`  折叠代码
- `ctrl+shift+]`  展开代码
- `ctrl+shift+v`  粘贴并格式化
- `ctrl+g `       跳转到第几行
- `ctrl+m `       跳转到对应括号
- `ctrl+w  `      关闭当前文件
- `ctrl+r `		  前往method
- `alt+数字 `     切换至当前窗口的第N个文件
- `alt+.   `  	  闭合标签
- `alt+F3   `     选中所有相同的词
- `ctrl+鼠标左键点击` 标记多个光标

###Emmet
- p20  ->  `Tab` -> padding: 20px;
- m0-auto -> `Tab` -> margin: 0 auto;
- .nav -> `Tab` -> `<div calss= "nav"></div>`
- #nav -> `Tab` -> `<div id= "nav"></div>`
- .siderbar>.nav -> `Tab` ->

```
<div calss= "siderbar">
	<div class="nav"></div>
</div>
```

- ul.nav>.li*3 -> `Tab` ->

```
<ul calss= "nav">
	<li></li>
	<li></li>
	<li></li>
</ul>
```

- 选中需嵌套的字符串 `Ctrl + Shift +G ->``<div>xxx</div>`
`.sidebar->``<div class= "sidebar"></div>`
`.sidebar>nav``<div class= "sidebar"><nav>xxx</nav></div>`
`.sidebar>#nav``<div class= "sidebar"><div id="nav">xxx</div></div>`



---

#blog27 (HTML5)

---


<!-- MarkdownTOC -->

- HTML5语法概要
- 1. H5新增元素
	- \(1\) 结构元素
	- \(2\) 其他元素
	- \(3\) input元素类型
	- \(4\) *废除的元素
- 2. H5新增属性
	- \(1\) 表单相关属性
	- \(2\) 链接相关属性
	- \(3\) 其他属性
	- \(4\) *废除属性
	- \(5\) 全局属性
- 3. H5选择器补充
	- querySelectorAll 对比 getElements 的优势
	- jQuery的选择器即是querySelectorAll
- 4. H5自定义属性 dataset
- 5. H5元素类名操作 classList
	- 隐式原型上的方法\(不一一列举\)
- 6. H5本地存储 localStorage
	- Web Storage实际上由两部分组成：sessionStorage与localStorage
	- sessionStorage与localStorage操作相同
- 7. H5地理位置 geolocation
	- \(1\) 测试用例
	- \(2\) 百度地图API
- 8. H5音频 audio
	- \(1\) 属性
	- \(2\) 方法
	- \(3\) 应用：钢琴弹奏
	- \(4\) 应用：音乐播放器
- 9. H5视频 video
	- \(1\) 属性
	- \(2\) 方法
- 10. H5文件 FileReader
	- \(1\) 文件拖拽
	- \(2\) File接口
	- \(3\) 示例
- 11. H5 web工作线程 webworker
	- \(1\) 方法
	- \(2\) 示例
- 12. H5 webSocket 网络套接字
- 13. H5画布 canvas
	- \(1\) 应用 canvas笑脸
	- \(2\) 应用 canvas画图
	- \(3\) 应用 canvas变换
	- \(4\) 应用 canvas内长方形拖拽
	- \(5\) 应用 canvas内圆形拖拽
	- \(6\) 应用 下载canvas绘图
	- \(7\) 应用 canvas运动回调
	- \(8\) canvas框架 jCanvaScript.js
- 14. H5内联SVG
	- \(1\) 位图 && 矢量图
	- \(2\) SVG使用
	- \(3\) SVG梗概
	- \(4\) SVG应用
	- \(5\) 矢量图形库 Raphael.js

<!-- /MarkdownTOC -->



[翻译-你必须知道的28个HTML5特征、窍门和技术](http://www.zhangxinxu.com/wordpress/2010/08/%E7%BF%BB%E8%AF%91-%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8428%E4%B8%AAhtml5%E7%89%B9%E5%BE%81%E3%80%81%E7%AA%8D%E9%97%A8%E5%92%8C%E6%8A%80%E6%9C%AF/)

[html5shiv项目让IE6-IE9浏览器都支持HTML5中的元素](http://www.zhangxinxu.com/wordpress/2013/02/github-html5shiv-readme-translate/)

## HTML5语法概要
1. 内容类型
2. DOCTYPE声明
3. 指定字符编码
4. 可以省略标记的元素
5. 具有boolean值的元素
6. 省略行内属性赋值的引号

## 1. H5新增元素

![H5标签集合](http://ojvx9eehr.bkt.clouddn.com/H5%E6%A0%87%E7%AD%BE%E9%9B%86%E5%90%88.jpg)

![H5页面常用结构](http://ojvx9eehr.bkt.clouddn.com/H5%E9%A1%B5%E9%9D%A2%E5%B8%B8%E7%94%A8%E7%BB%93%E6%9E%84.gif)

### (1) 结构元素
#### section
对网站内容分块、分段
当容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section

结构(标题+内容)
``` html
<section>
	<h1></h1>
	<p></p>
</section>
```
#### article
代表文档内容 独立性 可嵌套使用
可看作特殊的section元素

常见结构
``` html
<article>
	<header>
		<h1></h1>
	</header>
	<article>
		<header>
			<h2></h2>
		</header>
		<p></p>
		<footer></footer>
	</article>
	<footer></footer>
</article>
```

#### aside
用来表示当前页面或文章的附属信息(相关引用、侧边栏、广告、导航条)

常见结构
``` html
<header>
	<h1></h1>
</header>
<article>
	<h1></h1>
	<p></p>
	<aside>
		<h1></h1>
		<p></p>
	</aside>
</article>
<aside>
	<nav>
		<h2>评论</h2>
		<ul>
			<li><a href="javascipt:;"></a></li>
			<li><a href="javascipt:;"></a></li>
		</ul>
	</nav>
</aside>
```

#### nav
常见应用：导航条、侧边栏导航、页内导航、翻页操作
**不能用menu元素代替nav元素**

常见结构
``` html
<nav>
	<ul>
		<li><a href="javascript:;"></a></li>
		<li><a href="javascript:;"></a></li>
	</ul>
</nav>

<article>
	<header>
		<nav>
			<ul>
				<li><a href="javascript"></a></li>
				<li><a href="javascript"></a></li>
			</ul>
		</nav>
	</header>
	<section>
		<h1></h1>
		<p></p>
	</section>
	<section>
		<h1></h1>
		<p></p>
	</section>
	<footer>
		<a href="javascript:;"></a>
		<a href="javascript:;"></a>
	</footer>
</article>
```

#### figure
figure -> 内容相关，去掉不影响理解的内容
figcaption -> figure里

```
<figure>
  <img src="xxx.jpg">
  <figcaption>描述</figcaption>
</figure>
```

#### time
用来区分各时区或编码

常见结构
``` html
	<time datetime="2017-1-1">2017-1-1</time>
	<time datetime="2017-1-1T20:00">2017-1-1</time>
```

#### pubdate
指明发布时间

常见结构
``` html
	<article>
		<header>
			<h1></h1>
			<p>
				<time datetime="2017-1-1" pubdate>2017-1-1</time>
			</p>
		</header>
	</article>
```
#### header
header可出现多次

常见结构
``` html
<header>
	<h1></h1>
	<nav>
		<ul>
			<li><a href=""></a></li>
			<li><a href=""></a></li>
			<li><a href=""></a></li>
		</ul>
	</nav>
</header>
<article>
	<header>
		<h1></h1>
	</header>
</article>
```

#### footer
footer可出现多次
常见应用：脚注(相关链接、版权信息)

常见结构
``` html
<footer>
	<ul>
		<li><a href="">版权信息</a></li>
		<li><a href="">联系我们</a></li>
		<li><a href="">加入我们</a></li>
	</ul>
</footer>
```
#### hgroup
将标题及其子标题进行分组

常见结构
``` html
<article>
	<header>
		<hgroup>
			<h1>主标题</h1>
			<h2>子标题</h2>
		</hgroup>
		<p>
			<time datetime="2017-1-1">2017-1-1</time>
		</p>
	</header>
	<div></div>
	<footer>
	</footer>
</article>
```

#### address
在文档中呈现联系信息(作者名字、网站连接、电子邮箱、地址、手机号)

常见结构
``` html
<address>
	<a href=""></a>
	<a href=""></a>
</address>
<footer>
	<div>
		<address>
			<a href=""></a>
		</address>
		<time datetime="2017-1-1">2017-1-1</time>
	</div>
</footer>
```

#### 整体应用
``` html
<header>
	<h1>xxx</h1>
	<nav>
		<ul>
			<li><a href="#">a1</a></li>
			<li><a href="#">a2</a></li>
		</ul>
	</nav>
</header>
<article>
	<hgroup>
		<h1>主标题</h1>
		<h2>子标题</h2>
	</hgroup>
	<p>正文</p>
	<section>
		<div>
			<article>
				<h1>评论标题</h1>
				<p>评论正文</p>
			</article>
		</div>
	</section>
</article>
<footer>
	<small>版权***</small>
</footer>
```

### (2) 其他元素
#### video
不同浏览器支持的格式不同，可能需要转码，在source标签里引入多种格式

FF不支持mp4，支持ogg

controls属性显示自带控制进度条

常见结构
``` html
<html>
	<video src="xxx.mp4" controls></video>
	<hr>
	<video  controls>
		<source src="xxx.mp4">
		<source src="xxx.ogg">
	</video>
	<hr>
	<video src="xxx.mp4" id="v1" width="400px" height="200px"></video>
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var v1 = document.getElementById('v1');
	function play() {
		if(v1.paused) {
			v1.play();
		} else {
			v1.pause();
		}
	}
</script>
```

#### audio
controls属性显示自带控制进度条

常见结构
``` html
<html>
	<audio src="xxx.mp3" controls></audio>  <!-- 显示音频自带播放器样式 -->
	<hr>
	<audio src="xxx.mp3" id="a1"></audio>  <!-- 只显示下面的按钮 -->
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var a1 = document.getElementById('a1');
	function play() {
		if(a1.paused) {
			a1.play();
		} else {
			a1.pause();
		}
	}
</script>
```

#### canvas

#### meter
meter -> 度量条
eg:
```
<meter value="3" min="0" max="10">3/10</meter><br>
<meter value="0.6">60%</meter>`
```

#### progress
progress -> 下载进度条
eg:
```
<progress max="100"></progress>
<progress value="22" max="100"></progress>
```

#### details summary
summary -> 总结/梗概(下拉按钮展开details内容)
details -> summary里 -> 详情
eg:
```
<details>
	<summary>HTML 5</summary>
	This document teaches you everything you have to learn about HTML 5.
</details>
```

#### ...

### (3) input元素类型
- email
- url
- number
- range

- date
- time

- Date Pickers

### (4) *废除的元素
- 能用CSS替代的元素：basefont、big、center、font、s、tt、u等
- frame框架
- 只有部分浏览器支持的元素

## 2. H5新增属性

### (1) 表单相关属性
####form
form的元素可写在form外，只要指向相同id

常见结构
``` html
<form id="form1">
	<input type="text">
</form>
<textarea form="form1"></textarea>
```
#### formaction
不同表单元素不同action路径

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formaction="fc1">
	<input type="submit" name="s2" value="v2" formaction="fc2">
	<input type="submit" name="s3" value="v3" formaction="fc3">
</form>
```

#### formmethod
不同表单元素不同提交方法

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formmethod="get" formaction="fc1">
	<input type="submit" name="s2" value="v2" formmethod="post" formaction="fc2">
</form>
```
#### formenctype
不同表单元素不同编码方式

常见结构
``` html
<form id="form1">
	<input type="text" formenctype="text/plain" value="表单数据中的空格转换为加号">
	<input type="text" formenctype="multipart/form-data" value="文件上传">
	<input type="text" formenctype="application/x-www-form-urlencoded" value="get方式时把表单数据转换为字符">
</form>
<textarea form="form1"></textarea>
```

#### formtarget
不同表单元素不同提交后在何处打开加载页面

常见结构
``` html
<form id="form1">
	<input type="text">
	<input type="submit" name="s1" value="v1" formtarget="_blank" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_self" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_parent" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="_top" formaction="fc1">
	<input type="submit" name="s1" value="v1" formtarget="framename" formaction="fc1">
</form>
```

#### autofocus
表单元素自动获得焦点

常见结构
``` html
<form id="form1">
	<input type="text" autofocus>
	<input type="text">
</form>
```

#### require
提交时内容为空不允许提交，并显示提示

常见结构
``` html
<form id="form1">
	<input type="text" required>
	<input type="text">
	<input type="submit">
</form>
```
#### labels
验证提示信息

常见结构
``` html
<form id="form1">
	<label for="t1" id="l1"></label>
	<input type="text" id="t1">
	<input type="button" id="btn1" value="验证" onclick="validate()">
</form>
```

``` javascript
<script>
	function validate() {
		var t1 = document.getElementById('t1');
		var btn1 = document.getElementById('btn1');
		var fm1 = document.getElementById('form1');

		if(t1.value.trim() == "") {
			var l1 = document.getElementById('l1');
			l1.setAttribute('for', 't1');
			f1.insertBefore(l1, btn1);	// 在button前显示验证提示信息
			t1.labels[1].innerHTML = '输入为空';
		}
	}
</script>
```

#### placeholder
输入提示信息

常见结构
``` html
<form id="form1">
	<input type="text" placeholder="请输入...">
</form>
```

#### datalist
可输入的下拉框

常见结构
``` html
<form id="form1">
	<input type="text" name="n1" list="ns">  <!-- 点击下拉箭头时显示datalist -->
	<datalist id="ns" style="display: none">
		<option value="v1">v1</option>
		<option value="v2">v2</option>
	</datalist>
</form>
```
#### autocomplete
输入自动填充

#### pattern
表单元素正则验证，输入错误时不跳转

常见结构
``` html
<form id="form1" action="xxx">
	<input type="text" pattern="{a-z}[3]" >
	<input type="submit">
</form>
```

#### selectionDirection
*Chrome不支持

#### indeterminate
复选框checkbox 的第三种状态 “尚未明确是否选取”状态

#### image按钮的width/height

### (2) 链接相关属性
### (3) 其他属性
### (4) *废除属性

### (5) 全局属性
contentEditable
designMode
hidden
spellcheck       拼写检查
tabindex         设置tab键焦点的顺序

## 3. H5选择器补充
*兼容：IE8+

- document/dom.querySelector() 匹配指定 css 选择器的一个元素

- querySelectorAll()  匹配指定 css 选择器的所有元素 (NodeList)

> **注意：** querySelectorAll()方法得到的类数组对象是非动态实时的

### querySelectorAll 对比 getElements 的优势
可以操作数组

``` html
	<div class="box"></div>
	<div class="box"></div>
	<div class="box"></div>
```

``` javascript
<script>
	var aBox = document.querySelectorAll('div');

	// getElements得到的是伪数组，不能操作各项的属性

	// var aBox = document.getElementsByTagName('div');
	// for (var i = 0; i < aBox.length; i++) {
	// 	aBox[i].onclick = function() {
	// 		alert(1);
	// 	}
	// }

	aBox.forEach(function(item, index) {
		item.onclick = function() {
			alert(index);
			// 弹出当前点击div的索引值，依次为0、1、2
		}
	})
</script>
```


### jQuery的选择器即是querySelectorAll

``` javascript
<script>
	function $(selector) {
		var items = document.querySelectorAll(selector);

		if(items.length > 1) {
			return items;
		} else if (items.length == 0) {
			return;
		} else {
			return items[0];
		}
	}
</script>
```

## 4. H5自定义属性 dataset

[HTML5自定义属性对象Dataset简介](http://www.zhangxinxu.com/wordpress/2011/06/html5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1dataset%E7%AE%80%E4%BB%8B/)

[HTML5 datalist在实际项目中应用的可行性研究](http://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/)

示例
``` html
	<a data-link="#" data-user-name="chloe">wangchloe.vip</a>
```

``` javascript
<script>
	var oA = document.querySelector('a');
	oA.dataset.link = 'http://wangchloe.vip';
	oA.href = oA.dataset.link + '?name=' + oA.dataset.userName;
	// http://wangchloe.vip?name=chloe
	// *注意：两个及以上属性名调用时需转化为驼峰命名
</script>
```

## 5. H5元素类名操作 classList

[HTML5 DOM元素类名相关操作API classList简介](http://www.zhangxinxu.com/wordpress/2013/07/domtokenlist-html5-dom-classlist-%E7%B1%BB%E5%90%8D/)

``` html
<!-- 该示例来源于张鑫旭个人博客 -->
<body class="a b c"></body>
```

``` javascript
<script>
	console.log(document.body.classList);
	console.log(document.body.className);
	console.log(document.body.classList.toString() === document.body.className;)	// true
</script>
```

> HTML5 DOM元素类名相关操作API classList简介>>>测试

![HTML5 DOM元素类名相关操作API classList简介>>>测试](http://img.blog.csdn.net/20170110000715296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzk1MDkxNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 隐式原型上的方法(不一一列举)

- obj.add(cName1, cName2, ...);

- obj.remove(cName1, cName2, ...);

- obj.toggle(cName);

- obj.contains(cName);

## 6. H5本地存储 localStorage

[HTML5 localStorage本地存储实际应用举例](http://www.zhangxinxu.com/wordpress/2011/09/html5-localstorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/)

**cookie && localStorage && sessionStorage** (来源CSDN)

- 共同点：
     都是保存在浏览器端，且同源的。

- 不同点：
	1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

	2. cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。

	3. 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

	4. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。

	5. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

	6. Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。

### Web Storage实际上由两部分组成：sessionStorage与localStorage

- sessionStorage用于本地存储一个会话(session)中的数据，这些数据只有在同一个会话中的页面才能访问并且当前会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。

- localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

> *兼容：可以先测试，以确定window.localStorage是否存在。

### sessionStorage与localStorage操作相同

- 设置

`localStorage.key = value;`

`localStorage.setItem(key, value);`

``` javascript
<script>
	var userName = 'chloe';

	//存储，IE6~7 cookie 其他浏览器HTML5本地存储
	if (window.localStorage) {
		localStorage.setItem("name", userName);
	} else {
		Cookie.write("name", userName);	// MooTools框架下cookie的写法
	}
</script>
```

- 读取

`localStorage.key;`

`localStorage.getItem(key);`

``` javascript
<script>
	var userName = window.localStorage ? localStorage.getItem("name") : Cookie.read("name"); // MooTools框架下cookie的写法
</script>
```

- 遍历

``` javascript
<script>
	var storage = window.localStorage;
	for (var i = 0, len = storage.length; i < len; i++) {
		var key = storage.key(i);
		var value = storage.getItem(key);
		console.log(key + "=" + value);
	}
</script>
```

- 删除

`delete localStorage.key;`

`localStorage.removeItem(key);`

``` javascript
<script>
	if (window.localStorage) {
		localStorage.removeItem("name");
	} else {
		Cookie.dispose('name'); // MooTools框架下cookie的写法
	}
</script>
```

- 清空

`localStorage.clear();`

- 监听
`window.onStorage` 监听localStorage变化

## 7. H5地理位置 geolocation

LBS -> Location Based Service 基于位置服务

### (1) 测试用例

``` javascript
<script>
	window.navigator.geolocation.getCurrentPosition(function(res) {
		console.log(res);
	}, function(err) {
		console.log(err);
	})
</script>
```

#### PositionError
错误码 错误信息

- `code: 1`
`message: "User denied Geolocation"` -> 用户拒绝授权

- `code: 1`
`message: "Only secure origins are allowed (see: https://goo.gl/Y0ZkNV).` -> 仅允许HTTPS访问

- `code:2`
`message:"Network location provider at 'https://www.googleapis.com/' : No response received."` -> 没翻墙

### (2) 百度地图API
- timestamp 时间戳

- coords -> 地理坐标
  - accuracy:26 -> 精确度
  - altitude:null -> 海拔
  - altitudeAccuracy:null -> 海拔高度精确度
  - heading:null -> 方向
  - latitude:31.167638 -> 纬度
  - longitude:121.423593 -> 经度
  - speed:null -> 速度

```
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
	<style type="text/css">
		body, html,#allmap {
			user-select: none;
			width: 100%;
			height: 100%;
			overflow: hidden;
			margin: 0;
			font-family: "微软雅黑";
		}
	</style>
	<script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=wmwHFMPxi66GlPBVUrdgEhDzbLUqlSrM"></script>
	<title>上海师范大学 - 百度地图</title>
</head>
<body>
	<div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
	var map = new BMap.Map("allmap");

	map.centerAndZoom(new BMap.Point(121.423593, 31.167638), 20); // 初始化地图,设置中心点坐标和地图级别

	map.addControl(new BMap.MapTypeControl()); //添加地图类型控件
	map.setCurrentCity("上海"); // 设置地图显示的城市 此项是必须设置的
	map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放

	navigator.geolocation.getCurrentPosition(function(res) {
		var {
			coords: {
				longitude,
				latitude
			}
		} = res;

		var point = new BMap.Point(longitude, latitude);

		var marker = new BMap.Marker(point);
		map.addOverlay(marker);

		marker.setAnimation(BMAP_ANIMATION_BOUNCE)

		map.panTo(point)
	}, function(err) {
		console.log(err);
	})
</script>
```

## 8. H5音频 audio

- 音频格式：mp3 wma flat ape wav ogg

### (1) 属性
- src -> 音频路径
- controls -> 显示自带控制进度条
- loop -> 音频循环
- autoplay -> 自动播放 只有pc端可以实现
- muted -> 静音

- currentTime -> 当前播放时间
- duration -> 音频总时间
- volume -> 音量 [0,1]

- ontimeupdate -> 进度更新

- play -> 是否在播放 返回true/false
- pause -> 是否暂停 返回true/false

### (2) 方法
- play() -> 播放歌曲
- pause() -> 暂停歌曲
- load() -> 重新加载歌曲
- onended() -> 音频播放完毕

常见结构
``` html
<html>
	<audio src="xxx.mp3" controls></audio>  <!-- 显示音频自带播放器样式 -->
	<hr>
	<!-- 自定义播放器 -->
	<audio src="xxx.mp3" id="a1"></audio>  <!-- 只显示下面的按钮 -->
	<!-- 进度条 -->
	<div class="progress">
		<div class="inner"></div>
	</div>
	<input type="range" min="0" max="100" value="100">音量
	<button onclick="aPlay()">播放/暂停</button>
	<button onclick="aMute()">静音</button>
</html>
```

``` javascript
<script>
	var a1 = document.getElementById('a1');
	var progress = document.querySelector('.progress');
	var oInner = document.querySelector('.inner');
	var oRange = document.querySelector('[type=range]');

	// 自定义进度条
	// setInterval(function() {
	// 	oInner.style.width = (a1.currentTime / a1.duration) * 100 + '%';
	// }, 16);

	a1.ontimeupdate = function(){
		oInner.style.width = (a1.currentTime / a1.duration) * 100 + '%';
	}

	progress.onclick = function({
		clientX
	}) {
		var leftDelta = clientX - this.offsetLeft;

		var percentage = leftDelta / this.offsetWidth;

		a1.currentTime = a1.duration * percentage;
	}

	oRange.oninput = function(){
		a1.volume = this.value/100;
	}

	function aPlay() {
		if (a1.paused) {
			a1.play();
		} else {
			a1.pause();
		}
	}

	function aMute() {
		a1.muted = !oA.muted;
	}

</script>
```

### (3) 应用：钢琴弹奏

- **sound.js**

钢琴示例

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>钢琴示例</title>
	<style>
		body {
			user-select: none;
		}
		ul, li {
			list-style: none;
			margin: 0;
			padding: 0;
		}
		ul {
			width: 400px;
			margin: 40px auto;
		}
		li {
			width: 38px;
			border: 1px solid black;
			height: 198px;
			float: left;
			text-align: center;
			line-height: 350px;
			margin-left: 10px;
			transform-origin: top center;
		}
		li:active {
			transform: perspective(800px) rotateX(-10deg);
		}
		li.active {
			transform: perspective(800px) rotateX(-10deg);
		}
	</style>
</head>
<body>
	<ul>
		<li>1</li>
		<li>2</li>
		<li>3</li>
		<li>4</li>
		<li>5</li>
		<li>6</li>
		<li>7</li>
		<li>8</li>
	</ul>
	<script src="statics/sound.js"></script>
	<script>
		var aLi = document.querySelectorAll('li');

		aLi.forEach(function(oLi, index) {
			oLi.onmousedown = function() {
				playSound(index + 49);
			}
		})

		window.onkeydown = function({
			keyCode
		}) {
			playSound(keyCode);

			aLi[keyCode - 49].classList.add('active');
		}

		window.onkeyup = function({
			keyCode
		}) {
			if (keyCode >= 49 && keyCode <= 56) {
				aLi[keyCode - 49].classList.remove('active');
			}
		}

		function playSound(index) {
			new Audio(oggSound[`sound${index}`]).play();
		}
	</script>
</body>
</html>
```

### (4) 应用：音乐播放器

- 歌词显示

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		#box {
			width: 200px;
			margin: 40px auto;
			text-align: center;
			padding: 10px;
			border: 2px solid black;
			-webkit-background-clip: text;
			background-image: linear-gradient(90deg, red 30%, blue 30%);
			color: transparent;
		}
	</style>
</head>
<body>
	<div id="box">
		西湖的水我的泪
	</div>
	<script>
		var progress = 0;
		var oBox = document.querySelector('div');

		setInterval(function() {
			oBox.style.backgroundImage = `linear-gradient(90deg,red ${progress}%,blue ${progress}%)`

			progress += 0.4;
		}, 16)
	</script>
</body>
</html>
```

## 9. H5视频 video
不同浏览器支持的格式不同，可能需要转码，在source标签里引入多种格式

FF不支持mp4，支持ogg

### (1) 属性
- src -> 视频路径
- controls -> 显示自带控制进度条
- loop -> 视频循环
- autoplay -> 自动播放
- muted -> 静音

- currentTime -> 当前播放时间
- duration -> 视频总时间
- volume -> 音量 [0,1]

- ontimeupdate -> 进度更新

- play -> 是否在播放 返回true/false
- pause -> 是否暂停 返回true/false

### (2) 方法
- play() -> 播放视频
- pause() -> 暂停视频
- load() -> 重新加载视频
- onended() -> 视频播放完毕

常见结构
``` html
<html>
	<video src="xxx.mp4" controls></video>
	<hr>
	<video  controls>
		<source src="xxx.mp4">
		<source src="xxx.ogg">
	</video>
	<hr>
	<video src="xxx.mp4" id="v1" width="400px" height="200px"></video>
	<button onclick="play()">播放/暂停</button>
</html>
```

``` javascript
<script>
	var v1 = document.getElementById('v1');
	function play() {
		if(v1.paused) {
			v1.play();
		} else {
			v1.pause();
		}
	}
</script>
```

## 10. H5文件 FileReader

### (1) 文件拖拽
- ondragover -> 只要悬浮，一直触发
- ondragenter -> 进入时触发，有子节点时有问题
- ondragleave -> 离开时触发，有子节点时有问题
- ondrop -> 释放鼠标时触发，对应DOM节点的dragover事件必须取消默认事件

### (2) File接口
`var reader = new FileReader();`  新建文件读取对象

方法
- `.readAsText(file)` -> 读取文本文件
- `.readAsDataURL(file)` -> 读取多媒体

- `.onload` -> 资源读取完毕  reader.result
- `.onprogress` -> 读取进度更新时触发

`<progress max="100"></progress>`

```
<script>
	reader.onprogress = function(ev){
		oProgress.value = ev.loaded/ev.total*100;
	}
</script>
```

- `.onloadstart` -> 加载开始时触发
- `.onloadend` -> 加载结束时触发
- `.onerror` -> 出现错误时触发
- `.onabort` -> 加载过程中中止时触发

- `.abort` -> 手动中止加载


### (3) 示例

- 文本

``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		reader.readAsText(file);	// 读取文本文件

		reader.onload = function(ev) {
			console.log(reader.result);
		}

		ev.preventDefault();
	}
</script>
```

- 多媒体

``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		reader.readAsDataURL(file);		// 读取多媒体

		reader.onload = function(ev) {
			new Audio(reader.result).play();
		}

		ev.preventDefault();
	}
</script>
```

- 处理文本/多媒体

``` javascript
<script>
	oBlock.ondrop = function(ev) {
		var file = ev.dataTransfer.files[0];

		var reader = new FileReader();

		if (/text/.test(file.type)) {  // 处理文本

			reader.readAsText(file);

			reader.onload = function() {
				document.write(reader.result);
			}

			console.log('text');

		} else {  // 处理多媒体
			reader.readAsDataURL(file);

			reader.onload = function() {
				if (/image/.test(file.type)) {
					console.log('image');

					var oImage = new Image();
					oImage.src = reader.result;

					document.body.appendChild(oImage)

				} else if (/video/.test(file.type)) {

					console.log('video');

					oVideo.src = reader.result;
					oVideo.play();

				} else {

					console.log('audio');
					new Audio(reader.result).play();

				}
			}
		}

		ev.preventDefault();
	}
</script>
```

## 11. H5 web工作线程 webworker
- 进程
- 线程

`var worker = new Worker('js文件');`  新建worker

> 	1. 需在服务器环境下
	2. 不会改变数据类型
	3. 不会改变父线程数据
	4. DOM/BOM 不可使用(console.log可用)
    5. 只能有一层子线程，子线程不可再开子线程

### (1) 方法
- worker.postMessage('Data')  向worker内传递数据 (1)
- worker.onmessage 监听事件 (4)
- worker.terminate 停止worker

worker内部
监听事件：
- this.onmessage -> ev -> ev.data //'Data' (2)
- this.postMessage 向父线程传递数据  (3)

### (2) 示例

- 主程序

``` javascript
<script>
	var worker = new Worker('./calc.js');

	worker.postMessage(2);
</script>
```

- calc.js

``` javascript
<script>
	this.onmessage = function(ev) {
		console.log(ev.data)
	}

	function fibonacci(n){
		if( n == 1 || n == 2 ) return 1;

		return fibonacci(n-1) + fibonacci(n-2);
	}
</script>
```

## 12. H5 webSocket 网络套接字

- 客户端
	1.发消息 -> emit
	2.接消息 -> on

- 服务端
	1.接消息 -> on
	2.发消息 -> emit

在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header。

WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。

> Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议。

## 13. H5画布 canvas

基于 JavaScript 的绘图 API

`<canvas></canvas>`

获取绘图上下文
``` javascript
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');
</script>
```

ctx.
  - moveTo(x, y)  移动
  - lineTo(x, y)  划线
  - fillStyle = "color"  更改填充颜色
  - fill()  填充
  - strokeStyle = "color"  更改描边样式
  - stroke()  描边

- 矩形
ctx.
  - fillRect(x, y, w, h)  填充矩形(没有路径)
  - strokeRect(x, y, w, h)  描边矩形(没有路径)
  - rect(x, y, w, h)  举行路径
  - clearRect(x, y, w, h)  清空区域

- 弧
ctx.
  - arc(cx, cy, r, startDegree, endDegree, anticlockwise)  圆心x，圆心y，半径，起始角度(弧度制)，结束角度(弧度制)，是否逆时针
  - fill()  填充

- 文本
ctx.
  - font = "字号 字体"
  - textAlign = "left/center/right"  竖轴对齐方式
  - textBaseline ="top/middle/bottom" 横轴对齐方式
  - fillText('文字', x, y)  填充文字
  - strokeText('文字', x, y)  描边文字
  - measureText('文字')  返回文字长度(width)

ctx.
  - beginPath()  开始路径
  - closePath()  闭合路径

- 线条样式
ctx.
  - lineCap = "round/butt(默认)/square"  更改线帽
  - lineJoin = "round/miter(默认)/bevel(切角)"  更改连接点样式
  - lineWidth = 20  线宽

- 阴影
ctx.
  - shadowColor	设置或返回阴影颜色
  - shadowBlur	设置或返回阴影模糊级别
  - shadowOffsetX	设置或返回阴影距形状的水平距离
  - shadowOffsetY	设置或返回阴影距形状的垂直距离

- 渐变
ctx.
  - createLinearGradient(x0, y0, x1, y1)  创建线性渐变 起始位置 结束位置（用在画布内容上）
  - createPattern(img, "repeat|repeat-x|repeat-y|no-repeat")	在指定的方向上重复指定的元素
  - createRadialGradient(x0, y0, r0, x1, y1, r1)	创建径向渐变 起始位置 结束位置（用在画布内容上）
  - addColorStop(位置, 颜色)	规定渐变对象中的颜色和停止位置(0~1)

- 画图
ctx.
  - drawImage(img, x, y)  在画布上绘制图像、画布或视频
  - drawImage(img, x, y, width, height)
  - drawImage(img, sx, sy, swidth, sheight, x, y, width, height)  剪切图像，并在画布上定位被剪切的部分 s-裁剪

	```
	<script>
		var oC = document.querySelector('canvas');
		var ctx = oC.getContext('2d');

		var oImage = new Image();
		oImage.src = 'xxx.png';

		oImage.onload = function() {
			ctx.drawImage(oImage, 0, 0);
		}
	</script>
	```

- 像素操作
ctx.
  - getImageData(x, y, w, h)  画布指定矩形复制像素数据  **需服务器环境**
    imgData包括{data, width, height}  其中data是像素数组
    - red=imgData.data[0];
	- green=imgData.data[1];
	- blue=imgData.data[2];
	- alpha=imgData.data[3];
  - putImageData(imgData, x, y) 将图像数据放回画布

- 变换
ctx.
  - scale(sW, sH)	缩放当前绘图至更大或更小
  - rotate(角度*Math.PI/180)	旋转当前绘图
  - translate(x, y)	重新映射画布上的 (0,0) 位置
  > 注意translate和moveTo的区别

  - transform(a,b,c,d,e,f)	替换绘图的当前转换矩阵(相对变化)  水平缩放 水平倾斜 垂直倾斜 垂直缩放 水平移动 垂直移动
  - setTransform(a,b,c,d,e,f)	将当前转换重置为单位矩阵(不相对变化)  水平缩放 水平倾斜 垂直倾斜 垂直缩放 水平移动 垂直移动

ctx.
  - isPointInPath(x, y)  点是否在路径内

ctx.
  - save()	保存当前环境的状态
  - restore()	返回之前保存过的路径状态和属性

---

- \(1\) 应用 canvas笑脸
- \(2\) 应用 canvas画图
- \(3\) 应用 canvas变换
- \(4\) 应用 canvas内长方形拖拽
- \(5\) 应用 canvas内圆形拖拽
- \(6\) 应用 下载canvas绘图
- \(7\) 应用 canvas运动回调
- \(8\) canvas框架 jCanvaScript.js

---

### (1) 应用 canvas笑脸
```
<canvas width="800" height="1200"></canvas>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');

    // face
    ctx.fillStyle = 'yellow';
    ctx.arc(400, 250, 180, 0, 2 * Math.PI, false);
    ctx.fill();
    ctx.stroke();

    // mouth
    ctx.beginPath();
    ctx.lineCap = 'round';

    ctx.lineWidth = 20;
    ctx.fillStyle = 'red';
    // ctx.arc(400, 280, 80, 0, Math.PI, false); // 笑脸
    ctx.arc(400, 350, 80, Math.PI, 0, false); //不开心脸
    // ctx.fill();  // 红色实心半圆张嘴笑脸
    ctx.stroke(); // 黑色半圆弧微笑脸

    // eyes
    ctx.beginPath();
    ctx.fillStyle = 'black';
    ctx.moveTo(350, 200);
    ctx.arc(350, 200, 20, 0, 2 * Math.PI, false);

    ctx.moveTo(450, 200);
    ctx.arc(450, 200, 20, 0, 2 * Math.PI, false);

    ctx.closePath();

    ctx.fill();
</script>
```


![应用_canvas笑脸.PNG](http://upload-images.jianshu.io/upload_images/2125655-28ebcaa31def035a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


![应用_canvas笑脸2.PNG](http://upload-images.jianshu.io/upload_images/2125655-578a2a6d3743a8d9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


![应用_canvas笑脸3.PNG](http://upload-images.jianshu.io/upload_images/2125655-abef3669f38f982d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### (2) 应用 canvas画图
```
<canvas width="800" height="600"></canvas>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');

	oC.onmousedown = function(ev) {

		var {
			clientX,
			clientY
		} = ev;

		ctx.moveTo(clientX, clientY)

		oC.onmousemove = function(ev) {

			ctx.clearRect(0, 0, oC.width, oC.height);

			var {
				clientX,
				clientY
			} = ev;

			ctx.lineWidth = 5;
			ctx.lineTo(clientX, clientY);
			ctx.stroke();
		}

		oC.onmouseup = function() {
			oC.onmousemove = null;
			oC.onmouseup = null;
		}
	}
</script>
```



![应用_canvas画图.gif](http://upload-images.jianshu.io/upload_images/2125655-f340c24012917b44.gif?imageMogr2/auto-orient/strip)



### (3) 应用 canvas变换
```
<canvas width="800" height="600"></canvas>
	<script>
		var oC = document.querySelector('canvas');
		var ctx = oC.getContext('2d');

		var degree = 1;

		var x1 = 300;
		var y1 = 300;
		var w1 = 100;
		var h1 = 100;

		var x2 = 100;
		var y2 = 100;
		var w2 = 50;
		var h2 = 50;

		var rotate1 = 0;
		var rotate2 = 0;

		setInterval(function() {
			ctx.clearRect(-oC.width, -oC.height, oC.width * 2, 2 * oC.height);

			ctx.save();
			ctx.translate(x1, y1);
			ctx.rotate(rotate1);
			ctx.fillRect(-w1 / 2, -h1 / 2, w1, h1);
			ctx.restore();

			ctx.save();
			ctx.translate(x2, y2);
			ctx.rotate(rotate2);
			ctx.fillRect(-w2 / 2, -h2 / 2, w2, h2);
			ctx.restore()

			rotate1++;
			rotate2 += 0.2;
		}, 100)

		function d2a(deg) {
			return deg / 180 * Math.PI
		}
	</script>
```


![应用_canvas变换.gif](http://upload-images.jianshu.io/upload_images/2125655-26862c67c81cfe41.gif?imageMogr2/auto-orient/strip)


### (4) 应用 canvas内长方形拖拽
```
<canvas width="800" height="600"></canvas>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');

	var rect = {
		x: 0,
		y: 0,
		w: 100,
		h: 100
	}

	ctx.fillRect(
		rect.x,
		rect.y,
		rect.w,
		rect.h
	);

	oC.onmousedown = function({
		clientX,
		clientY
	}) {
		var {
			x,
			y,
			w,
			h
		} = rect;

		var disX = clientX - x;
		var disY = clientY - y;

		if (
			clientX > x &&
			clientX < x + w &&
			clientY > y &&
			clientY < y + h
		) {
			oC.onmousemove = function({
				clientX,
				clientY
			}) {

				ctx.clearRect(0, 0, oC.width, oC.height)  // **先清空画布再画

				var deltaX = clientX - disX;
				var deltaY = clientY - disY;

				rect.x = deltaX;
				rect.y = deltaY;

				ctx.fillRect(
					rect.x,
					rect.y,
					rect.w,
					rect.h
				);
			}

			oC.onmouseup = function() {
				oC.onmousemove = null;
				oC.onmouseup = null;
			}
		}
	}
</script>
```


![应用_canvas内长方形拖拽.gif](http://upload-images.jianshu.io/upload_images/2125655-fc21ecb61e9e36f1.gif?imageMogr2/auto-orient/strip)


### (5) 应用 canvas内圆形拖拽
```
<canvas width="800" height="600"></canvas>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');

	var circle = {
		x: 50,
		y: 50,
		r: 50
	}

	ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI, false);

	ctx.fill();

	oC.onmousedown = function({
		clientX,
		clientY
	}) {
		var {
			x,
			y,
			r
		} = circle;

		var disX = clientX - x;
		var disY = clientY - y;

		if (
			ctx.isPointInPath(clientX, clientY)  // 利用isPointInPath函数
		) {
			oC.onmousemove = function({
				clientX,
				clientY
			}) {
				ctx.clearRect(0, 0, oC.width, oC.height);
				ctx.beginPath();

				var deltaX = clientX - disX;
				var deltaY = clientY - disY;

				circle.x = deltaX;
				circle.y = deltaY;

				ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI, false);
				ctx.fill();
			}

			oC.onmouseup = function() {
				oC.onmousemove = null;
				oC.onmouseup = null;
			}
		}
	}
</script>

```


![应用_canvas内圆形拖拽.gif](http://upload-images.jianshu.io/upload_images/2125655-4cd05bd21c0e6ad7.gif?imageMogr2/auto-orient/strip)



### (6) 应用 下载canvas绘图
```
<canvas width="600" height="400"></canvas>
<br>
<button>Download</button>
<script>
	var oC = document.querySelector('canvas');
	var ctx = oC.getContext('2d');
	var oBtn = document.querySelector('button');

	var data = [
		rnd(100, 1000),
		rnd(100, 1000),
		rnd(100, 1000),
		rnd(100, 1000),
		rnd(100, 1000)
	]

	var start = 0;

	var sum = sumUp(data);

	data.forEach(function(number, index) {
		var color = `rgb(${rnd(0,255)},${rnd(0,255)},${rnd(0,255)})`;

		var delta = number / sum * 2 * Math.PI;

		ctx.fillStyle = color;

		ctx.beginPath();

		ctx.moveTo(300, 200)
		ctx.arc(300, 200, 100, start, start + delta, false);
		ctx.lineTo(300, 200)

		ctx.fill();

		start = start + delta;
	})

	function sumUp(array) {
		var sum = 0;

		array.forEach(function(n) {
			sum += n
		})

		return sum;
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n);
	}

	// **下载canvas图片
	oBtn.onclick = function() {
		var oA = document.createElement('a');
		oA.href = oC.toDataURL();
		oA.download = '默认命名';
		// oA.download = fileName.value ? fileName.value : '默认命名' + '.png';

		oA.click();
	}
</script>
```

![应用_下载canvas绘图.gif](http://upload-images.jianshu.io/upload_images/2125655-bd093cf7df7b2bb3.gif?imageMogr2/auto-orient/strip)


### (7) 应用 canvas运动回调
```
<script>
	function loadStatics(statics, callback) {
		var count = 0;

		statics.forEach(function(path, index) {
			var oImage = new Image();
			oImage.src = `img/${path}.png`

			resources[path] = oImage;

			oImage.onload = function() {

				count++

				if (count == statics.length) {
					callback && callback();
				}
			}
		})
	}

	function d2a(d) {
		return d / 180 * Math.PI
	}

	function a2d(a) {
		return a / Math.PI * 180
	}

	function rnd(n, m) {
		return parseInt(Math.random() * (m - n) + n)
	}

	function rndSign() {
		return Math.random() < 0.5 ? -1 : 1
	}
</script>
```

### (8) canvas框架 jCanvaScript.js
[jCanvaScript.js](http://jcscript.com/)

示例
```
<canvas id="c1" width="500" height="500"></canvas>
<script src="libs/jCanvaScript.1.5.18.min.js"></script>
<script>
    var idCanvas = "c1";
    onload_1();

    var interval_1 = 0;

    function startShow() {
        var r = Math.floor(Math.random() * (254)),
            g = Math.floor(Math.random() * (254)),
            b = Math.floor(Math.random() * (254)),
            x = Math.floor(Math.random() * (439)),
            y = Math.floor(Math.random() * (554)),
            color = "rgba(" + r + ", " + g + ", " + b + ", 0.5)",
            filled = true,
            radius = 1;
        jc.circle(x, y, radius, color, filled)
            .animate({
                radius: 100,
                opacity: 0
            }, 1500, function() {
                this.del();
            });
    }

    function onload_1() {
        jc.start(idCanvas, true);
        interval_1 = setInterval(startShow, 200);
    }

    function start_1(idCanvas) {
        if (interval_1) return;
        onload_1();
    }

    function stop_1(idCanvas) {
        clearInterval(interval_1);
        interval_1 = 0;
        jc.clear(idCanvas);
    }
</script>
```

![canvas框架 jCanvaScript.gif](http://upload-images.jianshu.io/upload_images/2125655-0e38ec1c6db6d023.gif?imageMogr2/auto-orient/strip)

---

- H5内联SVG
	- \(1\) 位图 && 矢量图
	- \(2\) SVG使用
	- \(3\) SVG梗概
	- \(4\) SVG应用

---

## 14. H5内联SVG

SVG(Scalable Vector Graphic 可伸缩矢量图形)
VML(The Vector Markup Language  矢量可标记语言)

> SVG 使用 XML 格式定义图形

### (1) 位图 && 矢量图
- 位图 -> 由像素点构成的图形
  - 优点: 色彩信息相当复杂
  - 缺点: 失真、体积大

- 矢量图 -> 由数学语言描述出的图形
  - 优点: 体积小不失真
  - 缺点: 色彩信息单一，图形简单

### (2) SVG使用
1.
```
<img src="xxx.svg">
```
```
<?xml version="1.0" encoding="UTF-8"?>
<svg width="801px" height="792px" viewBox="0 0 801 792" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	...
</svg>
```

2.
```
<svg>
	<rect x="20" y="20" rx="20" ry="20" width="250" height="250" style="fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9"/>
</svg>
```

3.
```
<svg width="200" height="200"></svg>
<script>
	var oSvg = document.querySelector('svg');
	var oLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');

	oLine.setAttribute('x1', '10');
	oLine.setAttribute('y1', '10');
	oLine.setAttribute('x2', '100');
	oLine.setAttribute('y2', '100');
	oLine.setAttribute('stroke', 'green');

	oSvg.appendChild(oLine);
</script>
```


### (3) SVG梗概
- `<rect>`     矩形
  eg: `<rect x="20" y="20" rx="20" ry="20" width="250" height="250" style="fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9"/>`
  - x, y  位置
  - width, height  宽高
  - rx, ry  圆角矩形
  - style  css属性

- `<circle>`   圆形
  eg: `<circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red"/>`
  - cx, cy  圆心坐标 默认(0, 0)
  - r  半径

- `<ellipse>`  椭圆
  eg: `<ellipse cx="300" cy="150" rx="200" ry="80"style="fill:rgb(200,100,50);stroke:rgb(0,0,100);stroke-width:2"/>`
  - cx, cy  圆心坐标
  - rx, ry  水平/垂直半径

- `<line>`     线
  eg: `<line x1="0" y1="0" x2="300" y2="300"style="stroke:rgb(99,99,99);stroke-width:2"/>`
  - x1, y1  开始坐标
  - x2, y2  结束坐标

- `<polyline>` 折线
  eg: `<polyline points="0,0 0,20 20,20 20,40 40,40 40,60"style="fill:white;stroke:red;stroke-width:2"/>`
  - points 每个折点的x,y坐标

- `<polygon>`  多边形
  eg: `<polygon points="220,100 300,210 170,250"style="fill:#cccccc;stroke:#000000;stroke-width:1"/>`
  - points  每个角的x,y坐标(自动闭合)

- `<path>`     路径
  eg: `<path d="M250 150 L150 350 L350 350 Z" style="#ccc;"/>`  **大写表示绝对定位，小写表示相对定位。**
  - M  moveto
  - L  lineto
  - H  horizontal lineto
  - V  vertical lineto
  - C  curveto
  - S  smooth curveto
  - Q  quadratic Belzier curve
  - T  smooth quadratic Belzier curveto
  - A  elliptical Arc
  - Z  closepath


- `<filter>`    高斯滤镜  **<filter> 标签必须嵌套在 <defs> 标签内。**  definitions 定义
  eg: `<defs><filter id="Gaussian_Blur"><feGaussianBlur in="SourceGraphic" stdDeviation="3" /></filter></defs>`
  `<ellipse cx="200" cy="150" rx="70" ry="40" style="fill:#ff0000;stroke:#000000;stroke-width:2;filter:url(#Gaussian_Blur)"/>`
  - <filter>id  定义名称

  - filter:url(#xxx)  链接滤镜

- `<linearGradient>`  线性渐变  **<linearGradient> 标签必须嵌套在 <defs> 的内部。**
  eg: `<defs><linearGradient id="orange_red" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1"/><stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1"/></linearGradient></defs>`
  `<ellipse cx="200" cy="190" rx="85" ry="55" style="fill:url(#orange_red)"/>`
  - <linearGradient>id  定义名称
  - <linearGradient>x1,y1  渐变开始位置
  - <linearGradient>x2,y2  渐变结束位置
  - <stop>  渐变颜色

  - fill:url(#xxx)  链接渐变

- `<radialGradient>`  径向渐变  **<radialGradient> 标签必须嵌套在 <defs> 中。**
  eg: `<defs><radialGradient id="grey_blue" cx="50%" cy="50%" r="50%"fx="50%" fy="50%"><stop offset="0%" style="stop-color:rgb(200,200,200);stop-opacity:0"/><stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1"/></radialGradient></defs>`
  `<ellipse cx="230" cy="200" rx="110" ry="100" style="fill:url(#grey_blue)"/>`
  - <radialGradient>id  定义名称
  - <radialGradient>cx,cy,r  外圈
  - <radialGradient>fx,fy  内圈
  - <stop>  渐变颜色

  - fill:url(#xxx)  链接渐变

### (4) SVG应用

[纯CSS实现帅气的SVG路径描边动画效果](http://www.zhangxinxu.com/wordpress/2014/04/animateion-line-drawing-svg-path-%E5%8A%A8%E7%94%BB-%E8%B7%AF%E5%BE%84/)

- `stroke-dasharray`  各虚线长度
- `stroke-dashoffset`  虚线的起始偏移

获取路径长度
```
<script>
	var path = document.querySelector('path');
	var length = path.getTotalLength();
</script>
```

#### 2017

``` css
<style>
	.one {
		stroke-dasharray: 600;
		stroke-dashoffset: 600;
		animation: ani 2s forwards;
	}
	.two {
		stroke-dasharray: 600;
		stroke-dashoffset: 600;
		animation: ani 1.8s forwards 0.2s;
	}
	.three {
		stroke-dasharray: 600;
		stroke-dashoffset: 600;
		animation: ani 1.6s forwards 0.4s;
	}
	@keyframes ani {
		to {
			stroke-dashoffset: 0;
		}
	}
</style>
```

三个颜色变换

``` html
<svg width="800" height="600">
	<!-- one -->
	<path d="M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563" class="one" stroke="#4A4A4A" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z" class="one"  stroke="#4A4A4A" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449" class="one"  stroke="#4A4A4A" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696" class="one"  stroke="#4A4A4A" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<!-- two -->
	<path d="M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563" class="two" stroke="#029df9" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z" class="two" stroke="#029df9" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449" class="two" stroke="#029df9" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696" class="two" stroke="#029df9" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<!-- three -->
	<path d="M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563" class="three" stroke="#90da32" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z" class="three" stroke="#90da32" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449" class="three" stroke="#90da32" stroke-width="8" fill="none" stroke-lineCap="round"></path>
	<path d="M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696" class="three" stroke="#90da32" stroke-width="8" fill="none" stroke-lineCap="round"></path>
</svg>
```


![应用_svg 2017.gif](http://upload-images.jianshu.io/upload_images/2125655-cf23014776dbd171.gif?imageMogr2/auto-orient/strip)


### (5) 矢量图形库 Raphael.js
[Raphaël Reference](http://dmitrybaranovskiy.github.io/raphael/)

示例
```
<script src="libs/raphael.min.js"></script>
<script>
	// Creates canvas 320 × 200 at 10, 50
	var paper = Raphael(10, 50, 320, 200);

	// Creates circle at x = 50, y = 40, with radius 10
	var circle = paper.circle(50, 40, 10);
	// Sets the fill attribute of the circle to red (#f00)
	circle.attr("fill", "#f00");

	// Sets the stroke attribute of the circle to white
	circle.attr("stroke", "#fff");

	circle.click(function() {
		this.animate({
			fill: '#fe0',
			y: 100
		}, 500, 'bounce');
	})

	// circle.drag(function(dx,dy){
	// 	this.attr({
	// 		x: x + dx,
	// 		y: y + dy
	// 	})
	// },function(){
	// 	x = this.attr('x')
	// 	y = this.attr('y')
	// })
</script>
```

![应用_svg矢量图形库 Raphael.gif](http://upload-images.jianshu.io/upload_images/2125655-3d99bfc6dd83f68f.gif?imageMogr2/auto-orient/strip)


---

#blog28 (杂技)
<!-- MarkdownTOC -->

- 1. toString\(\) && valueOf\(\)
- 2. JSON stringify & parse
- 3. +new Date\(\)
- 4. Array.prototype.slice.call\(arguments, 0\) 剖析
- 5. JS Bridge建立Native与H5间通信
    - Hybrid通信原理
    - JS Bridge

<!-- /MarkdownTOC -->

有些平时碰到的很零碎的东西我就随便插入到这个章节里了。

## 1. toString() && valueOf()

- toString() 把一个逻辑值转换为字符串，并返回结果。

- valueOf()  返回Boolean对象的原始值

> **源自知乎**
这两个方法一般是交由JS去隐式调用，以满足不同的运算情况。

> 在数值运算里，会优先调用valueOf()，如a+b；
在字符串运算里，会优先调用toString()，如alert(c)。

``` javascript
<script>
    // 该示例来源于脚本之家
    var bbb = {
        i: 10,
        toString: function() {
            console.log('toString');
            return this.i;
        },
        valueOf: function() {
            console.log('valueOf');
            return this.i;
        }
    }

    alert(bbb); // 10 toString
    alert(+bbb); // 10 valueOf
    alert('' + bbb); // 10 valueOf
    alert(String(bbb)); // 10 toString
    alert(Number(bbb)); // 10 valueOf
    alert(bbb == '10'); // true valueOf
    alert(bbb === '10'); // false
</script>
```

``` javascript
<script>
    console.log({
        valueOf: function() {
            return 20;
        }
    } * {
        valueOf: function() {
            return 30;
        }
    });     // 600
</script>
```

## 2. JSON stringify & parse

[json2.js - 引入解决IE7及以下版本JSON未定义问题。](https://github.com/douglascrockford/JSON-js/blob/master/json2.js)

1. JSON.stringify(object);  **对象 -> 字符串**  将对象字符串序列化成标准JSON字符串

eg: `{a:1,b:2}`  ->  `"{"a":1,"b":2}"`

2. JSON.parse(str);  **字符串 -> json对象**  将字符串序列化成对象

`{"name":"wangchloe","age":"22"}`  ->
```
{
    age: "22",
    name: "wangchloe",
    _proto: Object
}
```

``` html
<a href="https://www.baidu.com/" attr1='13'>baidu.com</a>
```

``` javascript
<script>
    var oA = document.querySelector('a');
    console.log(oA.getAttribute('attr1'));  // 13

    oA.setAttribute('attr1', '14');
    var num = oA.getAttribute('attr1');

    console.log(oA.getAttribute('attr1'));  // 14
    console.log(typeof number);  // string 直接设置自定义属性只能得到string类型

    oA.setAttribute('attr1', JSON.stringify({name: 14}));

    var num2 = oA.getAttribute('attr1');

    console.log(num2);  // {"name": "14"}
    console.log(JSON.parse(num2));
    // Object {name: "14"}
    //     name: "14"
    //     -> _proto_: Object

    console.log(JSON.parse(num2).name);  // 14
    console.log(typeof JSON.parse(num2).name);  // number JSON转化得到了真正类型
</script>
```

## 3. +new Date()
```
<script>
    s = new Date().toString();
    // "Wed May 17 2017 11:00:16 GMT+0800 (中国标准时间)"

    t = (+new Date()).toString();
    // "1494990039861"
    // +new Date(); 等同于 new Date().getTime(); 简略写法，得到毫秒
</script>
```

## 4. Array.prototype.slice.call(arguments, 0) 剖析

将具有length属性的对象转成数组

```
<script>
// array.js slice的内部实现
function slice(start, end) {
    var len = ToUint32(this.length),
        result = [];
    for (var i = start; i < end; i++) {
        result.push(this[i]);
    }
    return result;
}
</script>
```

```
<script>
    // 传入arguments类数组，调用Array.prototype.slice原型方法
    // 并用call()方法，将作用域限定在arguments中
    // 这里Array.prototype就可以理解为arguments
    // 参数0为slice()方法的第一个参数，即开始位置索引，返回整个数组。
    Array.prototype.slice.call(arguments, 0);
</script>
```

## 5. JS Bridge建立Native与H5间通信

### Hybrid通信原理
背景：原生APP开发中有一个webview的组件(Android中是webview,iOS7以下有UIWebview,7以上有WKWebview),这个组件可以加载Html文件。

- IOS
  - Object-C可直接调用js，只需调用stringByEvaluatingJavaScriptFromString即可，可直接获取js返回值。
  - js不可直接调用Object-C，利用 shouldStartLoadWithRequest，需拦截每个url，对指定的schema进行拦截做相应的本地方法。

- Android
  - Java可直接调用js，但不可直接获取js返回值。
  - Java注册addJavascriptInterface 后，js可直接调用Native的接口，并获取Native的返回值。[让Java跟Javascript更加亲密](http://www.alloyteam.com/2013/02/rang-java-gen-javascript-geng-jia-qin-mi/)
  - 通过 shouldOverrideUrlLoading，也还是拦截Web的所有URL请求来达到通信的目的。


**基础通信存在以下问题**

- Android4.2以下,addJavascriptInterface方式有安全漏洞

- iOS7以下,js无法调用Native

### JS Bridge

- url scheme交互方式是一套现有的成熟方案，可以完美兼容各种版本，不存在上述问题。

通过JSBridge(JS和Native通信机制),H5页面可以调用Native的api,Native也可调用H5页面的方法或者通知H5页面回调。

![JSBridge的核心原理](https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_1.png?_=5931322)

原理：
（1）初始化创建的一个style.display=none 的iframe,并将iframe.src设置为自有协议，每次js需要与Native通信时，js端主动调用iframe.src即可，Native收到请求通知后，反向调用fetchQueue(可见源码)获取消息内容；若Native需要与js通信，直接调用js，并获取返回值

（2）
- IOS
js->Native：js将要发送的消息存放在js端->调用iframe.src，触发通知Native->Native拦截请求，调用js bridge里面的fetchQueue并获取返回的消息内容，处理消息->将需要返回的数据通过直接调用js的方式，让js处理

- Android
js->Native: 通过 shouldOverrideUrlLoading 携带Js的返回值
（3）Native->js: Native可直接调用Js并获取返回的内容


```
<script>
function bridgeApp(protocol) {
    var iframe = document.createElement("iframe");
    var iframeStyle = document.createAttribute("style");
    var iframeSrc = document.createAttribute("src");

    iframeStyle.nodeValue = "display:none;width:0;height:0;";
    iframeSrc.nodeValue = protocol;
    iframe.setAttributeNode(iframeStyle);
    iframe.setAttributeNode(iframeSrc);
    document.body.appendChild(iframe);

    setTimeout(function() {
        document.body.removeChild(iframe);
    }, 250);
}
</script>
```


[连续五篇讲述Hybrid以及JSBridge解决方案](http://www.cnblogs.com/dailc/p/5930231.html)

---

#blog29 (css3)
<!-- MarkdownTOC -->

- 1. CSS3老版浏览器兼容处理
- 2. CSS3新增选择器
    - 属性选择器
    - 结构选择器
- 3. CSS3新增属性
    - 色值透明度 rgba
    - 文字阴影 text-shadow
    - 文字省略 text-overflow
    - 圆角 border-radius
    - 盒子阴影 box-shadow
    - 变换 transform \(搭配transition使用效果更佳\)
    - 过渡 transition
    - 动画 animation
    - 视角 perspectiv
    - 文字转向 direction
    - 遮罩 -webkit-mask
    - 倒影 box-reflect
    - 文字阴影 text-shadow
    - 调整尺寸 resize
    - background-image内的一些属性
    - background相关属性
    - 滤镜 filter
- 4. CSS3媒体查询 media
    - 媒体类型
    - 媒体功能
    - meida大全

<!-- /MarkdownTOC -->

## 1. CSS3老版浏览器兼容处理

- css
  - -webkit-transition: 1s;
  - -moz-transition: 1s;
  - -o-transition: 1s;
  - transition: 1s;

- js(去掉-，首字母大写)
  - WebkitTransition
  - MozTransition
  - OTransition

## 2. CSS3新增选择器

### 属性选择器
**兼容：IE7+**

- E[attr]

- E[attr="value"]  匹配属性  **只含一个属性值**

- E[attr~="value"]  匹配空格隔开的单词  attr属性值包含value

- E[attr^="value"]  匹配开头  attr属性值以value开头

- E[attr$="value"]  匹配结尾  attr属性值以value结束

- E[attr*="value"]   attr属性值包含value字符

- E[attr|="value"]  匹配value-开头  attr属性值是value或者"value-"开头  **只含一个属性值**


``` css
<style>
    p[attr1] {
        background: #f00;
    }
    p[attr1=a] {
        background: #0ff;
    }
    p[attr1~=c] {
        background: #00f;
    }
    p[attr1^=e] {
        background: #ff0;
    }
    p[attr1$=g] {
        background: #f0f;
    }
    p[attr1*=i] {
        background: #0f0;
    }
    p[attr1|=k] {
        background: #fff;
    }
</style>
```

``` html
    <strong>E[attr="value"] **只含一个属性值**</strong>
    <p attr1="a">attr1="a"</p>
    <p attr1="b a">attr1="b a"</p>
    <hr/>
    <strong>E[attr~="value"] attr属性值包含value</strong>
    <p attr1="c">attr1="c"</p>
    <p attr1="d c">attr1="d c"</p>
    <hr/>
    <strong>E[attr^="value"] attr属性值以value开头</strong>
    <p attr1="e">attr1="e"</p>
    <p attr1="f ef">attr1="f ef"</p>
    <p attr1="ef f">attr1="ef f"</p>
    <hr/>
    <strong>E[attr$="value"] attr属性值以value结束</strong>
    <p attr1="g gh">attr1="g gh"</p>
    <p attr1="h hg">attr1="h hg"</p>
    <hr/>
    <strong>E[attr*="value"] attr属性值包含value字符</strong>
    <p attr1="i">attr1="i"</p>
    <p attr1="j jij">attr1="j jij"</p>
    <hr/>
    <strong>E[attr|="value"] attr属性值是value或者"value-"开头  **只含一个属性值**</strong>
    <p attr1="k">attr1="k"</p>
    <p attr1="l k">attr1="l k"</p>
    <p attr1="m k-m">attr1="m k-m"</p>
    <p attr1="k-m">attr1="k-m"</p>
```

![css3属性选择器](http://img.blog.csdn.net/20170110165816536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdzk1MDkxNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 结构选择器
**兼容：IE9+**

**下标索引从1开始**

- `:nth-child(n) ` 找当前节点的父节点下的第n个子节点，**当且仅当该子节点与当前节点的类型相符时有效**

- `:nth-last-child(n)`  找当前节点的父节点下的倒数第n个子节点，**当且仅当该子节点与当前节点的类型相符时有效**

- `:nth-of-type(n)` 找当前节点的父节点下的第n个与当前节点的类型相符的子节点

- `:nth-last-of-type(n)` 找当前节点的父节点下的倒数第n个与当前节点的类型相符的子节点

- `:first-child`  即 :nth-child(1)

- `:last-child`  即 :nth-last-child(1)

- `:first-of-type`  即 :nth-of-type(1)

- `:last-of-type`  即 :nth-last-of-type(1)

- `:only-child`   当前节点的父节点下只有一个子节点时有效

- `:only-of-type` 当前节点的父节点下与当前节点的类型相符的子节点只有一个时有效，可有多个其他类型子节点

---

- `:target`  设置跳转锚点属性  <a href="#div1"></a> -> <div id="div1"></div>

- `:disabled`  不可点击的表单控件

- `:enabled`   可点击的表单控件

- `:checked`   选中的checkbox/radio

- `A~B`        A元素后的第一个类型为B的兄弟节点  **应用：模拟checkbox**

- `:first-line` 当前节点的第一行

- `:first-letter` 当前节点的第一个字符

- `:not(x)`      不匹配x时有效

---

伪元素

- `::selection`  在当前节点内选中文字时有效

- `::before`     搭配content使用，在当前节点内容最前面插入content **不增加DOM**

- `::after`     搭配content使用，在当前节点内容最后面插入content **不增加DOM**

## 3. CSS3新增属性

### 色值透明度 rgba
之前的opacity改变背景色透明度时同时改变文字颜色透明度

rgba可实现**只改变背景色透明度**

### 文字阴影 text-shadow

text-shadow: [x轴 y轴 模糊度 弥散度 颜色]

- x轴：正值 -> 向右 负值 -> 向左

- y轴：正值 -> 向下 负值 -> 向上

阴影叠加

### 文字省略 text-overflow
``` css
<style>
    .ell {
        white-space: nowrap;  /* 不允许换行 */
        overflow: hidden;     /* 超出隐藏 */
        text-overflow: ellipsis;  /* 超出显示省略号，默认为clip(无省略号) */
    }
</style>
```

### 圆角 border-radius
`border-radius: 10px 20px 30px 40px` -> 左上角起顺时针经过的角的顺序

`border-radius: 10px 20px 30px 40px / 30px 10px 40px 20px`  **/** -> 分离x/y轴方向半径

### 盒子阴影 box-shadow
`box-shadow: [inset]  10px   20px   30px      40px   black;`

             [内阴影] x位移 y位移 模糊半径  弥散半径 颜色

多边框实例
``` css
<style>
    #box{
        width: 100px;
        height: 100px;
        box-shadow: 0 0 0 10px black,
                    0 0 0 20px green,
                    0 0 0 30px pink,
                    0 0 0 40px purple,
                    0 0 0 50px orange,
                    0 0 0 60px khaki,
                    0 0 0 70px indigo,
                    0 0 0 80px plum,
                    0 0 0 90px violet;
        margin: 200px auto;
    }
</style>
```

### 变换 transform (搭配transition使用效果更佳)

**以下属性可以一同使用**

- rotate([deg])  旋转

`transform: rotate(30deg);`  正向旋转30度
`tansform: rotate(0.785rad);`  正向旋转0.785弧度
`tansform: rotateX|Y|Z(45deg);`

> 角度转弧度 π/180×角度
弧度变角度 180/π×弧度

transofrm-origin 旋转中心

eg:
`transofrm-origin: left|top|bottom|right|center(默认);`
`transofrm-origin: left top|left bottom|right top|left center|center bottom;`
`transofrm-origin: -120px -120px;`

- translate(x, y)  偏移
x>0 右偏移
x<0 左偏移
y>0 下偏移
y<0 上偏移

`transform: translate(-30px, -40px);` 左偏移30px, 右偏移40px
`transform: translateX|Y|Z(-30px);`

- scale(s); 放大/缩小

`transform: scale(0.2)` 宽高缩小至0.2倍的大小
`transform: scale(0.2, 1)` 宽度缩小至0.2倍大小，高度不变
`transform: scaleX|scaleY(0.2)`

- skew([deg]) 倾斜

`transform: skew(20deg)` 水平向左倾斜20度
`transform: skewX(20deg)` 水平向左倾斜20度
`transform: skewY(20deg)` 垂直向上倾斜20度
`transform: skew(20deg, 20deg)` 水平向左倾斜20度，垂直向上倾斜20度

- 关于多属性

> **transform多属性时从后向前解析**

eg:
`transform: rotate(45deg) scale(2,1);`  先横向放大再旋转
`transform: scale(2,1) rotate(45deg);`  先旋转再横向放大

### 过渡 transition
transition 属性是一个简写属性，用于设置**四个过渡属性**：

- transition-property 设置过渡效果的 CSS 属性的名称

- transition-duration 完成过渡效果需要多少秒

- transition-timing-function 速度效果的速度曲线
    - linear      匀速等于 cubic-bezier(0,0,1,1)
    - ease        慢速开始，然后变快，然后慢速结束 cubic-bezier(0.25,0.1,0.25,1)
    - ease-in     慢速开始 等于 cubic-bezier(0.42,0,1,1)
    - ease-out    慢速结束 等于 cubic-bezier(0,0,0.58,1)
    - ease-in-out 慢速开始和结束 等于 cubic-bezier(0.42,0,0.58,1)
    - cubic-bezier(n,n,n,n)

- transition-delay 过渡效果何时开始

eg:

``` css
<style>
    #box{
        width: 200px;
        height: 200px;
        background-color: green;
        transition: 1s width cubic-bezier(1, 1.7, 0, 1.54) 1s;  /* 1s后由400px过渡到200px */
    }
    #box:active{
        width: 400px;
        transition: 0s; /* 按下0s后变为400px */
    }
</style>
```

### 动画 animation
animation 属性是一个简写属性，用于设置**六个动画属性**：

- animation-name 需要绑定到选择器的 keyframe 名称

- animation-duration 完成动画所花费的时间

- animation-timing-function 动画的速度曲线

- animation-delay 在动画开始之前的延迟

- animation-iteration-count 动画应该播放的次数
    - n        播放次数
    - infinite 无限次播放

- animation-direction 是否应该轮流反向播放动画
    - alternate 轮流反向播放
    - reverse   反向播放
    - alternate-reverse 反向交替播放

- animation-fill-mode 结束状态
    - forwards  停留在结束状态
    - backwards 返回原始状态

- animation-play-state 暂停动画
    - paused   动画已暂停
    - running 动画正在播放

keyframe 关键帧
``` css
<style>
    @keyframes name{
        from{

        }
        to{

        }

        10%{

        }
        20%{

        }
        100%{

        }
    }
</style>
```

### 视角 perspectiv
指定观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。

[小tip: 纯CSS实现视差滚动效果](http://www.zhangxinxu.com/wordpress/2015/03/css-only-parallax-effect/)
[好吧，CSS3 3D transform变换，不过如此！](http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/)

perspective属性有两种书写形式：

- 用在舞台元素上（动画元素们的共同父辈元素）
  - `perspective:1px;` -> 给当前元素的子集增加视角

- 用在当前动画元素上，与transform的其他属性写在一起
  - `transform:perspective(800px) (perspective必须写在最前面) rotate...` -> 给当前元素增加视角


开启3D空间

`transform-style:preserve-3d;`  加给3D变化元素父集，不可继承

```
<style>
/*小tip: 纯CSS实现视差滚动效果*/
.container {
    /* 滚动容器 */
    perspective: 1px; 
    padding: 0; height: calc(100vh - 300px); overflow: auto;
}
.box {
    /* 视差元素的父级需要3D视角 */
    height: 1280px;
    transform-style: preserve-3d;
    position: relative;
}
.background {
    /* 滚动比较慢的背景元素 */
    position: absolute; left: 50%;
    transform: translate3D(-50%, -120px, -1px) scale(2);
}
</style>
```

### 文字转向 direction
需配合`unicode-bidi`使用

```
<style>
    /*right to left*/
    .rtl{
        direction:rtl;
        unicode-bidi:bidi-override;
    }
</style>
```

### 遮罩 -webkit-mask

```
<style>
.mask{
    -webkit-mask: url(xxx.jpg); /*背景按mask图片大小显示*/
    -webkit-mask:linear-gradient(rgba(0,0,0,1)), to(rgba(0,0,0,0); /*背景按渐变遮罩显示*/
}

</style>
```

[webkit下神奇的图层蒙版效果](http://wangchloe.vip/Demo/CSS3/mask)

![webkit下神奇的图层蒙版效果.gif](http://upload-images.jianshu.io/upload_images/2125655-57bad81f61dd6241.gif?imageMogr2/auto-orient/strip)

```
<style>

    body {
        margin: 0;
        padding: 0;
        background-color: #000;
    }
    #box {
        position: absolute;
        top:0;
        right:0;
        bottom:0;
        left:0;
        background: url(img/2.jpg) no-repeat;
        background-size: cover;
        -webkit-mask: -webkit-radial-gradient(300px 300px, circle, #f00 100px, rgba(0, 0, 0, .3) 20px);
    }

</style>
```
```
<div id="box"></div>
```
```
<script>

    var oBox = document.querySelector('#box');

    oBox.onmousemove = function({
        clientX,
        clientY
    }) {

        this.style.WebkitMask = `-webkit-radial-gradient(${
            clientX - oBox.offsetLeft
        }px ${
            clientY - oBox.offsetTop
        }px,circle,#f00 100px,rgba(0,0,0,.3) 20px)`

    }

</script>
```

### 倒影 box-reflect
[-webkit-box-reflect各个属性值效果演示](http://www.zhangxinxu.com/study/201608/-webkit-box-reflect.html)

box-reflect：none | <direction> <offset>? <mask-box-image>?

方向<direction> = above | below | left | right
间隔<offset> = <length> | <percentage>
遮罩<mask-box-image> = none | <url> | <linear-gradient> | <radial-gradient> | <repeating-linear-gradient> | <repeating-radial-gradient>

### 文字阴影 text-shadow
`text-shadow: x-shadow y-shadow [blur] [color];`

水平阴影位置 垂直阴影位置 模糊的距离 阴影颜色

### 调整尺寸 resize
是否允许用户调整元素的尺寸

```
resize: none;          用户无法调整元素的尺寸
resize: both;          用户可调整元素的高度和宽度
resize: horizontal;    用户可调整元素的宽度
resize: vertical;      用户可调整元素的高度
```

### background-image内的一些属性

#### linear-gradient 线性渐变

- direction:
to top    ->    0deg   -> 从下到上
to right  ->    90deg  -> 从左到右
to bottom ->    180deg -> 从上到下（默认值）
to left   ->    270deg -> 从右到左
to top left  -> 右上角到左上角（斜对角）
to top right -> 左下角到右上角（斜对角）

eg:
`background-image: linear-gradient(red,blue);`
`background-image: linear-gradient(250deg,red,blue);`
`background-image: linear-gradient(red,orange,yellow,green,blue,indigo,violet);`
`background-image: linear-gradient(red 50%,blue 50%);` 跳变
`background-image: linear-gradient(90deg,blue 33.33333%,white 33.33333%,white 66.66666%,red 66.66666%,red 100%);` 0~1/3是蓝色 1/3~2/3是白色 2/3~1是红色


#### radial-gradient 径向渐变

background:radial-gradient(position ,shape size, start-color, stop-color);

- position 圆心位置

- shape
circle  定义径向渐变为“圆形”
ellipse 定义径向渐变为“椭圆形”

- size
closet-side 指定径向渐变的半径长度为从圆心到离圆心最近的边
closest-corner  指定径向渐变的半径长度为从圆心到离圆心最近的角
farthest-side   指定径向渐变的半径长度为从圆心到离圆心最远的边
farthest-corner 指定径向渐变的半径长度为从圆心到离圆心最远的角

eg:
`background-image: radial-gradient(red,blue);` 内圆红色，外框蓝色
`background-image: radial-gradient(red,orange,yellow,green,blue,indigo,violet);border-radius: 50%;`
`background-image: radial-gradient(circle,red 30%,white 30%);`
`background-image: -webkit-radial-gradient(100px 100px,circle farthest-corner,red,blue);`
`background-image: -webkit-radial-gradient(100px 100px,circle farthest-side,red,blue);`
`background-image: -webkit-radial-gradient(150px 100px,200px 80px,red,blue);`

#### repeating-linear-gradient 重复渐变
eg:
`background-image: repeating-linear-gradient(red,blue 20%);`

### background相关属性

####background-origin 相对于内容框来定位背景图像

`background-origin: border-box;`  相对于边框盒来定位背景图像
`background-origin: content-box;` 相对于内容框来定位背景图像
`background-origin: padding-box;` 相对于内边距框来定位背景图像

#### background-clip 裁剪背景图片

`background-clip: border-box;`  相对于边框盒来定位背景图像
`background-clip: content-box;` 相对于内容框来定位背景图像
`background-clip: padding-box;` 相对于内边距框来定位背景图像

[webkit下神奇的文字蒙版效果](http://wangchloe.vip/Demo/CSS3/mask2)

![webkit下神奇的文字蒙版效果.PNG](http://upload-images.jianshu.io/upload_images/2125655-8fdaedb33502cb11.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
<style>

    #box {
        width: 200px;
        height: 200px;
        background: url(img/1.jpg);
        background-size: cover;
        -webkit-background-clip: text;
        font-size: 200px;
        font-weight: bolder;
        color: rgba(0, 0, 0, 0.1);
    }

</style>

```
```
    <div id="box">W</div>
```

#### background-attachment
`background-attachment: scroll` 默认值。背景图像会随着页面其余部分的滚动而移动。
`background-attachment: fixed`  当页面的其余部分滚动时，背景图像不会移动。

[图片覆盖切换效果](http://wangchloe.vip/Demo/CSS3/background-attachment)

![图片覆盖切换.gif](http://upload-images.jianshu.io/upload_images/2125655-16406daa0f269fae.gif?imageMogr2/auto-orient/strip)

#### background-size 背景图像尺寸
`background-size: 3em, 25%;`  自定义背景图像尺寸
`background-size: cover;`     使背景图像完全覆盖背景区域(**图像可能被裁剪**)
`background-size: contain;`   完全包含背景图(**no-repeat背景区域可能有空白**)

#### background-position 背景图像定位
常用于雪碧图

`background-position: center|top|right|bottom|left`
`background-position: 20px 20%`

### 滤镜 filter
[CSS3 Filter的十种特效](http://www.w3cplus.com/css3/ten-effects-with-css3-filter)

- blur 模糊
eg:
`filter: blur(20px);`

- drop-shadow 阴影
[CSS3 filter:drop-shadow滤镜与box-shadow区别应用](http://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/)
eg:
`filter: drop-shadow(100px 1px 2px black);`

- invert 反色
eg:
`filter: invert(0.7);`

- brightness 亮度
eg:
`filter: brightness(.5);`

- sepia 褐色
eg:
`filter: sepia(1);`

- hue-rotate 色相旋转
eg:
`filter: hue-rotate(30deg);`

- saturate 饱和度
eg:
`filter: saturate(10);`

## 4. CSS3媒体查询 media

### 媒体类型
- `all` 用于所有设备

- `screen` 用于电脑屏幕，平板电脑，智能手机等

- `print` 用于打印机和打印预览

### 媒体功能
- `width` 定义输出设备中的页面可见区域宽度

- `heigth` 定义输出设备中的页面可见区域高度

- `min-width` 定义输出设备中的页面最小可见区域宽度

- `max-width` 定义输出设备中的页面最大可见区域宽度

- `min-height` 定义输出设备中的页面最小可见区域高度

- `max-height` 定义输出设备中的页面最大可见区域高度

- `device-width` 定义输出设备的屏幕可见宽度

- `device-height` 定义输出设备的屏幕可见高度

- `orientation` 定义输出设备中的页面可见区域高度是否大于或等于宽度
  - `portrait` 竖屏 页面可见区域高度大于或等于宽度
  - `landscape` 横屏 页面可见区域高度小于宽度

### meida大全

``` css
<style>
    /* iphone3 */
    @media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:1) {
    }
    @media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:1) and (orientation:portrait) {
    }
    @media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:1) and (orientation:landscape) {
    }

    /*iphone  4 (retina)*/
    @media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) {
    }
    @media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) and (orientation:portrait) {
    }
    @media only screen and (min-device-width:320px) and (max-device-width:480px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) and (orientation:landscape) {
    }

    /*iphone 5*/
    @media only screen and (min-device-width:320px) and (max-device-width:568px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) {
    }
    @media only screen and (min-device-width:320px) and (max-device-width:568px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) and (orientation:portrait) {
    }
    @media only screen and (min-device-width:320px) and (max-device-width:568px)  and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) and (orientation:landscape) {
    }

    /*ipads (all) */
    @media only screen and (min-device-width:768px) and (max-device-width:1024px) {
    }
    @media only screen and (min-device-width:768px) and (max-device-width:1024px) and (orientation:portrait) {
    }
    @media only screen and (min-device-width:768px) and (max-device-width:1024px) and (orientation:landscape) {
    }

    /* ipad-retina */
    @media screen and (min-device-width:768px) and (max-device-width:1024px)  and (-webkit-device-pixel-ratio:2) {
    }
    @media screen and (min-device-width:768px) and (max-device-width:1024px)  and (-webkit-device-pixel-ratio:2) and (orientation:portrait) {
    }
    @media screen and (min-device-width:768px) and (max-device-width:1024px)  and (-webkit-device-pixel-ratio:2) and (orientation:landscape) {
    }

    /* iPhone 6 */
    /* Landscape */
    @media only screen 
    and (min-device-width:375px) /* or 213.4375em or 3in or 9cm */
    and (max-device-width:667px) /* or 41.6875em */
    and (width:667px)  /* or 41.6875em */
    and (height:375px)  /* or 23.4375em */
    and (orientation:landscape) 
    and (color:8)
    and (device-aspect-ratio:375/667)
    and (aspect-ratio:667/375)
    and (device-pixel-ratio:2)
    and (-webkit-min-device-pixel-ratio:2) {
    }

    /* Portrait */
    @media only screen 
    and (min-device-width:375px)  /* or 213.4375em */
    and (max-device-width:667px)  /* or 41.6875em */
    and (width:375px)  /* or 23.4375em */
    and (height:559px)  /* or 34.9375em */
    and (orientation:portrait) 
    and (color:8)
    and (device-aspect-ratio:375/667)
    and (aspect-ratio:375/559)
    and (device-pixel-ratio:2)
    and (-webkit-min-device-pixel-ratio:2) {
    }

    /* ----------- iPhone 6+ ----------- */

    /* Portrait and Landscape */
    @media only screen 
      and (min-device-width: 414px) 
      and (max-device-width: 736px) 
      and (-webkit-min-device-pixel-ratio: 3) { 

    }

    /* Portrait */
    @media only screen 
      and (min-device-width: 414px) 
      and (max-device-width: 736px) 
      and (-webkit-min-device-pixel-ratio: 3)
      and (orientation: portrait) { 
    }

    /* Landscape */
    @media only screen 
      and (min-device-width: 414px) 
      and (max-device-width: 736px) 
      and (-webkit-min-device-pixel-ratio: 3)
      and (orientation: landscape) { 

    }

</style>
```
[常见移动设备的 CSS3 Media Query 整理（iPhone/iPad/Galaxy/HTC One etc.）](https://segmentfault.com/a/1190000002711737)
[Media Queries for Standard Devices](https://css-tricks.com/snippets/css/media-queries-for-standard-devices/)


---

#blog30 


---

#blog (bootstrap)

---

---

#blog (es6)

---

---

#blog (mvc)

---

---

#blog angular

---

---

#blog vue

---

---

#blog react

---

---

#blog (构建工具 gulp & grunt)

---

---

#blog (Node.js)

---

---

#blog (移动端)

---

---

#blog (移动端web)

---

---

#blog (移动端app)

---
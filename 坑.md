##1. 字符串与数字
``` javascript
<script>
	var str = '123a';
	console.log(typeof str++);	//number
	console.log(str);	//NaN

	//字符串内为非纯数字时++为NaN，数据类型number
</script>

```
``` javascript
<script>
	var str = '123';
	console.log(typeof str++);	//number
	console.log(str);	//124	123+1

</script>

```

##2. 闭包
``` javascript
<script>
	for(var i=0; i<2; i++) {
		setTimeout(function(){
			alert(i);
		}, 2000);
	}	// 结果：两秒后alert两次2，两秒后i已为2，然后执行两次循环
</script>

```
闭包写法：

``` javascript
<script>
	for(var i=0; i<2; i++) {
		(function(a){
			setTimeout(function(){
				alert(a);
			},2000);
		})(i);
	}	// 结果：两秒后alert 0、1
</script>

```

##3. 严格模式
**非严格模式下，没有用var定义变量时为全局变量，全局的东西都属于window**
``` javascript
<script>
	function show(){
		a = 12;		// a没有var时a为全局变量
		alert(a);	// 1. 12
	}
	show();		// 需先调用show函数
	alert(a);	// 2. 12
</script>
```

``` javascript
<script>
	var a = 5;
	if(a % 2) {
		function show() {
			alert('单数');
		}
	} else {
		function show() {
			alert('双数');
		}
	}
	show();	// 单数 最新版高级浏览器中预解析不会覆盖，之前版本预解析后此例预解析覆盖 弹出双数
</script>
```
**严格模式不允许if/for里面定义函数**
``` javascript
<script>
	'use strict';
	var a = 5;
	if(a % 2) {
		function show() {
			alert('单数');
		}
	} else {
		function show() {
			alert('双数');
		}
	}
	show();	// show is not defined，严格模式不允许if/for里面定义函数
</script>
```
##4. 连等及逗号运算符
1. 连等
函数内部使用连等定义变量，第一个是局部变量，其余是全局变量

``` javascript
<script>
	function show(){
		var a=b=c=1;	//a是局部变量，b、c是全局变量
	}
</script>
```

2. 逗号运算符
逗号运算符 以最后一个为准

``` javascript
<script>
	var a=(1,2,3);	// a=3

	for(var i=0, j=5, k=8; i<10, j<10, k<10; i++, j++, k++) {

	}
	alert(i+j+k);	// 2+7+10=19
</script>
```

## 5. relative && absolute

- position:relative 会相对于浏览器8px margin定位
- position:absolute 不会相对于浏览器8px margin定位

## 6. img的bug
多个img时上下有间距

解决方法：img{vertical-align: top;}

## 7. 鼠标移入移出
- obj.onmouseover  鼠标移入时触发

- obj.onmouseout   鼠标移出时触发

**问题**

问题1：移入子级也算重新移入
解决1：onmouseover -> onmouseenter

问题2：移出子级也算移出
解决2：onmouseout -> onmouseleave

## 7. 定时器interval的问题

1.时间不能设置太小的值

eg:设置0其实会超出0

``` javascript
<script>
	var a = 6;
	setTimeout(function(){
		a = 66;
	},0);
	alert(a);	//6
</script>
```

2.时间值越小越不稳定

3.打开其他窗口时，该窗口定时器时间会变长

> *定时器的最佳时间：30ms (时间过小，程序性能开销大)

## 8. 预解析
变量和函数的定义会预先解析，解析在**script标签内**的最上面

eg:
``` javascript
<script>
	var a = 111;
	function show(){
		alert(a);	// 相当于 var a; alert(a);
		var a = 12;	 // a = 12;
	}
	show();		// 返回undefined(弹出undefined)
</script>
```

eg:
``` javascript
<script>
	show(12);  // show in not defined
</script>
<script>
	// 函数预解析在该script标签最上面
	function show(a) {
		alert(a);
	}
</script>
```

## 9.

``` javascript
<script>
	function Foo() {
		getName = function() {
			alert(1);
		};
		return this;
	}
	Foo.getName = function() {  // 静态属性
		alert(2);
	};
	Foo.prototype.getName = function() {  //原型对象上创建函数
		alert(3);
	};
	var getName = function() {  // 匿名函数变量表达式，预解析var getName;
		alert(4);
	};

	function getName() {  // 函数声明，预解析function getName() {...}
		alert(5);
	}

	// 解析过程：
	// var getName;

	// function Foo() {
	// 	...
	// }

	// function getName() {
	// 	...
	// }

	// function Foo() {
	// 	getName = function() {  //这是函数赋值语句，没有var，非函数变量表达式，不提前解析
	// 		alert(1);
	// 	};
	// 	return this;
	// }

	// Foo.getName = function() {
	// 	alert(2);
	// };
	// Foo.prototype.getName = function() {
	// 	alert(3);
	// };
	// getName = function() {  // 最终getName()
	// 	alert(4);
	// };

	//答案：
	Foo.getName(); //2  访问静态属性
	getName(); //4  查找变量getName
	Foo().getName(); //1  执行Foo()函数并调用函数内的getName()，最后为window.getName()
	getName(); //1  window.getName()已改变
	new Foo.getName(); //2  ()优先级高于new 优先级排序后为new (Foo.getName)();
	new Foo().getName(); //3  优先级排序后为(new Foo()).getName()
	new new Foo().getName(); //3  优先级排序后为new ((new Foo()).getName)()
</script>
```

[一道常被人轻视的前端JS面试题](https://gold.xitu.io/entry/580cdbeec4c9710058943151?from=groupmessage&isappinstalled=1)

## 10. 闭包
``` javascript
<script>
	function fun(n, o) {
		console.log(o)
		return {
			fun: function(m) {  // 使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。
				return fun(m, n);  // return出去的是第一层fun()函数
			}
		};
	}

	// 答案：
	var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);	//undefined,0,0,0  后三次都为调用第二层fun()函数
	var b = fun(0).fun(1).fun(2).fun(3);				//undefined,0,1,2  分别为第一层、第二层、第三层、第三层
	var c = fun(0).fun(1);  c.fun(2);  c.fun(3);		//undefined,0,1,1  分别为第一层、第二层(此时第二层m为1) 第三层 第三层
</script>
```

[大部分人都会做错的经典JS闭包面试题](http://www.cnblogs.com/xxcanghai/p/4991870.html)